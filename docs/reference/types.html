<HTML>
<HEAD>
<TITLE>Modula-3: Types</TITLE>
<LINK HREF="/cm3/normal.css" REL="stylesheet" TYPE="text/css"></head>
<body>

<P>
<A HREF="m3.html">[top]</A>
<A HREF="defns.html">[prev]</A>
<A HREF="ordinal.html">[next]</A>
<P>

<H2>Types</H2>
<P>

<BLOCKQUOTE><EM>
I am the voice of today, the herald of tomorrow...  
I am the leaden army that conquers the world---I am TYPE.  
---Frederic William Goudy
</EM></BLOCKQUOTE>
<P>

<A NAME=idx.28>Modula-3</A>
uses structural equivalence, instead of the name equivalence
of Modula-2.  Two types are the same if their definitions become the
same when expanded; that is, when all constant expressions are replaced
by their values and all type names are replaced by their definitions.
In the case of recursive types, the expansion is the infinite limit
of the partial expansions.  A type expression is generally allowed
wherever a type is required.
<P>

<A NAME=idx.29>A</A>
type is <EM>empty</EM> if it contains no values.  For example,
<TT>[1..0]</TT> is an empty type.  Empty types can be used to build non-empty 
types (for example, <TT>SET OF [1..0]</TT>, which is not empty because 
it contains the empty set).  It is a static error to declare a variable 
of an empty type.
<P>

Every expression has a statically-determined type, which contains 
every value that the expression can produce.  The type of a designator 
is the type of the variable it produces. 
<P>

Assignability and type compatibility are defined in terms of a single
syntactically specified subtype relation with the property that if
<TT>T</TT> is a subtype of <TT>U</TT>, then every member of <TT>T</TT>
is a member of <TT>U</TT>.  The subtype relation is reflexive and transitive.
<P>

Every expression has a unique type, but a value can be a member of 
many types.  For example, the value <TT>6</TT> is a member of both
<TT>[0..9]</TT> and <TT>INTEGER</TT>.  It would be ambiguous to talk
about "the type of a value".  Thus the phrase "type of <TT>x</TT>"
means "type of the expression <TT>x</TT>", while "<TT>x</TT> is a
member of <TT>T</TT>" means "the value of <TT>x</TT> is a member of
<TT>T</TT>".  
<P>

<A NAME=idx.30>However,</A>
there is one sense in which a value can be said to have 
a type: every object or traced reference value includes a code 
for a type, called the <EM>allocated type</EM> of the reference value. 
The allocated type is tested by <A HREF="typecase.html"><TT>TYPECASE</TT></A>.
<P>

The type constructors and subtyping rules are discussed below
<UL>
<LI><A HREF="ordinal.html">Ordinal types</A>
<LI><A HREF="floats.html">Floating-point types</A>
<LI><A HREF="arrays.html">Array types</A>
<LI><A HREF="records.html">Record types</A>
<LI><A HREF="packed.html">Packed types</A>
<LI><A HREF="sets.html">Set types</A>
<LI><A HREF="refs.html">Reference types</A>
<LI><A HREF="procs.html">Procedure types</A>
<LI><A HREF="objects.html">Object types</A>
<LI><A HREF="subtypes.html">Subtyping rules</A>
<LI><A HREF="builtin.html">Predeclared opaque types</A>
</UL>
<P>

<P>
<A HREF="m3.html">[top]</A>
<A HREF="defns.html">[prev]</A>
<A HREF="ordinal.html">[next]</A>
</BODY>
</HTML>
