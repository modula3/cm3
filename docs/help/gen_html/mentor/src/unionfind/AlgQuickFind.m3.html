<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: mentor/src/unionfind/AlgQuickFind.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>mentor/src/unionfind/AlgQuickFind.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1994, Digital Equipment Corporation                         
 All rights reserved.                                                      
 See the file COPYRIGHT for a full description.                            
                                                                           
 Last modified on Thu Aug 18 14:17:20 PDT 1994 by heydon                   

<P><PRE>MODULE <module><implements><A HREF="AlgQuickFind.i3.html">AlgQuickFind</A></implements></module>;

IMPORT <A HREF="../../derived/UnionFindAlgClass.i3.html">UnionFindAlgClass</A>, <A HREF="../../derived/UnionFindIE.i3.html">UnionFindIE</A>;
IMPORT <A HREF="UFInput.i3.html">UFInput</A>, <A HREF="TreeNode.i3.html">TreeNode</A>;
IMPORT <A HREF="../../../zeus/src/Algorithm.i3.html">Algorithm</A>, <A HREF="../../../zeus/src/ZeusPanel.i3.html">ZeusPanel</A>;
IMPORT <A HREF="../../../ui/src/vbt/VBT.i3.html">VBT</A>;
IMPORT <A HREF="../../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>;

TYPE
  T = UnionFindAlgClass.T BRANDED OBJECT OVERRIDES
    run := Run
  END;
  Node = TreeNode.T OBJECT
    next: Node
  METHODS
    init(): Node := Init
  END;
  Nodes = REF ARRAY OF Node;

PROCEDURE <A NAME="Init"><procedure>Init</procedure></A>(n: Node): Node =
  BEGIN
    n.rank := 1;
    n.up := n;
    n.next := n;
    RETURN n
  END Init;

PROCEDURE <A NAME="Run"><procedure>Run</procedure></A>(alg: T) RAISES {Thread.Alerted} =
  VAR ufin: UFInput.T; nodes: Nodes; cmd: UFInput.Cmd; BEGIN
    TRY
      ufin := UFInput.New(alg.data);
      IF ufin # NIL THEN
        nodes := Setup(alg, ufin);
    	WHILE ufin.next(cmd) DO
    	  TYPECASE cmd OF &lt;* NOWARN *&gt;
    	    UFInput.FindCmd (find) =&gt;    EVAL Find(alg, nodes, find)
    	  | UFInput.UnionCmd (union) =&gt;  EVAL Union(alg, nodes, union)
    	  END
    	END
      END
    EXCEPT
      UFInput.Error (txt) =&gt;
        LOCK VBT.mu DO
          ZeusPanel.ReportError(&quot;Bad input: &quot; &amp; txt &amp; &quot;\n&quot;)
        END
    END
  END Run;

PROCEDURE <A NAME="Setup"><procedure>Setup</procedure></A>(alg: T; ufin: UFInput.T): Nodes
    RAISES {UFInput.Error, Thread.Alerted} =
  VAR numSets := 0; cmd: UFInput.Cmd; res: Nodes; BEGIN
    UnionFindIE.Setup(alg);
    WHILE ufin.next(cmd) DO
      TYPECASE cmd OF &lt;* NOWARN *&gt;
        UFInput.NewSetCmd (newSet) =&gt;
          UnionFindIE.NewSet(alg, newSet.arg1); INC(numSets)
      | UFInput.FinishedSetsCmd =&gt;
          UnionFindIE.FinishedSets(alg, numSets, usesRanks := TRUE); EXIT
      END
    END;
    res := NEW(Nodes, numSets);
    FOR i := 0 TO numSets - 1 DO
      res[i] := NEW(Node, id := i).init()
    END;
    RETURN res
  END Setup;

PROCEDURE <A NAME="Find"><procedure>Find</procedure></A>(alg: T; nodes: Nodes; cmd: UFInput.FindCmd): Node
    RAISES {UFInput.Error, Thread.Alerted} =
  VAR root: Node; BEGIN
    IF cmd.arg1 &gt; LAST(nodes^) THEN
      RAISE UFInput.Error(&quot;Find: set &quot; &amp;Fmt.Int(cmd.arg1)&amp; &quot; does not exist&quot;)
    END;
    WITH node = nodes[cmd.arg1] DO
      UnionFindIE.StartFind(alg, node.id);
      root := DoFind(alg, node);
    END;
    UnionFindIE.EndFind(alg, root.id);
    RETURN root
  END Find;

PROCEDURE <A NAME="Union"><procedure>Union</procedure></A>(alg: T; nodes: Nodes; cmd: UFInput.UnionCmd): Node
    RAISES {UFInput.Error, Thread.Alerted} =
  BEGIN
    IF cmd.arg1 &gt; LAST(nodes^) THEN
      RAISE UFInput.Error(&quot;Union: set &quot; &amp;Fmt.Int(cmd.arg1)&amp; &quot; does not exist&quot;)
    ELSIF cmd.arg2 &gt; LAST(nodes^) THEN
      RAISE UFInput.Error(&quot;Union: set &quot; &amp;Fmt.Int(cmd.arg2)&amp; &quot; does not exist&quot;)
    END;
    VAR node1 := nodes[cmd.arg1]; node2 := nodes[cmd.arg2]; BEGIN
      UnionFindIE.StartUnion(alg, node1.id, node2.id, cmd.bothRoots);
      IF NOT cmd.bothRoots THEN
      	node1 := DoFind(alg, node1);
      	UnionFindIE.FoundFirst(alg, node1.id);
      	node2 := DoFind(alg, node2)
      END;
      IF node1 # node2 THEN
        UnionFindIE.CompareRanks(alg, node1.id, node2.id);
        IF node1.rank &lt; node2.rank THEN
          VAR t := node1; BEGIN node1 := node2; node2 := t END
        END;
        node2.up := node1;
        INC(node1.rank, node2.rank);
        UnionFindIE.Unite(alg, node2.id, node1.id, pRank := node1.rank - 1);
        VAR curr := node2.next; BEGIN
          WHILE curr # node2 DO
            UnionFindIE.ChangeParent(alg, curr.id, curr.up.id, node1.id);
            curr.up := node1;
            curr := curr.next
          END
        END;
        VAR t := node2.next; BEGIN
          node2.next := node1.next; node1.next := t
        END
      END;
      UnionFindIE.EndUnion(alg);
      RETURN node1
    END
  END Union;

PROCEDURE <A NAME="DoFind"><procedure>DoFind</procedure></A>(alg: T; node: Node): Node RAISES {Thread.Alerted} =
  VAR root: Node; BEGIN
    UnionFindIE.StartDoFind(alg, node.id);
    IF node.up # node THEN
      UnionFindIE.StepUp(alg, node.id, node.up.id);
    END;
    root := node.up;
    UnionFindIE.Found(alg, root.id);
    UnionFindIE.EndDoFind(alg, node.id);
    RETURN root
  END DoFind;

PROCEDURE <A NAME="New"><procedure>New</procedure></A>(): Algorithm.T =
  BEGIN
    RETURN NEW(T, data := ZeusPanel.NewForm(&quot;UnionFind.fv&quot;)).init()
  END New;

BEGIN
  ZeusPanel.RegisterAlg(New, &quot;List, Union by Rank&quot;, &quot;UnionFind&quot;)
END AlgQuickFind.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
