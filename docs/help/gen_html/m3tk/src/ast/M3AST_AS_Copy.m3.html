<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: m3tk/src/ast/M3AST_AS_Copy.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>m3tk/src/ast/M3AST_AS_Copy.m3</H2></A><HR>
<inModule>
<PRE></PRE>*************************************************************************
                      Copyright (C) Olivetti 1989                        
                          All Rights reserved                            
                                                                         
 Use and copy of this software and preparation of derivative works based 
 upon this software are permitted to any person, provided this same      
 copyright notice and the following Olivetti warranty disclaimer are      
 included in any copy of the software or any modification thereof or     
 derivative work therefrom made by any person.                           
                                                                         
 This software is made available AS IS and Olivetti disclaims all        
 warranties with respect to this software, whether expressed or implied  
 under any law, including all implied warranties of merchantibility and  
 fitness for any purpose. In no event shall Olivetti be liable for any   
 damages whatsoever resulting from loss of use, data or profits or       
 otherwise arising out of or in connection with the use or performance   
 of this software.                                                       
*************************************************************************

 Copyright (C) 1991, Digital Equipment Corporation           
 All rights reserved.                                        
 See the file COPYRIGHT for a full description.              

<P><PRE>MODULE <module>M3AST_AS_Copy</module> EXPORTS <A HREF="M3AST_AS_Copy.i3.html"><implements>M3AST_AS_Copy</A></implements>, <A HREF="M3AST_PG_Copy.i3.html"><implements>M3AST_PG_Copy</A></implements>;

IMPORT <A HREF="../gast/AST.i3.html">AST</A>, <A HREF="M3AST_LX.i3.html">M3AST_LX</A>, <A HREF="M3AST_AS.i3.html">M3AST_AS</A>, <A HREF="M3AST_PG.i3.html">M3AST_PG</A>;
IMPORT <A HREF="M3AST_LX_F.i3.html">M3AST_LX_F</A>, <A HREF="M3AST_AS_F.i3.html">M3AST_AS_F</A>, <A HREF="M3AST_PG_F.i3.html">M3AST_PG_F</A>;

IMPORT <A HREF="../gast/AST_CopyRep.i3.html">AST_CopyRep</A>;
IMPORT
    <A HREF="../../derived/SeqM3AST_AS_IMPORTED.i3.html">SeqM3AST_AS_IMPORTED</A>,
    <A HREF="../../derived/SeqM3AST_AS_Import_item.i3.html">SeqM3AST_AS_Import_item</A>, <A HREF="../../derived/SeqM3AST_AS_F_Interface_id.i3.html">SeqM3AST_AS_F_Interface_id</A>,
    <A HREF="../../derived/SeqM3AST_AS_Used_interface_id.i3.html">SeqM3AST_AS_Used_interface_id</A>, <A HREF="../../derived/SeqM3AST_AS_Used_def_id.i3.html">SeqM3AST_AS_Used_def_id</A>,
    <A HREF="../../derived/SeqM3AST_AS_REVELATION.i3.html">SeqM3AST_AS_REVELATION</A>, <A HREF="../../derived/SeqM3AST_AS_DECL_REVL.i3.html">SeqM3AST_AS_DECL_REVL</A>,
    <A HREF="../../derived/SeqM3AST_AS_Const_decl.i3.html">SeqM3AST_AS_Const_decl</A>, <A HREF="../../derived/SeqM3AST_AS_TYPE_DECL.i3.html">SeqM3AST_AS_TYPE_DECL</A>,
    <A HREF="../../derived/SeqM3AST_AS_Var_decl.i3.html">SeqM3AST_AS_Var_decl</A>, <A HREF="../../derived/SeqM3AST_AS_Exc_decl.i3.html">SeqM3AST_AS_Exc_decl</A>,
    <A HREF="../../derived/SeqM3AST_AS_Var_id.i3.html">SeqM3AST_AS_Var_id</A>,
    <A HREF="../../derived/SeqM3AST_AS_Enum_id.i3.html">SeqM3AST_AS_Enum_id</A>, <A HREF="../../derived/SeqM3AST_AS_Field_id.i3.html">SeqM3AST_AS_Field_id</A>,
    <A HREF="../../derived/SeqM3AST_AS_FORMAL_ID.i3.html">SeqM3AST_AS_FORMAL_ID</A>, <A HREF="../../derived/SeqM3AST_AS_Qual_used_id.i3.html">SeqM3AST_AS_Qual_used_id</A>,
    <A HREF="../../derived/SeqM3AST_AS_Fields.i3.html">SeqM3AST_AS_Fields</A>, <A HREF="../../derived/SeqM3AST_AS_Method.i3.html">SeqM3AST_AS_Method</A>,
    <A HREF="../../derived/SeqM3AST_AS_M3TYPE.i3.html">SeqM3AST_AS_M3TYPE</A>,
    <A HREF="../../derived/SeqM3AST_AS_Formal_param.i3.html">SeqM3AST_AS_Formal_param</A>, <A HREF="../../derived/SeqM3AST_AS_CONS_ELEM.i3.html">SeqM3AST_AS_CONS_ELEM</A>,
    <A HREF="../../derived/SeqM3AST_AS_EXP.i3.html">SeqM3AST_AS_EXP</A>, <A HREF="../../derived/SeqM3AST_AS_Actual.i3.html">SeqM3AST_AS_Actual</A>,
    <A HREF="../../derived/SeqM3AST_AS_Case.i3.html">SeqM3AST_AS_Case</A>, <A HREF="../../derived/SeqM3AST_AS_STM.i3.html">SeqM3AST_AS_STM</A>,
    <A HREF="../../derived/SeqM3AST_AS_Elsif.i3.html">SeqM3AST_AS_Elsif</A>, <A HREF="../../derived/SeqM3AST_AS_Tcase.i3.html">SeqM3AST_AS_Tcase</A>,
    <A HREF="../../derived/SeqM3AST_AS_Handler.i3.html">SeqM3AST_AS_Handler</A>, <A HREF="../../derived/SeqM3AST_AS_Binding.i3.html">SeqM3AST_AS_Binding</A>,
    <A HREF="../../derived/SeqM3AST_AS_RANGE_EXP.i3.html">SeqM3AST_AS_RANGE_EXP</A>, <A HREF="../../derived/SeqM3AST_AS_Override.i3.html">SeqM3AST_AS_Override</A>;
</PRE>PRIVATE
<PRE>PROCEDURE <A NAME="CopySeqStm"><procedure>CopySeqStm</procedure></A>(seqStm: SeqM3AST_AS_STM.T; h: AST_CopyRep.Handle
    ): SeqM3AST_AS_STM.T
    RAISES ANY =
  VAR
    m, n_m: M3AST_AS.STM;
    iter := SeqM3AST_AS_STM.NewIter(seqStm);
    n_seqStm := SeqM3AST_AS_STM.Null;
  BEGIN
    WHILE SeqM3AST_AS_STM.Next(iter, m) DO
      n_m := h.Copy(m);
      SeqM3AST_AS_STM.AddRear(n_seqStm, n_m);
    END;
    RETURN n_seqStm;
  END CopySeqStm;
</PRE>PRIVATE
<PRE>PROCEDURE <A NAME="CopyEXTERNAL_DECL"><procedure>CopyEXTERNAL_DECL</procedure></A>(n: M3AST_PG.External_NULL;
    h: AST_CopyRep.Handle): M3AST_PG.External_NULL RAISES ANY=
  VAR cn: M3AST_PG.External_NULL := NIL;
  BEGIN
    IF n # NIL THEN
      cn := h.Copy(n)
    END;
    RETURN cn;
  END CopyEXTERNAL_DECL;
</PRE>PRIVATE
<PRE>PROCEDURE <A NAME="CopyUNIT_WITH_BODY"><procedure>CopyUNIT_WITH_BODY</procedure></A>(n, cn: M3AST_AS_F.UNIT_WITH_BODY;
    h: AST_CopyRep.Handle) RAISES ANY=
  VAR
    m2: M3AST_AS.IMPORTED;
    iter2 := SeqM3AST_AS_IMPORTED.NewIter(n.as_import_s);
  BEGIN
    WHILE SeqM3AST_AS_IMPORTED.Next(iter2, m2) DO
      SeqM3AST_AS_IMPORTED.AddRear(cn.as_import_s, h.Copy(m2));
    END;
    cn.as_block := h.Copy(n.as_block);
  END CopyUNIT_WITH_BODY;
</PRE>PRIVATE
<PRE>PROCEDURE <A NAME="CopyUNIT_GEN_DEF"><procedure>CopyUNIT_GEN_DEF</procedure></A>(n, cn: M3AST_AS_F.UNIT_GEN_DEF;
    h: AST_CopyRep.Handle) RAISES ANY=
  VAR iter := SeqM3AST_AS_F_Interface_id.NewIter(n.as_id_s);
    m: M3AST_AS.F_Interface_id;
  BEGIN
    WHILE SeqM3AST_AS_F_Interface_id.Next(iter, m) DO
      SeqM3AST_AS_F_Interface_id.AddRear(cn.as_id_s, h.Copy(m));
    END;
  END CopyUNIT_GEN_DEF;

PROCEDURE <A NAME="CopySeqUsed_interface_id"><procedure>CopySeqUsed_interface_id</procedure></A>(s: SeqM3AST_AS_Used_interface_id.T;
    h: AST_CopyRep.Handle): SeqM3AST_AS_Used_interface_id.T RAISES ANY=
  VAR
    m, n_m: M3AST_AS.Used_interface_id;
    iter := SeqM3AST_AS_Used_interface_id.NewIter(s);
    n_s := SeqM3AST_AS_Used_interface_id.Null;
  BEGIN
    WHILE SeqM3AST_AS_Used_interface_id.Next(iter, m) DO
      n_m := h.Copy(m);
      SeqM3AST_AS_Used_interface_id.AddRear(n_s, n_m);
    END;
    RETURN n_s;
  END CopySeqUsed_interface_id;

&lt;*INLINE*&gt; PROCEDURE <A NAME="ID"><procedure>ID</procedure></A>(n, cn: M3AST_AS.ID): M3AST_AS.ID RAISES {}=
  BEGIN
    cn.lx_symrep := n.lx_symrep;
    RETURN cn;
  END ID;

PROCEDURE <A NAME="SRC_NODE"><procedure>SRC_NODE</procedure></A>(n, cn: M3AST_AS.SRC_NODE): M3AST_AS.SRC_NODE RAISES {}=
  BEGIN
    cn.lx_srcpos := n.lx_srcpos;
    RETURN cn;
  END SRC_NODE;

PROCEDURE <A NAME="Module_id"><procedure>Module_id</procedure></A>(
    n: M3AST_AS_F.Module_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Module_id).init()));
  END Module_id;

PROCEDURE <A NAME="Interface_id"><procedure>Interface_id</procedure></A>(
    n: M3AST_AS_F.Interface_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Interface_id).init()));
  END Interface_id;

PROCEDURE <A NAME="F_Interface_id"><procedure>F_Interface_id</procedure></A>(
    n: M3AST_AS_F.F_Interface_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.F_Interface_id).init()));
  END F_Interface_id;

PROCEDURE <A NAME="Interface_AS_id"><procedure>Interface_AS_id</procedure></A>(
    n: M3AST_AS_F.Interface_AS_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Interface_AS_id).init()));
  END Interface_AS_id;

PROCEDURE <A NAME="F_Value_id"><procedure>F_Value_id</procedure></A>(
    n: M3AST_AS_F.F_Value_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.F_Value_id).init()));
  END F_Value_id;

PROCEDURE <A NAME="F_Var_id"><procedure>F_Var_id</procedure></A>(
    n: M3AST_AS_F.F_Var_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.F_Var_id).init()));
  END F_Var_id;

PROCEDURE <A NAME="F_Readonly_id"><procedure>F_Readonly_id</procedure></A>(
    n: M3AST_AS_F.F_Readonly_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.F_Readonly_id).init()));
  END F_Readonly_id;

PROCEDURE <A NAME="Type_id"><procedure>Type_id</procedure></A>(
    n: M3AST_AS_F.Type_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Type_id).init()));
  END Type_id;

PROCEDURE <A NAME="Const_id"><procedure>Const_id</procedure></A>(
    n: M3AST_AS_F.Const_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Const_id).init()));
  END Const_id;

PROCEDURE <A NAME="Var_id"><procedure>Var_id</procedure></A>(
    n: M3AST_AS_F.Var_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Var_id).init()));
  END Var_id;

PROCEDURE <A NAME="Proc_id"><procedure>Proc_id</procedure></A>(
    n: M3AST_AS_F.Proc_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Proc_id).init()));
  END Proc_id;

PROCEDURE <A NAME="Enum_id"><procedure>Enum_id</procedure></A>(
    n: M3AST_AS_F.Enum_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Enum_id).init()));
  END Enum_id;

PROCEDURE <A NAME="Method_id"><procedure>Method_id</procedure></A>(
    n: M3AST_AS_F.Method_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Method_id).init()));
  END Method_id;

PROCEDURE <A NAME="Override_id"><procedure>Override_id</procedure></A>(
    n: M3AST_AS_F.Override_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Override_id).init()));
  END Override_id;

PROCEDURE <A NAME="Field_id"><procedure>Field_id</procedure></A>(
    n: M3AST_AS_F.Field_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Field_id).init()));
  END Field_id;

PROCEDURE <A NAME="For_id"><procedure>For_id</procedure></A>(
    n: M3AST_AS_F.For_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.For_id).init()));
  END For_id;

PROCEDURE <A NAME="Handler_id"><procedure>Handler_id</procedure></A>(
    n: M3AST_AS_F.Handler_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Handler_id).init()));
  END Handler_id;

PROCEDURE <A NAME="Tcase_id"><procedure>Tcase_id</procedure></A>(
    n: M3AST_AS_F.Tcase_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Tcase_id).init()));
  END Tcase_id;

PROCEDURE <A NAME="With_id"><procedure>With_id</procedure></A>(
    n: M3AST_AS_F.With_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.With_id).init()));
  END With_id;

PROCEDURE <A NAME="Exc_id"><procedure>Exc_id</procedure></A>(
    n: M3AST_AS_F.Exc_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Exc_id).init()));
  END Exc_id;

PROCEDURE <A NAME="Used_interface_id"><procedure>Used_interface_id</procedure></A>(
    n: M3AST_AS_F.Used_interface_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Used_interface_id).init()));
  END Used_interface_id;

PROCEDURE <A NAME="Used_def_id"><procedure>Used_def_id</procedure></A>(
    n: M3AST_AS_F.Used_def_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN ID(n, SRC_NODE(n, NEW(M3AST_AS.Used_def_id).init()));
  END Used_def_id;

PROCEDURE <A NAME="Qual_used_id"><procedure>Qual_used_id</procedure></A>(n: M3AST_AS_F.Qual_used_id; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Qual_used_id := SRC_NODE(n, NEW(M3AST_AS.Qual_used_id).init());
  BEGIN
    IF n.as_intf_id # NIL THEN cn.as_intf_id := h.Copy(n.as_intf_id); END;
    cn.as_id := h.Copy(n.as_id);
    RETURN cn;
  END Qual_used_id;

PROCEDURE <A NAME="Compilation_Unit"><procedure>Compilation_Unit</procedure></A>(n: M3AST_AS_F.Compilation_Unit;
      h: AST_CopyRep.Handle): AST.NODE RAISES ANY =
  VAR cn: M3AST_AS.Compilation_Unit := NEW(M3AST_AS.Compilation_Unit).init();
  BEGIN
    cn.as_root := h.Copy(n.as_root);
    RETURN cn;
  END Compilation_Unit;

PROCEDURE <A NAME="Interface"><procedure>Interface</procedure></A>(n: M3AST_AS_F.Interface; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Interface := SRC_NODE(n, NEW(M3AST_AS.Interface).init());
  BEGIN
    cn.vEXTERNAL_DECL.pg_external :=
      CopyEXTERNAL_DECL(n.vEXTERNAL_DECL.pg_external, h);
    IF n.as_unsafe # NIL THEN cn.as_unsafe := h.Copy(n.as_unsafe); END;
    cn.as_id := h.Copy(n.as_id);
    CopyUNIT_WITH_BODY(n, cn, h);
    RETURN cn;
  END Interface;

PROCEDURE <A NAME="Module"><procedure>Module</procedure></A>(n: M3AST_AS_F.Module; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Module := SRC_NODE(n, NEW(M3AST_AS.Module).init());
  BEGIN
    IF n.as_unsafe # NIL THEN cn.as_unsafe := h.Copy(n.as_unsafe); END;
    cn.as_id := h.Copy(n.as_id);
    cn.as_export_s := CopySeqUsed_interface_id(n.as_export_s, h);
    CopyUNIT_WITH_BODY(n, cn, h);
    RETURN cn;
  END Module;

PROCEDURE <A NAME="Interface_gen_def"><procedure>Interface_gen_def</procedure></A>(n: M3AST_AS_F.Interface_gen_def;
    h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Interface_gen_def := SRC_NODE(n, NEW(M3AST_AS.Interface_gen_def).init());
  BEGIN
    cn.vEXTERNAL_DECL.pg_external :=
      CopyEXTERNAL_DECL(n.vEXTERNAL_DECL.pg_external, h);
    cn.as_id := h.Copy(n.as_id);
    CopyUNIT_GEN_DEF(n, cn, h);
    CopyUNIT_WITH_BODY(n, cn, h);
    RETURN cn;
  END Interface_gen_def;

PROCEDURE <A NAME="Module_gen_def"><procedure>Module_gen_def</procedure></A>(n: M3AST_AS_F.Module_gen_def;
    h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Module_gen_def := SRC_NODE(n, NEW(M3AST_AS.Module_gen_def).init());
  BEGIN
    cn.as_id := h.Copy(n.as_id);
    CopyUNIT_GEN_DEF(n, cn, h);
    CopyUNIT_WITH_BODY(n, cn, h);
    RETURN cn;
  END Module_gen_def;

PROCEDURE <A NAME="Interface_gen_ins"><procedure>Interface_gen_ins</procedure></A>(n: M3AST_AS_F.Interface_gen_ins;
    h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Interface_gen_ins := SRC_NODE(n, NEW(M3AST_AS.Interface_gen_ins).init());
  BEGIN
    IF n.as_unsafe # NIL THEN cn.as_unsafe := h.Copy(n.as_unsafe); END;
    cn.as_id := h.Copy(n.as_id);
    cn.as_gen_id := h.Copy(n.as_gen_id);
    cn.as_id_s := CopySeqUsed_interface_id(n.as_id_s, h);
    RETURN cn;
  END Interface_gen_ins;

PROCEDURE <A NAME="Module_gen_ins"><procedure>Module_gen_ins</procedure></A>(n: M3AST_AS_F.Module_gen_ins;
    h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Module_gen_ins := SRC_NODE(n, NEW(M3AST_AS.Module_gen_ins).init());
  BEGIN
    IF n.as_unsafe # NIL THEN cn.as_unsafe := h.Copy(n.as_unsafe); END;
    cn.as_id := h.Copy(n.as_id);
    cn.as_export_s := CopySeqUsed_interface_id(n.as_export_s, h);
    cn.as_gen_id := h.Copy(n.as_gen_id);
    cn.as_id_s := CopySeqUsed_interface_id(n.as_id_s,h);
    RETURN cn;
  END Module_gen_ins;

PROCEDURE <A NAME="Unsafe"><procedure>Unsafe</procedure></A>(
    n: M3AST_AS_F.Unsafe; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.Unsafe).init());
  END Unsafe;

PROCEDURE <A NAME="Simple_import"><procedure>Simple_import</procedure></A>(n: M3AST_AS_F.Simple_import; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Simple_import := SRC_NODE(n, NEW(M3AST_AS.Simple_import).init());
  VAR
    m: M3AST_AS.Import_item;
    iter := SeqM3AST_AS_Import_item.NewIter(n.as_import_item_s);
  BEGIN
    VAR ns := SeqM3AST_AS_Import_item.Null;
    BEGIN
    WHILE SeqM3AST_AS_Import_item.Next(iter, m) DO
      SeqM3AST_AS_Import_item.AddRear(ns, h.Copy(m));
    END;
    cn.as_import_item_s := ns;
    END;
    RETURN cn;
  END Simple_import;

PROCEDURE <A NAME="Import_item"><procedure>Import_item</procedure></A>(
    n: M3AST_AS_F.Import_item; h: AST_CopyRep.Handle;
    ): AST.NODE RAISES ANY =
  VAR cn: M3AST_AS.Import_item := SRC_NODE(n, NEW(M3AST_AS.Import_item).init());
  BEGIN
    cn.as_intf_id := h.Copy(n.as_intf_id);
    IF n.as_id # NIL THEN cn.as_id := h.Copy(n.as_id); END;
    RETURN cn;
  END Import_item;

PROCEDURE <A NAME="From_import"><procedure>From_import</procedure></A>(n: M3AST_AS_F.From_import; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.From_import := SRC_NODE(n, NEW(M3AST_AS.From_import).init());
  VAR
    m: M3AST_AS.Used_def_id;
    iter := SeqM3AST_AS_Used_def_id.NewIter(n.as_id_s);
  BEGIN
    cn.as_intf_id := h.Copy(n.as_intf_id);
    VAR ns := SeqM3AST_AS_Used_def_id.Null;
    BEGIN
    WHILE SeqM3AST_AS_Used_def_id.Next(iter, m) DO
      SeqM3AST_AS_Used_def_id.AddRear(ns, h.Copy(m));
    END;
    cn.as_id_s := ns;
    END;
    RETURN cn;
  END From_import;

PROCEDURE <A NAME="Revelation_s"><procedure>Revelation_s</procedure></A>(n: M3AST_AS_F.Revelation_s; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Revelation_s := SRC_NODE(n, NEW(M3AST_AS.Revelation_s).init());
  VAR
    m: M3AST_AS.REVELATION;
    iter := SeqM3AST_AS_REVELATION.NewIter(n.as_reveal_s);
  BEGIN
    VAR ns := SeqM3AST_AS_REVELATION.Null;
    BEGIN
    WHILE SeqM3AST_AS_REVELATION.Next(iter, m) DO
      SeqM3AST_AS_REVELATION.AddRear(ns, h.Copy(m));
    END;
    cn.as_reveal_s := ns;
    END;
    RETURN cn;
  END Revelation_s;

PROCEDURE <A NAME="Const_decl_s"><procedure>Const_decl_s</procedure></A>(n: M3AST_AS_F.Const_decl_s; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Const_decl_s := SRC_NODE(n, NEW(M3AST_AS.Const_decl_s).init());
  VAR
    m: M3AST_AS.Const_decl;
    iter := SeqM3AST_AS_Const_decl.NewIter(n.as_const_decl_s);
  BEGIN
    cn.vEXTERNAL_DECL.pg_external :=
      CopyEXTERNAL_DECL(n.vEXTERNAL_DECL.pg_external, h);
    VAR ns := SeqM3AST_AS_Const_decl.Null;
    BEGIN
    WHILE SeqM3AST_AS_Const_decl.Next(iter, m) DO
      SeqM3AST_AS_Const_decl.AddRear(ns, h.Copy(m));
    END;
    cn.as_const_decl_s := ns;
    END;
    RETURN cn;
  END Const_decl_s;

PROCEDURE <A NAME="Type_decl_s"><procedure>Type_decl_s</procedure></A>(n: M3AST_AS_F.Type_decl_s; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Type_decl_s := SRC_NODE(n, NEW(M3AST_AS.Type_decl_s).init());
  VAR
    m: M3AST_AS.TYPE_DECL;
    iter := SeqM3AST_AS_TYPE_DECL.NewIter(n.as_type_decl_s);
  BEGIN
    cn.vEXTERNAL_DECL.pg_external :=
      CopyEXTERNAL_DECL(n.vEXTERNAL_DECL.pg_external, h);
    VAR ns := SeqM3AST_AS_TYPE_DECL.Null;
    BEGIN
    WHILE SeqM3AST_AS_TYPE_DECL.Next(iter, m) DO
      SeqM3AST_AS_TYPE_DECL.AddRear(ns, h.Copy(m));
    END;
    cn.as_type_decl_s := ns;
    END;
    RETURN cn;
  END Type_decl_s;

PROCEDURE <A NAME="Var_decl_s"><procedure>Var_decl_s</procedure></A>(n: M3AST_AS_F.Var_decl_s; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Var_decl_s := SRC_NODE(n, NEW(M3AST_AS.Var_decl_s).init());
  VAR
    m: M3AST_AS.Var_decl;
    iter := SeqM3AST_AS_Var_decl.NewIter(n.as_var_decl_s);
  BEGIN
    cn.vEXTERNAL_DECL.pg_external :=
      CopyEXTERNAL_DECL(n.vEXTERNAL_DECL.pg_external, h);
    VAR ns := SeqM3AST_AS_Var_decl.Null;
    BEGIN
    WHILE SeqM3AST_AS_Var_decl.Next(iter, m) DO
      SeqM3AST_AS_Var_decl.AddRear(ns, h.Copy(m));
    END;
    cn.as_var_decl_s := ns;
    END;
    RETURN cn;
  END Var_decl_s;

PROCEDURE <A NAME="Exc_decl_s"><procedure>Exc_decl_s</procedure></A>(n: M3AST_AS_F.Exc_decl_s; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Exc_decl_s := SRC_NODE(n, NEW(M3AST_AS.Exc_decl_s).init());
  VAR
    m: M3AST_AS.Exc_decl;
    iter := SeqM3AST_AS_Exc_decl.NewIter(n.as_exc_decl_s);
  BEGIN
    cn.vEXTERNAL_DECL.pg_external :=
      CopyEXTERNAL_DECL(n.vEXTERNAL_DECL.pg_external, h);
    VAR ns := SeqM3AST_AS_Exc_decl.Null;
    BEGIN
    WHILE SeqM3AST_AS_Exc_decl.Next(iter, m) DO
      SeqM3AST_AS_Exc_decl.AddRear(ns, h.Copy(m));
    END;
    cn.as_exc_decl_s := ns;
    END;
    RETURN cn;
  END Exc_decl_s;

PROCEDURE <A NAME="Proc_decl"><procedure>Proc_decl</procedure></A>(n: M3AST_AS_F.Proc_decl; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Proc_decl := SRC_NODE(n, NEW(M3AST_AS.Proc_decl).init());
  BEGIN
    cn.vEXTERNAL_DECL.pg_external :=
      CopyEXTERNAL_DECL(n.vEXTERNAL_DECL.pg_external, h);
    IF n.pg_inline # NIL THEN cn.pg_inline := h.Copy(n.pg_inline); END;
    cn.as_id := h.Copy(n.as_id);
    cn.as_type := h.Copy(n.as_type);
    IF n.as_body # NIL THEN cn.as_body := h.Copy(n.as_body); END;
    RETURN cn;
  END Proc_decl;

PROCEDURE <A NAME="Const_decl"><procedure>Const_decl</procedure></A>(n: M3AST_AS_F.Const_decl; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Const_decl := SRC_NODE(n, NEW(M3AST_AS.Const_decl).init());
  BEGIN
    cn.as_id := h.Copy(n.as_id);
    IF n.as_type # NIL THEN cn.as_type := h.Copy(n.as_type); END;
    cn.as_exp := h.Copy(n.as_exp);
    RETURN cn;
  END Const_decl;

PROCEDURE <A NAME="Var_decl"><procedure>Var_decl</procedure></A>(n: M3AST_AS_F.Var_decl; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Var_decl := SRC_NODE(n, NEW(M3AST_AS.Var_decl).init());
  VAR
    m: M3AST_AS.Var_id;
    iter := SeqM3AST_AS_Var_id.NewIter(n.as_id_s);
  BEGIN
    VAR ns := SeqM3AST_AS_Var_id.Null;
    BEGIN
    WHILE SeqM3AST_AS_Var_id.Next(iter, m) DO
      SeqM3AST_AS_Var_id.AddRear(ns, h.Copy(m));
    END;
    cn.as_id_s := ns;
    END;
    IF n.as_type # NIL THEN cn.as_type := h.Copy(n.as_type); END;
    IF n.as_default # NIL THEN cn.as_default := h.Copy(n.as_default); END;
    RETURN cn;
  END Var_decl;

PROCEDURE <A NAME="Exc_decl"><procedure>Exc_decl</procedure></A>(n: M3AST_AS_F.Exc_decl; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Exc_decl := SRC_NODE(n, NEW(M3AST_AS.Exc_decl).init());
  BEGIN
    cn.as_id := h.Copy(n.as_id);
    IF n.as_type # NIL THEN cn.as_type := h.Copy(n.as_type); END;
    RETURN cn;
  END Exc_decl;

PROCEDURE <A NAME="Subtype_decl"><procedure>Subtype_decl</procedure></A>(n: M3AST_AS_F.Subtype_decl; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Subtype_decl := SRC_NODE(n, NEW(M3AST_AS.Subtype_decl).init());
  BEGIN
    cn.as_id := h.Copy(n.as_id);
    cn.as_type := h.Copy(n.as_type);
    RETURN cn;
  END Subtype_decl;

PROCEDURE <A NAME="Concrete_decl"><procedure>Concrete_decl</procedure></A>(n: M3AST_AS_F.Concrete_decl; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Concrete_decl := SRC_NODE(n, NEW(M3AST_AS.Concrete_decl).init());
  BEGIN
    cn.as_id := h.Copy(n.as_id);
    cn.as_type := h.Copy(n.as_type);
    RETURN cn;
  END Concrete_decl;

PROCEDURE <A NAME="Subtype_reveal"><procedure>Subtype_reveal</procedure></A>(
    n: M3AST_AS_F.Subtype_reveal;
    h: AST_CopyRep.Handle): AST.NODE RAISES ANY =
  VAR cn: M3AST_AS.Subtype_reveal := SRC_NODE(n, NEW(M3AST_AS.Subtype_reveal).init());
  BEGIN
    cn.as_qual_id := h.Copy(n.as_qual_id);
    cn.as_type := h.Copy(n.as_type);
    RETURN cn;
  END Subtype_reveal;

PROCEDURE <A NAME="Concrete_reveal"><procedure>Concrete_reveal</procedure></A>(n: M3AST_AS_F.Concrete_reveal;
    h: AST_CopyRep.Handle): AST.NODE RAISES ANY =
  VAR cn: M3AST_AS.Concrete_reveal := SRC_NODE(n, NEW(M3AST_AS.Concrete_reveal).init());
  BEGIN
    cn.as_qual_id := h.Copy(n.as_qual_id);
    cn.as_type := h.Copy(n.as_type);
    RETURN cn;
  END Concrete_reveal;

PROCEDURE <A NAME="Named_type"><procedure>Named_type</procedure></A>(n: M3AST_AS_F.Named_type; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Named_type := SRC_NODE(n, NEW(M3AST_AS.Named_type).init());
  BEGIN
    cn.as_qual_id := h.Copy(n.as_qual_id);
    RETURN cn;
  END Named_type;

PROCEDURE <A NAME="Integer_type"><procedure>Integer_type</procedure></A>(
    n: M3AST_AS_F.Integer_type; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.Integer_type).init());
  END Integer_type;

PROCEDURE <A NAME="Longint_type"><procedure>Longint_type</procedure></A>(
    n: M3AST_AS_F.Longint_type; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.Longint_type).init());
  END Longint_type;

PROCEDURE <A NAME="WideChar_type"><procedure>WideChar_type</procedure></A>(
    n: M3AST_AS_F.WideChar_type; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.WideChar_type).init());
  END WideChar_type;

PROCEDURE <A NAME="Real_type"><procedure>Real_type</procedure></A>(
    n: M3AST_AS_F.Real_type; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.Real_type).init());
  END Real_type;

PROCEDURE <A NAME="LongReal_type"><procedure>LongReal_type</procedure></A>(
    n: M3AST_AS_F.LongReal_type; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.LongReal_type).init());
  END LongReal_type;

PROCEDURE <A NAME="Extended_type"><procedure>Extended_type</procedure></A>(
    n: M3AST_AS_F.Extended_type; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.Extended_type).init());
  END Extended_type;

PROCEDURE <A NAME="Null_type"><procedure>Null_type</procedure></A>(
    n: M3AST_AS_F.Null_type; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.Null_type).init());
  END Null_type;

PROCEDURE <A NAME="RefAny_type"><procedure>RefAny_type</procedure></A>(
    n: M3AST_AS_F.RefAny_type; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.RefAny_type).init());
  END RefAny_type;

PROCEDURE <A NAME="Address_type"><procedure>Address_type</procedure></A>(
    n: M3AST_AS_F.Address_type; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.Address_type).init());
  END Address_type;

PROCEDURE <A NAME="Root_type"><procedure>Root_type</procedure></A>(
    n: M3AST_AS_F.Root_type; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  VAR cn: M3AST_AS.Root_type := SRC_NODE(n, NEW(M3AST_AS.Root_type).init());
  BEGIN
    cn.as_trace_mode := n.as_trace_mode;
    RETURN cn;
  END Root_type;

PROCEDURE <A NAME="Enumeration_type"><procedure>Enumeration_type</procedure></A>(n: M3AST_AS_F.Enumeration_type;
    h: AST_CopyRep.Handle): AST.NODE RAISES ANY =
  VAR cn: M3AST_AS.Enumeration_type := SRC_NODE(n, NEW(M3AST_AS.Enumeration_type).init());
  VAR
    m: M3AST_AS.Enum_id;
    iter := SeqM3AST_AS_Enum_id.NewIter(n.as_id_s);
  BEGIN
    VAR ns := SeqM3AST_AS_Enum_id.Null;
    BEGIN
    WHILE SeqM3AST_AS_Enum_id.Next(iter, m) DO
      SeqM3AST_AS_Enum_id.AddRear(ns, h.Copy(m));
    END;
    cn.as_id_s := ns;
    END;
    RETURN cn;
  END Enumeration_type;

PROCEDURE <A NAME="Subrange_type"><procedure>Subrange_type</procedure></A>(n: M3AST_AS_F.Subrange_type; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Subrange_type := SRC_NODE(n, NEW(M3AST_AS.Subrange_type).init());
  BEGIN
    cn.as_range := h.Copy(n.as_range);
    RETURN cn;
  END Subrange_type;

PROCEDURE <A NAME="Array_type"><procedure>Array_type</procedure></A>(n: M3AST_AS_F.Array_type; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Array_type := SRC_NODE(n, NEW(M3AST_AS.Array_type).init());
  VAR
    m: M3AST_AS.M3TYPE;
    iter := SeqM3AST_AS_M3TYPE.NewIter(n.as_indextype_s);
  BEGIN
    VAR ns := SeqM3AST_AS_M3TYPE.Null;
    BEGIN
    WHILE SeqM3AST_AS_M3TYPE.Next(iter, m) DO
      SeqM3AST_AS_M3TYPE.AddRear(ns, h.Copy(m));
    END;
    cn.as_indextype_s := ns;
    END;
    cn.as_elementtype := h.Copy(n.as_elementtype);
    RETURN cn;
  END Array_type;

PROCEDURE <A NAME="Record_type"><procedure>Record_type</procedure></A>(n: M3AST_AS_F.Record_type; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Record_type := SRC_NODE(n, NEW(M3AST_AS.Record_type).init());
  VAR
    m: M3AST_AS.Fields;
    iter := SeqM3AST_AS_Fields.NewIter(n.as_fields_s);
  BEGIN
    VAR ns := SeqM3AST_AS_Fields.Null;
    BEGIN
    WHILE SeqM3AST_AS_Fields.Next(iter, m) DO
      SeqM3AST_AS_Fields.AddRear(ns, h.Copy(m));
    END;
    cn.as_fields_s := ns;
    END;
        RETURN cn;
  END Record_type;

PROCEDURE <A NAME="Object_type"><procedure>Object_type</procedure></A>(n: M3AST_AS_F.Object_type; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Object_type := SRC_NODE(n, NEW(M3AST_AS.Object_type).init());
  VAR
    m: M3AST_AS.Fields;
    iter := SeqM3AST_AS_Fields.NewIter(n.as_fields_s);
    m2: M3AST_AS.Method;
    iter2 := SeqM3AST_AS_Method.NewIter(n.as_method_s);
    m3: M3AST_AS.Override;
    iter3 := SeqM3AST_AS_Override.NewIter(n.as_override_s);
  BEGIN
    IF n.as_ancestor # NIL THEN cn.as_ancestor := h.Copy(n.as_ancestor); END;
    IF n.as_brand # NIL THEN cn.as_brand := h.Copy(n.as_brand); END;
    VAR ns := SeqM3AST_AS_Fields.Null;
    BEGIN
    WHILE SeqM3AST_AS_Fields.Next(iter, m) DO
      SeqM3AST_AS_Fields.AddRear(ns, h.Copy(m));
    END;
    cn.as_fields_s := ns;
    END;
    VAR ns := SeqM3AST_AS_Method.Null;
    BEGIN
    WHILE SeqM3AST_AS_Method.Next(iter2, m2) DO
      SeqM3AST_AS_Method.AddRear(ns, h.Copy(m2));
    END;
    cn.as_method_s := ns;
    END;
    VAR ns := SeqM3AST_AS_Override.Null;
    BEGIN
    WHILE SeqM3AST_AS_Override.Next(iter3, m3) DO
      SeqM3AST_AS_Override.AddRear(ns, h.Copy(m3));
    END;
    cn.as_override_s := ns;
    END;
        RETURN cn;
  END Object_type;

PROCEDURE <A NAME="Set_type"><procedure>Set_type</procedure></A>(n: M3AST_AS_F.Set_type; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Set_type := SRC_NODE(n, NEW(M3AST_AS.Set_type).init());
  BEGIN
    cn.as_type := h.Copy(n.as_type);
    RETURN cn;
  END Set_type;

PROCEDURE <A NAME="Procedure_type"><procedure>Procedure_type</procedure></A>(n: M3AST_AS_F.Procedure_type;
    h: AST_CopyRep.Handle): AST.NODE RAISES ANY =
  VAR cn: M3AST_AS.Procedure_type := SRC_NODE(n, NEW(M3AST_AS.Procedure_type).init());
  VAR
    m: M3AST_AS.Formal_param;
    iter := SeqM3AST_AS_Formal_param.NewIter(n.as_formal_param_s);
  BEGIN
    VAR ns := SeqM3AST_AS_Formal_param.Null;
    BEGIN
    WHILE SeqM3AST_AS_Formal_param.Next(iter, m) DO
      SeqM3AST_AS_Formal_param.AddRear(ns, h.Copy(m));
    END;
    cn.as_formal_param_s := ns;
    END;
    IF n.as_result_type # NIL THEN cn.as_result_type := h.Copy(n.as_result_type); END;
    IF n.as_raises # NIL THEN cn.as_raises := h.Copy(n.as_raises); END;
    RETURN cn;
  END Procedure_type;

PROCEDURE <A NAME="Ref_type"><procedure>Ref_type</procedure></A>(n: M3AST_AS_F.Ref_type; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Ref_type := SRC_NODE(n, NEW(M3AST_AS.Ref_type).init());
  BEGIN
    IF n.as_trace_mode # NIL THEN cn.as_trace_mode := h.Copy(n.as_trace_mode); END;
    IF n.as_brand # NIL THEN cn.as_brand := h.Copy(n.as_brand) END;
    cn.as_type := h.Copy(n.as_type);
    RETURN cn;
  END Ref_type;

PROCEDURE <A NAME="Packed_type"><procedure>Packed_type</procedure></A>(n: M3AST_AS_F.Packed_type; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Packed_type := SRC_NODE(n, NEW(M3AST_AS.Packed_type).init());
  BEGIN
    cn.as_exp := h.Copy(n.as_exp);
    cn.as_type := h.Copy(n.as_type);
    RETURN cn;
  END Packed_type;

PROCEDURE <A NAME="Opaque_type"><procedure>Opaque_type</procedure></A>(n: M3AST_AS_F.Opaque_type; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Opaque_type := SRC_NODE(n, NEW(M3AST_AS.Opaque_type).init());
  BEGIN
    cn.as_type := h.Copy(n.as_type);
    RETURN cn;
  END Opaque_type;

PROCEDURE <A NAME="Brand"><procedure>Brand</procedure></A>(
    n: M3AST_AS_F.Brand; h: AST_CopyRep.Handle
    ): AST.NODE RAISES ANY=
  VAR cn: M3AST_AS.Brand := SRC_NODE(n, NEW(M3AST_AS.Brand).init());
  BEGIN
    IF n.as_exp # NIL THEN cn.as_exp := h.Copy(n.as_exp) END;
    RETURN cn;
  END Brand;

PROCEDURE <A NAME="Untraced"><procedure>Untraced</procedure></A>(
    n: M3AST_AS_F.Untraced; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.Untraced).init());
  END Untraced;

PROCEDURE <A NAME="Fields"><procedure>Fields</procedure></A>(n: M3AST_AS_F.Fields; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Fields := SRC_NODE(n, NEW(M3AST_AS.Fields).init());
  VAR
    m: M3AST_AS.Field_id;
    iter := SeqM3AST_AS_Field_id.NewIter(n.as_id_s);
  BEGIN
    VAR ns := SeqM3AST_AS_Field_id.Null;
    BEGIN
    WHILE SeqM3AST_AS_Field_id.Next(iter, m) DO
      SeqM3AST_AS_Field_id.AddRear(ns, h.Copy(m));
    END;
    cn.as_id_s := ns;
    END;
    IF n.as_type # NIL THEN cn.as_type := h.Copy(n.as_type); END;
    IF n.as_default # NIL THEN cn.as_default := h.Copy(n.as_default); END;
    RETURN cn;
  END Fields;

PROCEDURE <A NAME="Method"><procedure>Method</procedure></A>(n: M3AST_AS_F.Method; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Method := SRC_NODE(n, NEW(M3AST_AS.Method).init());
  BEGIN
    cn.as_id := h.Copy(n.as_id);
    IF n.as_type # NIL THEN cn.as_type := h.Copy(n.as_type); END;
    IF n.as_default # NIL THEN cn.as_default := h.Copy(n.as_default); END;
    RETURN cn;
  END Method;

PROCEDURE <A NAME="Override"><procedure>Override</procedure></A>(n: M3AST_AS_F.Override; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Override := SRC_NODE(n, NEW(M3AST_AS.Override).init());
  BEGIN
    cn.as_id := h.Copy(n.as_id);
    IF n.as_default # NIL THEN cn.as_default := h.Copy(n.as_default); END;
    RETURN cn;
  END Override;

PROCEDURE <A NAME="Inline"><procedure>Inline</procedure></A>(
    n: M3AST_PG_F.Inline; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_PG.Inline).init());
  END Inline;

PROCEDURE <A NAME="Formal_param"><procedure>Formal_param</procedure></A>(n: M3AST_AS_F.Formal_param; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Formal_param := SRC_NODE(n, NEW(M3AST_AS.Formal_param).init());
  VAR
    m: M3AST_AS.FORMAL_ID;
    iter := SeqM3AST_AS_FORMAL_ID.NewIter(n.as_id_s);
  BEGIN
    VAR ns := SeqM3AST_AS_FORMAL_ID.Null;
    BEGIN
    WHILE SeqM3AST_AS_FORMAL_ID.Next(iter, m) DO
      SeqM3AST_AS_FORMAL_ID.AddRear(ns, h.Copy(m));
    END;
    cn.as_id_s := ns;
    END;
    IF n.as_formal_type # NIL THEN cn.as_formal_type := h.Copy(n.as_formal_type); END;
    IF n.as_default # NIL THEN cn.as_default := h.Copy(n.as_default); END;
    RETURN cn;
  END Formal_param;

PROCEDURE <A NAME="Raisees_some"><procedure>Raisees_some</procedure></A>(n: M3AST_AS_F.Raisees_some; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Raisees_some := SRC_NODE(n, NEW(M3AST_AS.Raisees_some).init());
  VAR
    m: M3AST_AS.Qual_used_id;
    iter := SeqM3AST_AS_Qual_used_id.NewIter(n.as_raisees_s);
  BEGIN
    VAR ns := SeqM3AST_AS_Qual_used_id.Null;
    BEGIN
    WHILE SeqM3AST_AS_Qual_used_id.Next(iter, m) DO
      SeqM3AST_AS_Qual_used_id.AddRear(ns, h.Copy(m));
    END;
    cn.as_raisees_s := ns;
    END;
    RETURN cn;
  END Raisees_some;

PROCEDURE <A NAME="Raisees_any"><procedure>Raisees_any</procedure></A>(n: M3AST_AS_F.Raisees_any;
    &lt;*UNUSED*&gt; h: AST_CopyRep.Handle): AST.NODE =
  VAR cn: M3AST_AS.Raisees_any := SRC_NODE(n, NEW(M3AST_AS.Raisees_any).init());
  BEGIN
    RETURN cn;
  END Raisees_any;

PROCEDURE <A NAME="Range"><procedure>Range</procedure></A>(n: M3AST_AS_F.Range; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Range := SRC_NODE(n, NEW(M3AST_AS.Range).init());
  BEGIN
    cn.as_exp1 := h.Copy(n.as_exp1);
    cn.as_exp2 := h.Copy(n.as_exp2);
    RETURN cn;
  END Range;

PROCEDURE <A NAME="Range_EXP"><procedure>Range_EXP</procedure></A>(n: M3AST_AS_F.Range_EXP; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Range_EXP := SRC_NODE(n, NEW(M3AST_AS.Range_EXP).init());
  BEGIN
    cn.as_exp := h.Copy(n.as_exp);
    RETURN cn;
  END Range_EXP;

PROCEDURE <A NAME="LITERAL"><procedure>LITERAL</procedure></A>(n, cn: M3AST_LX.LITERAL): M3AST_AS.LITERAL=
  BEGIN
    cn.lx_litrep := n.lx_litrep;
    RETURN cn;
  END LITERAL;

PROCEDURE <A NAME="Integer_literal"><procedure>Integer_literal</procedure></A>(
    n: M3AST_AS_F.Integer_literal; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN LITERAL(n, SRC_NODE(n, NEW(M3AST_AS.Integer_literal).init()));
  END Integer_literal;

PROCEDURE <A NAME="Longint_literal"><procedure>Longint_literal</procedure></A>(
    n: M3AST_AS_F.Longint_literal; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN LITERAL(n, SRC_NODE(n, NEW(M3AST_AS.Longint_literal).init()));
  END Longint_literal;

PROCEDURE <A NAME="Real_literal"><procedure>Real_literal</procedure></A>(
    n: M3AST_AS_F.Real_literal; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN LITERAL(n, SRC_NODE(n, NEW(M3AST_AS.Real_literal).init()));
  END Real_literal;

PROCEDURE <A NAME="LongReal_literal"><procedure>LongReal_literal</procedure></A>(
    n: M3AST_AS_F.LongReal_literal; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN LITERAL(n, SRC_NODE(n, NEW(M3AST_AS.LongReal_literal).init()));
  END LongReal_literal;

PROCEDURE <A NAME="Extended_literal"><procedure>Extended_literal</procedure></A>(
    n: M3AST_AS_F.Extended_literal; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN LITERAL(n, SRC_NODE(n, NEW(M3AST_AS.Extended_literal).init()));
  END Extended_literal;

PROCEDURE <A NAME="Nil_literal"><procedure>Nil_literal</procedure></A>(
    n: M3AST_AS_F.Nil_literal; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN LITERAL(n, SRC_NODE(n, NEW(M3AST_AS.Nil_literal).init()));
  END Nil_literal;

PROCEDURE <A NAME="Text_literal"><procedure>Text_literal</procedure></A>(
    n: M3AST_AS_F.Text_literal; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN LITERAL(n, SRC_NODE(n, NEW(M3AST_AS.Text_literal).init()));
  END Text_literal;

PROCEDURE <A NAME="WideText_literal"><procedure>WideText_literal</procedure></A>(
    n: M3AST_AS_F.WideText_literal; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN LITERAL(n, SRC_NODE(n, NEW(M3AST_AS.WideText_literal).init()));
  END WideText_literal;

PROCEDURE <A NAME="Char_literal"><procedure>Char_literal</procedure></A>(
    n: M3AST_AS_F.Char_literal; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN LITERAL(n, SRC_NODE(n, NEW(M3AST_AS.Char_literal).init()));
  END Char_literal;

PROCEDURE <A NAME="WideChar_literal"><procedure>WideChar_literal</procedure></A>(
    n: M3AST_AS_F.WideChar_literal; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN LITERAL(n, SRC_NODE(n, NEW(M3AST_AS.WideChar_literal).init()));
  END WideChar_literal;

PROCEDURE <A NAME="Exp_used_id"><procedure>Exp_used_id</procedure></A>(
    n: M3AST_AS_F.Exp_used_id; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  VAR
    cn: M3AST_AS.Exp_used_id;
  BEGIN
    cn := SRC_NODE(n, NEW(M3AST_AS.Exp_used_id).init());
    EVAL ID(n.vUSED_ID, cn.vUSED_ID);
    RETURN cn;
  END Exp_used_id;

PROCEDURE <A NAME="Constructor"><procedure>Constructor</procedure></A>(n: M3AST_AS_F.Constructor; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Constructor := SRC_NODE(n, NEW(M3AST_AS.Constructor).init());
  VAR
    m: M3AST_AS.CONS_ELEM;
    iter := SeqM3AST_AS_CONS_ELEM.NewIter(n.as_element_s);
  BEGIN
    cn.as_type := h.Copy(n.as_type);
    VAR ns := SeqM3AST_AS_CONS_ELEM.Null;
    BEGIN
    WHILE SeqM3AST_AS_CONS_ELEM.Next(iter, m) DO
      SeqM3AST_AS_CONS_ELEM.AddRear(ns, h.Copy(m));
    END;
    cn.as_element_s := ns;
    END;
    IF n.as_propagate # NIL THEN cn.as_propagate := h.Copy(n.as_propagate); END;
    RETURN cn;
  END Constructor;

PROCEDURE <A NAME="RANGE_EXP_elem"><procedure>RANGE_EXP_elem</procedure></A>(n: M3AST_AS_F.RANGE_EXP_elem; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.RANGE_EXP_elem := SRC_NODE(n, NEW(M3AST_AS.RANGE_EXP_elem).init());
  BEGIN
    cn.as_range_exp := h.Copy(n.as_range_exp);
    RETURN cn;
  END RANGE_EXP_elem;

PROCEDURE <A NAME="Actual_elem"><procedure>Actual_elem</procedure></A>(n: M3AST_AS_F.Actual_elem; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Actual_elem := SRC_NODE(n, NEW(M3AST_AS.Actual_elem).init());
  BEGIN
    cn.as_actual := h.Copy(n.as_actual);
    RETURN cn;
  END Actual_elem;

PROCEDURE <A NAME="Propagate"><procedure>Propagate</procedure></A>(
    n: M3AST_AS_F.Propagate; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.Propagate).init());
  END Propagate;

PROCEDURE <A NAME="BINARY"><procedure>BINARY</procedure></A>(n, cn: M3AST_AS_F.BINARY; h: AST_CopyRep.Handle
                ): M3AST_AS.BINARY=
  &lt;*FATAL ANY*&gt;
  BEGIN
    cn.as_exp1 := h.Copy(n.as_exp1);
    cn.as_exp2 := h.Copy(n.as_exp2);
    RETURN cn;
  END BINARY;

PROCEDURE <A NAME="Plus"><procedure>Plus</procedure></A>(
    n: M3AST_AS_F.Plus; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Plus).init()), h);
  END Plus;

PROCEDURE <A NAME="Minus"><procedure>Minus</procedure></A>(
    n: M3AST_AS_F.Minus; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Minus).init()), h);
  END Minus;

PROCEDURE <A NAME="Times"><procedure>Times</procedure></A>(
    n: M3AST_AS_F.Times; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Times).init()), h);
  END Times;

PROCEDURE <A NAME="Rdiv"><procedure>Rdiv</procedure></A>(
    n: M3AST_AS_F.Rdiv; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Rdiv).init()), h);
  END Rdiv;

PROCEDURE <A NAME="Textcat"><procedure>Textcat</procedure></A>(
    n: M3AST_AS_F.Textcat; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Textcat).init()), h);
  END Textcat;

PROCEDURE <A NAME="Div"><procedure>Div</procedure></A>(
    n: M3AST_AS_F.Div; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Div).init()), h);
  END Div;

PROCEDURE <A NAME="Mod"><procedure>Mod</procedure></A>(
    n: M3AST_AS_F.Mod; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Mod).init()), h);
  END Mod;

PROCEDURE <A NAME="Eq"><procedure>Eq</procedure></A>(
    n: M3AST_AS_F.Eq; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Eq).init()), h);
  END Eq;

PROCEDURE <A NAME="Ne"><procedure>Ne</procedure></A>(
    n: M3AST_AS_F.Ne; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Ne).init()), h);
  END Ne;

PROCEDURE <A NAME="Gt"><procedure>Gt</procedure></A>(
    n: M3AST_AS_F.Gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Gt).init()), h);
  END Gt;

PROCEDURE <A NAME="Lt"><procedure>Lt</procedure></A>(
    n: M3AST_AS_F.Lt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Lt).init()), h);
  END Lt;

PROCEDURE <A NAME="Ge"><procedure>Ge</procedure></A>(
    n: M3AST_AS_F.Ge; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Ge).init()), h);
  END Ge;

PROCEDURE <A NAME="Le"><procedure>Le</procedure></A>(
    n: M3AST_AS_F.Le; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Le).init()), h);
  END Le;

PROCEDURE <A NAME="And"><procedure>And</procedure></A>(
    n: M3AST_AS_F.And; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.And).init()), h);
  END And;

PROCEDURE <A NAME="Or"><procedure>Or</procedure></A>(
    n: M3AST_AS_F.Or; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.Or).init()), h);
  END Or;

PROCEDURE <A NAME="In"><procedure>In</procedure></A>(
    n: M3AST_AS_F.In; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN BINARY(n, SRC_NODE(n, NEW(M3AST_AS.In).init()), h);
  END In;

PROCEDURE <A NAME="Select"><procedure>Select</procedure></A>(
    n: M3AST_AS_F.Select; h: AST_CopyRep.Handle;
    ): AST.NODE=
  &lt;*FATAL ANY*&gt;
  VAR cn: M3AST_AS.Select := SRC_NODE(n, NEW(M3AST_AS.Select).init());
  BEGIN
    cn.as_exp := h.Copy(n.as_exp);
    cn.as_id := h.Copy(n.as_id);
    RETURN cn;
  END Select;

PROCEDURE <A NAME="UNARY"><procedure>UNARY</procedure></A>(n, cn: M3AST_AS_F.UNARY; h: AST_CopyRep.Handle
               ): M3AST_AS_F.UNARY=
  &lt;*FATAL ANY*&gt;
  BEGIN
    cn.as_exp := h.Copy(n.as_exp);
    RETURN cn;
  END UNARY;

PROCEDURE <A NAME="Not"><procedure>Not</procedure></A>(
    n: M3AST_AS_F.Not; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN UNARY(n, SRC_NODE(n, NEW(M3AST_AS.Not).init()), h);
  END Not;

PROCEDURE <A NAME="Unaryplus"><procedure>Unaryplus</procedure></A>(
    n: M3AST_AS_F.Unaryplus; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN UNARY(n, SRC_NODE(n, NEW(M3AST_AS.Unaryplus).init()), h);
  END Unaryplus;

PROCEDURE <A NAME="Unaryminus"><procedure>Unaryminus</procedure></A>(
    n: M3AST_AS_F.Unaryminus; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN UNARY(n, SRC_NODE(n, NEW(M3AST_AS.Unaryminus).init()), h);
  END Unaryminus;

PROCEDURE <A NAME="Deref"><procedure>Deref</procedure></A>(
    n: M3AST_AS_F.Deref; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN UNARY(n, SRC_NODE(n, NEW(M3AST_AS.Deref).init()), h);
  END Deref;

PROCEDURE <A NAME="Call"><procedure>Call</procedure></A>(n: M3AST_AS_F.Call; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Call := SRC_NODE(n, NEW(M3AST_AS.Call).init());
  BEGIN
    RETURN EitherCall(n, cn, h);
  END Call;

PROCEDURE <A NAME="EitherCall"><procedure>EitherCall</procedure></A>(n: M3AST_AS_F.Call;
    cn: M3AST_AS.Call; h: AST_CopyRep.Handle): AST.NODE
    RAISES ANY =
  VAR
    m: M3AST_AS.Actual;
    iter := SeqM3AST_AS_Actual.NewIter(n.as_param_s);
  BEGIN
    cn.as_callexp := h.Copy(n.as_callexp);
    VAR ns := SeqM3AST_AS_Actual.Null;
    BEGIN
    WHILE SeqM3AST_AS_Actual.Next(iter, m) DO
      SeqM3AST_AS_Actual.AddRear(ns, h.Copy(m));
    END;
    cn.as_param_s := ns;
    END;
    RETURN cn;
  END EitherCall;

PROCEDURE <A NAME="NEWCall"><procedure>NEWCall</procedure></A>(n: M3AST_AS_F.NEWCall; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.NEWCall := SRC_NODE(n, NEW(M3AST_AS.NEWCall).init());
  BEGIN
    RETURN EitherCall(n, cn, h);
  END NEWCall;

PROCEDURE <A NAME="Index"><procedure>Index</procedure></A>(n: M3AST_AS_F.Index; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Index := SRC_NODE(n, NEW(M3AST_AS.Index).init());
  VAR
    m: M3AST_AS.EXP;
    iter := SeqM3AST_AS_EXP.NewIter(n.as_exp_s);
  BEGIN
    cn.as_array := h.Copy(n.as_array);
    VAR ns := SeqM3AST_AS_EXP.Null;
    BEGIN
    WHILE SeqM3AST_AS_EXP.Next(iter, m) DO
      SeqM3AST_AS_EXP.AddRear(ns, h.Copy(m));
    END;
    cn.as_exp_s := ns;
    END;
    RETURN cn;
  END Index;

PROCEDURE <A NAME="Actual"><procedure>Actual</procedure></A>(n: M3AST_AS_F.Actual; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Actual := SRC_NODE(n, NEW(M3AST_AS.Actual).init());
  BEGIN
    IF n.as_id # NIL THEN cn.as_id := h.Copy(n.as_id); END;
    cn.as_exp_type := h.Copy(n.as_exp_type);
    RETURN cn;
  END Actual;

PROCEDURE <A NAME="Assign_st"><procedure>Assign_st</procedure></A>(n: M3AST_AS_F.Assign_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Assign_st := SRC_NODE(n, NEW(M3AST_AS.Assign_st).init());
  BEGIN
    cn.as_lhs_exp := h.Copy(n.as_lhs_exp);
    cn.as_rhs_exp := h.Copy(n.as_rhs_exp);
    RETURN cn;
  END Assign_st;

PROCEDURE <A NAME="Call_st"><procedure>Call_st</procedure></A>(n: M3AST_AS_F.Call_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Call_st := SRC_NODE(n, NEW(M3AST_AS.Call_st).init());
  BEGIN
    cn.as_call := h.Copy(n.as_call);
    RETURN cn;
  END Call_st;

PROCEDURE <A NAME="Case_st"><procedure>Case_st</procedure></A>(n: M3AST_AS_F.Case_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Case_st := SRC_NODE(n, NEW(M3AST_AS.Case_st).init());
  VAR
    m: M3AST_AS.Case;
    iter := SeqM3AST_AS_Case.NewIter(n.as_case_s);
  BEGIN
    cn.as_exp := h.Copy(n.as_exp);
    VAR ns := SeqM3AST_AS_Case.Null;
    BEGIN
    WHILE SeqM3AST_AS_Case.Next(iter, m) DO
      SeqM3AST_AS_Case.AddRear(ns, h.Copy(m));
    END;
    cn.as_case_s := ns;
    END;
    IF n.as_else # NIL THEN cn.as_else := h.Copy(n.as_else); END;
        RETURN cn;
  END Case_st;

PROCEDURE <A NAME="Eval_st"><procedure>Eval_st</procedure></A>(n: M3AST_AS_F.Eval_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Eval_st := SRC_NODE(n, NEW(M3AST_AS.Eval_st).init());
  BEGIN
    cn.as_exp := h.Copy(n.as_exp);
    RETURN cn;
  END Eval_st;

PROCEDURE <A NAME="Exit_st"><procedure>Exit_st</procedure></A>(
    n: M3AST_AS_F.Exit_st; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.Exit_st).init());
  END Exit_st;

PROCEDURE <A NAME="For_st"><procedure>For_st</procedure></A>(n: M3AST_AS_F.For_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.For_st := SRC_NODE(n, NEW(M3AST_AS.For_st).init());
  BEGIN
    cn.as_id := h.Copy(n.as_id);
    cn.as_from := h.Copy(n.as_from);
    cn.as_to := h.Copy(n.as_to);
    IF n.as_by # NIL THEN cn.as_by := h.Copy(n.as_by); END;
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
        RETURN cn;
  END For_st;

PROCEDURE <A NAME="If_st"><procedure>If_st</procedure></A>(n: M3AST_AS_F.If_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.If_st := SRC_NODE(n, NEW(M3AST_AS.If_st).init());
  VAR
    m: M3AST_AS.Elsif;
    iter := SeqM3AST_AS_Elsif.NewIter(n.as_elsif_s);
  BEGIN
    cn.as_exp := h.Copy(n.as_exp);
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
    VAR ns := SeqM3AST_AS_Elsif.Null;
    BEGIN
    WHILE SeqM3AST_AS_Elsif.Next(iter, m) DO
      SeqM3AST_AS_Elsif.AddRear(ns, h.Copy(m));
    END;
    cn.as_elsif_s := ns;
    END;
    IF n.as_else # NIL THEN cn.as_else := h.Copy(n.as_else); END;
        RETURN cn;
  END If_st;

PROCEDURE <A NAME="Lock_st"><procedure>Lock_st</procedure></A>(n: M3AST_AS_F.Lock_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Lock_st := SRC_NODE(n, NEW(M3AST_AS.Lock_st).init());
  BEGIN
    cn.as_exp := h.Copy(n.as_exp);
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
        RETURN cn;
  END Lock_st;

PROCEDURE <A NAME="Loop_st"><procedure>Loop_st</procedure></A>(n: M3AST_AS_F.Loop_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Loop_st := SRC_NODE(n, NEW(M3AST_AS.Loop_st).init());
  BEGIN
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
        RETURN cn;
  END Loop_st;

PROCEDURE <A NAME="Raise_st"><procedure>Raise_st</procedure></A>(n: M3AST_AS_F.Raise_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Raise_st := SRC_NODE(n, NEW(M3AST_AS.Raise_st).init());
  BEGIN
    cn.as_qual_id := h.Copy(n.as_qual_id);
    IF n.as_exp_void # NIL THEN cn.as_exp_void := h.Copy(n.as_exp_void); END;
    RETURN cn;
  END Raise_st;

PROCEDURE <A NAME="Repeat_st"><procedure>Repeat_st</procedure></A>(n: M3AST_AS_F.Repeat_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Repeat_st := SRC_NODE(n, NEW(M3AST_AS.Repeat_st).init());
  BEGIN
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
    cn.as_exp := h.Copy(n.as_exp);
        RETURN cn;
  END Repeat_st;

PROCEDURE <A NAME="Return_st"><procedure>Return_st</procedure></A>(n: M3AST_AS_F.Return_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Return_st := SRC_NODE(n, NEW(M3AST_AS.Return_st).init());
  BEGIN
    IF n.as_exp # NIL THEN cn.as_exp := h.Copy(n.as_exp); END;
    RETURN cn;
  END Return_st;

PROCEDURE <A NAME="Try_st"><procedure>Try_st</procedure></A>(n: M3AST_AS_F.Try_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Try_st := SRC_NODE(n, NEW(M3AST_AS.Try_st).init());
  BEGIN
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
    cn.as_try_tail := h.Copy(n.as_try_tail);
        RETURN cn;
  END Try_st;

PROCEDURE <A NAME="Typecase_st"><procedure>Typecase_st</procedure></A>(n: M3AST_AS_F.Typecase_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Typecase_st := SRC_NODE(n, NEW(M3AST_AS.Typecase_st).init());
  VAR
    m: M3AST_AS.Tcase;
    iter := SeqM3AST_AS_Tcase.NewIter(n.as_tcase_s);
  BEGIN
    cn.as_exp := h.Copy(n.as_exp);
    VAR ns := SeqM3AST_AS_Tcase.Null;
    BEGIN
    WHILE SeqM3AST_AS_Tcase.Next(iter, m) DO
      SeqM3AST_AS_Tcase.AddRear(ns, h.Copy(m));
    END;
    cn.as_tcase_s := ns;
    END;
    IF n.as_else # NIL THEN cn.as_else := h.Copy(n.as_else); END;
        RETURN cn;
  END Typecase_st;

PROCEDURE <A NAME="While_st"><procedure>While_st</procedure></A>(n: M3AST_AS_F.While_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.While_st := SRC_NODE(n, NEW(M3AST_AS.While_st).init());
  BEGIN
    cn.as_exp := h.Copy(n.as_exp);
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
        RETURN cn;
  END While_st;

PROCEDURE <A NAME="With_st"><procedure>With_st</procedure></A>(n: M3AST_AS_F.With_st; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.With_st := SRC_NODE(n, NEW(M3AST_AS.With_st).init());
  VAR
    m: M3AST_AS.Binding;
    iter := SeqM3AST_AS_Binding.NewIter(n.as_binding_s);
  BEGIN
    VAR ns := SeqM3AST_AS_Binding.Null;
    BEGIN
    WHILE SeqM3AST_AS_Binding.Next(iter, m) DO
      SeqM3AST_AS_Binding.AddRear(ns, h.Copy(m));
    END;
    cn.as_binding_s := ns;
    END;
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
        RETURN cn;
  END With_st;

PROCEDURE <A NAME="Case"><procedure>Case</procedure></A>(
    n: M3AST_AS_F.Case; h: AST_CopyRep.Handle
    ): AST.NODE RAISES ANY=
  VAR cn: M3AST_AS.Case := SRC_NODE(n, NEW(M3AST_AS.Case).init());
  VAR
    m: M3AST_AS.RANGE_EXP;
    iter := SeqM3AST_AS_RANGE_EXP.NewIter(n.as_case_label_s);
  BEGIN
    VAR ns := SeqM3AST_AS_RANGE_EXP.Null;
    BEGIN
    WHILE SeqM3AST_AS_RANGE_EXP.Next(iter, m) DO
      SeqM3AST_AS_RANGE_EXP.AddRear(ns, h.Copy(m));
    END;
    cn.as_case_label_s := ns;
    END;
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
    RETURN cn;
  END Case;

PROCEDURE <A NAME="Block"><procedure>Block</procedure></A>(n: M3AST_AS_F.Block; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Block := SRC_NODE(n, NEW(M3AST_AS.Block).init());
  VAR
    m: M3AST_AS.DECL_REVL;
    iter := SeqM3AST_AS_DECL_REVL.NewIter(n.as_decl_s);
  BEGIN
    VAR ns := SeqM3AST_AS_DECL_REVL.Null;
    BEGIN
    WHILE SeqM3AST_AS_DECL_REVL.Next(iter, m) DO
      SeqM3AST_AS_DECL_REVL.AddRear(ns, h.Copy(m));
    END;
    cn.as_decl_s := ns;
    END;
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
    RETURN cn;
  END Block;

PROCEDURE <A NAME="Else_stm"><procedure>Else_stm</procedure></A>(n: M3AST_AS_F.Else_stm; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Else_stm := SRC_NODE(n, NEW(M3AST_AS.Else_stm).init());
  BEGIN
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
    RETURN cn;
  END Else_stm;

PROCEDURE <A NAME="By"><procedure>By</procedure></A>(n: M3AST_AS_F.By; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.By := SRC_NODE(n, NEW(M3AST_AS.By).init());
  BEGIN
    cn.as_exp := h.Copy(n.as_exp);
    RETURN cn;
  END By;

PROCEDURE <A NAME="Elsif"><procedure>Elsif</procedure></A>(n: M3AST_AS_F.Elsif; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Elsif := SRC_NODE(n, NEW(M3AST_AS.Elsif).init());
  BEGIN
    cn.as_exp := h.Copy(n.as_exp);
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
    RETURN cn;
  END Elsif;

PROCEDURE <A NAME="Try_except"><procedure>Try_except</procedure></A>(n: M3AST_AS_F.Try_except; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Try_except := SRC_NODE(n, NEW(M3AST_AS.Try_except).init());
  VAR
    m: M3AST_AS.Handler;
    iter := SeqM3AST_AS_Handler.NewIter(n.as_handler_s);
  BEGIN
    VAR ns := SeqM3AST_AS_Handler.Null;
    BEGIN
    WHILE SeqM3AST_AS_Handler.Next(iter, m) DO
      SeqM3AST_AS_Handler.AddRear(ns, h.Copy(m));
    END;
    cn.as_handler_s := ns;
    END;
    IF n.as_else # NIL THEN cn.as_else := h.Copy(n.as_else); END;
    RETURN cn;
  END Try_except;

PROCEDURE <A NAME="Try_finally"><procedure>Try_finally</procedure></A>(n: M3AST_AS_F.Try_finally; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Try_finally := SRC_NODE(n, NEW(M3AST_AS.Try_finally).init());
  BEGIN
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
    RETURN cn;
  END Try_finally;

PROCEDURE <A NAME="Tcase"><procedure>Tcase</procedure></A>(n: M3AST_AS_F.Tcase; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Tcase := SRC_NODE(n, NEW(M3AST_AS.Tcase).init());
  VAR
    m: M3AST_AS.M3TYPE;
    iter := SeqM3AST_AS_M3TYPE.NewIter(n.as_type_s);
  BEGIN
    VAR ns := SeqM3AST_AS_M3TYPE.Null;
    BEGIN
    WHILE SeqM3AST_AS_M3TYPE.Next(iter, m) DO
      SeqM3AST_AS_M3TYPE.AddRear(ns, h.Copy(m));
    END;
    cn.as_type_s := ns;
    END;
    IF n.as_id # NIL THEN cn.as_id := h.Copy(n.as_id) END;
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
    RETURN cn;
  END Tcase;

PROCEDURE <A NAME="Handler"><procedure>Handler</procedure></A>(n: M3AST_AS_F.Handler; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Handler := SRC_NODE(n, NEW(M3AST_AS.Handler).init());
  VAR
    m: M3AST_AS.Qual_used_id;
    iter := SeqM3AST_AS_Qual_used_id.NewIter(n.as_qual_id_s);
  BEGIN
    VAR ns := SeqM3AST_AS_Qual_used_id.Null;
    BEGIN
    WHILE SeqM3AST_AS_Qual_used_id.Next(iter, m) DO
      SeqM3AST_AS_Qual_used_id.AddRear(ns, h.Copy(m));
    END;
    cn.as_qual_id_s := ns;
    END;
    IF n.as_id # NIL THEN cn.as_id := h.Copy(n.as_id); END;
    cn.as_stm_s := CopySeqStm(n.as_stm_s, h);
    RETURN cn;
  END Handler;

PROCEDURE <A NAME="Binding"><procedure>Binding</procedure></A>(n: M3AST_AS_F.Binding; h: AST_CopyRep.Handle): AST.NODE
     RAISES ANY =
  VAR cn: M3AST_AS.Binding := SRC_NODE(n, NEW(M3AST_AS.Binding).init());
  BEGIN
    cn.as_id := h.Copy(n.as_id);
    cn.as_exp := h.Copy(n.as_exp);
    RETURN cn;
  END Binding;

PROCEDURE <A NAME="External"><procedure>External</procedure></A>(
    n: M3AST_PG_F.External; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  VAR cn: M3AST_PG.External;
  BEGIN
    cn := SRC_NODE(n, NEW(M3AST_PG.External).init());
    cn.lx_lang_spec := n.lx_lang_spec;
    RETURN cn;
  END External;

PROCEDURE <A NAME="Bad_EXP"><procedure>Bad_EXP</procedure></A>(
    n: M3AST_AS_F.Bad_EXP; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.Bad_EXP).init());
  END Bad_EXP;

PROCEDURE <A NAME="Bad_M3TYPE"><procedure>Bad_M3TYPE</procedure></A>(
    n: M3AST_AS_F.Bad_M3TYPE; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.Bad_M3TYPE).init());
  END Bad_M3TYPE;

PROCEDURE <A NAME="Bad_STM"><procedure>Bad_STM</procedure></A>(
    n: M3AST_AS_F.Bad_STM; &lt;*UNUSED*&gt; h: AST_CopyRep.Handle;
    ): AST.NODE=
  BEGIN
    RETURN SRC_NODE(n, NEW(M3AST_AS.Bad_STM).init());
  END Bad_STM;

BEGIN
END M3AST_AS_Copy.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
