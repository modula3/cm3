<HTML>
<HEAD>
    <TITLE>Reactor--Blue Paper</TITLE>
<LINK HREF="/cm3/normal.css" REL="stylesheet" TYPE="text/css"></head>
<BODY bgcolor="#F1F7FF">

<table border=0 cellpadding=1>
<tr valign=bottom>
<td width=400>
<!--<h1>R&nbsp&nbspE&nbsp&nbspA&nbsp&nbspC&nbsp&nbspT&nbsp&nbspO&nbsp&nbspR</H1>-->
<FONT size=+3>R&nbsp;&nbsp;E&nbsp;&nbsp;A&nbsp;&nbsp;C&nbsp;&nbsp;T&nbsp;&nbsp;O&nbsp;&nbsp;R</FONT>
<br><br>
<FONT size=+2>A</font>&nbsp;&nbsp;<font size=+2>D</font><font size=+1>ISTRIBUTED</font>&nbsp;&nbsp;<font size=+2>A</font><font size=+1>PPLICATION</font>
<font size=+2>D</font><font size=+1>EVELOPMENT</font>&nbsp;&nbsp;<font size=+2>S</font><font size=+1>YSTEM</font>
<br><br><br><br>
<td><img src="blueLogo.gif">
</table>


<BR>
Reactor represents a new generation of technology for building client/server,
multi-tiered, and distributed applications. It combines an innovative web-based
application development system with a rich and robust distributed infrastructure.
This paper outlines the features and benefits of Reactor's high-productivity,
distributed application development system.

<H3>The Development Environment</H3>

Most development environments force you to use the proprietary user interface
included with the environment. At Critical Mass, Inc., we've decided to
take a different approach. The user interface of our development environment
is <EM>a standard web browser</EM> such as Netscape Navigator, or the Internet
Explorer. At the heart of our development environment is a custom-built
server driven by HTTP requests for browsing, building, and compiling. (Think
of it as your personal HTTP server which knows about all your program files
and their relationships.) Our reliance on a web browser as our development
front-end makes it easy for new programmers to come up to speed and results
in a reduction of training costs-after all, most users are familiar with
web browsers. Moreover, the hypertext and networked nature of the web creates
a rich visual metaphor for building and exploring distributed applications.
For example, using Reactor, it is easy to embed references to external documentation,
to point out relationships with other projects in your system, or to create
links in a <CODE>README</CODE> file so that a coworker can easily find the
external documentation for programs.
<p>
<IMG SRC="screen.gif" WIDTH="614" HEIGHT="461" NATURALSIZEFLAG="3" ALIGN=
bottom>
<BLOCKQUOTE>
<EM>The Reactor Development Environment: Integrating into an
off-the-shelf web browser, the Reactor development environment gives you
the same look and feel whether you are programming on Unix or Windows. You
can build and browse your programs, or even link in your own html pages
into your program sources.</EM>
<a href="http://www.cmass.com/reactor/screen_full.gif">Full size image, 98K.</a>
</BLOCKQUOTE>
<p>
Each file in your project and every command in Reactor maps to a <CODE>URL</CODE>
in the virtual web space of the Reactor server. Hence, as web browsing technology
becomes embedded further into the desktop metaphor, the Reactor user interface
will become a natural part of the development desktop rather than a stand-alone
entity running on the side. Essentially, a Reactor-based project will be
just another explorable space residing on the desktop reached through standard
desktop interaction mechanisms. Moreover, to aid programming efforts that
require multiple developers, Reactor provides public and private repositories,
and allows team members to browse each other's projects. You can embed a
reference to a Reactor project in an e-mail message to a coworker. With
Reactor, team communication is just a click away.

<H3>The Programming Language</H3>

The Modula-3 programming language is the foundation of Reactor's programming
environment. The Modula-3 language was developed in the late 1980s by researchers
at Digital Systems Research Center and Olivetti Research Center; both organizations
have extensive experience in building sophisticated application and systems
software. Modula-3 provides features that are essential to the development
of large-scale systems, such as separate interfaces, garbage collection,
objects, threads, and exceptions.
<p>
<table border=1 cellpadding=1>
<tr align=center>
<td width=120>
<td width=65>Smalltalk
<td width=60>Ada83
<td width=60>Ada95
<td width=60>Java
<td width=60>C++
<td width=60>C
<td width=65><strong>Modula-3</strong></td>

<tr align=center valign=middle>
<td align=left>Interfaces
<td width=65>&nbsp;
<td width=60><img src="dark.gif">
<td width=60><img src="dark.gif">
<td width=60><img src="dark.gif">
<td width=60>&nbsp;
<td width=60>&nbsp;
<td width=65><img src="dark.gif">

<tr align=center valign=middle>
<td align=left>Strict Separation of<br>Impl. and Interface
<td width=65>&nbsp;
<td width=60><img src="dark.gif">
<td width=60><img src="dark.gif">
<td width=60>&nbsp;
<td width=60>&nbsp;
<td width=60>&nbsp;
<td width=65><img src="dark.gif">

<tr align=center valign=middle>
<td align=left>Garbage Collection
<td width=65><img src="dark.gif">
<td width=60>&nbsp;
<td width=60><img src="light.gif">
<td width=60><img src="dark.gif">
<td width=60>&nbsp;
<td width=60>&nbsp;
<td width=65><img src="dark.gif">

<tr align=center valign=middle>
<td align=left>Mulitple Inheritance
<td width=65>&nbsp;
<td width=60>&nbsp;
<td width=60>&nbsp;
<td width=60>&nbsp;
<td width=60><img src="dark.gif">
<td width=60>&nbsp;
<td width=65>&nbsp;

<tr align=center valign=middle>
<td align=left>Objects
<td width=65><img src="dark.gif">
<td width=60>&nbsp;
<td width=60><img src="dark.gif">
<td width=60><img src="dark.gif">
<td width=60><img src="dark.gif">
<td width=60>&nbsp;
<td width=65><img src="dark.gif">

<tr align=center valign=middle>
<td align=left>Concurrency & Threads
<td width=65><img src="light.gif">
<td width=60><img src="dark.gif">
<td width=60><img src="dark.gif">
<td width=60><img src="light.gif">
<td width=60>&nbsp;
<td width=60>&nbsp;
<td width=65><img src="dark.gif">

<tr align=center valign=middle>
<td align=left>Generics
<td width=65>&nbsp;
<td width=60><img src="dark.gif">
<td width=60><img src="dark.gif">
<td width=60>&nbsp;
<td width=60><img src="dark.gif">
<td width=60>&nbsp;
<td width=65><img src="dark.gif">

<tr align=center valign=middle>
<td align=left>Exceptions
<td width=65>&nbsp;
<td width=60><img src="dark.gif">
<td width=60><img src="dark.gif">
<td width=60><img src="dark.gif">
<td width=60><img src="dark.gif">
<td width=60>&nbsp;
<td width=65><img src="dark.gif">

<tr align=center valign=middle>
<td align=left>Unsafe Features
<td width=65>&nbsp;
<td width=60><img src="dark.gif">
<td width=60><img src="dark.gif">
<td width=60>&nbsp;
<td width=60><img src="dark.gif">
<td width=60><img src="dark.gif">
<td width=65><img src="dark.gif">

<tr align=center valign=middle>
<td align=left>Separation of<br>Unsafe Code
<td width=65>&nbsp;
<td width=60>&nbsp;
<td width=60><img src="light.gif">
<td width=60>&nbsp;
<td width=60>&nbsp;
<td width=60>&nbsp;
<td width=65><img src="dark.gif">

<tr align=center valign=middle>
<td align=left>Dynamic Typing
<td width=65><img src="dark.gif">
<td width=60>&nbsp;
<td width=60><img src="dark.gif">
<td width=60><img src="dark.gif">
<td width=60><img src="light.gif">
<td width=60>&nbsp;
<td width=65><img src="dark.gif">

</table>
<p>
<blockquote>
<em>
The Reactor Development Language: Despite its 50-page definition,
Modula-3, the heart of the Reactor programming environment, gives you
more support than other languages you may have considered for your
systems programming tasks.
</em>
</blockquote>
<p>
The language designers sought a combination of features that would support
the development of robust, long-lived systems while keeping the language
small and comprehensible. The result is a language that is a better suited
for building robust distributed applications than other current languages.
Modula-3 is more powerful than c++, but its language definition fits comfortably
within about <EM>fifty</EM> pages of text. The next few sections describe some of
the major features of the language.

<H4><EM>True Separation of Interface and Implementation</EM></H4>

The key structuring idea in building programs with Modula-3 is the strong
separation of interface from implementation. An interface describes an abstraction.
That is, it describes <EM>what</EM> something is capable of doing but does not describe
<EM>how</EM> it is done. Interfaces provide the <EM>what</EM>, implementations provide the
<EM>how</EM>.
<p>
This separation means that you are free to change the way an abstraction
is implemented without having to worry about all the clients of that abstraction-no
recompiling is necessary. As long as the interface remains unchanged, the
clients are unaffected. Clients cannot accidently become dependent on the
way something is implemented and later break in mysterious ways when the
implementation is changed. 
<p>
Another benefit of separating interfaces from implementations is that it
decouples the activities of the implementor of a programming client from
those of the API's provider. For example, client implementors can begin
programming as soon as the interface is written. They don't need to wait
for full implementations from the API's provider. Also, project managers
can easily maintain control of an interface's evolution by restricting write
access to it, without crippling the programmer's need to write code.
<p>
The true separation of interfaces from implementations is a critical advantage
for building large systems.

<H4><EM>Garbage Collection</EM></H4>

Garbage collection automates the most difficult aspect of memory management
by keeping track of references in your system, and freeing unused pieces
of memory when there are no longer references to them. Memory is finite;
thus, memory management is necessary in any long-running program written
in any language. Most of the time, the programmer needs to do the hard work
of determining when to free a piece of memory that is no longer needed.
While this is an easy task for small programs, it is quite difficult to
keep track of complex dependencies for large or long-running client/server
systems. With garbage collection, it is the <EM>responsibility of the system</EM>
to determine when a piece of memory is no longer in use. Automatic garbage
collection makes it easier to create more robust programs. Programs built
using manual storage management are often plagued by storage leaks and dangling
references. Garbage collection eliminates these errors. Correct, efficient
memory management is essential to building long-lived and robust applications.
Automatic garbage collection makes it easy.
<p>
Historically, programmers have been suspicious of garbage-collected systems,
feeling that they introduced too much overhead. Reactor's garbage collector
has been tuned through years of intensive use, and performs quite well in
client/server applications. Also, Reactor's state-of-the-art, concurrent,
incremental collector supports the development of response-critical, multi-threaded
applications.
<p>
Accompanying Reactor are a number of tools for analyzing and tuning memory
usage and an open interface to tune the collector's behavior. In fact, many
of the same tools were used in the development of Reactor, which is itself
a client/server application.
<p>
No matter what garbage collector or memory management scheme you use, there
are times when you need complete control of memory management. In Modula-3,
you can use <EM>untraced</EM> references. Then, as the programmer, you are responsible
for allocating and freeing the storage. This feature is essential when dealing
with data structures allocated by foreign and legacy systems, where you
must disallow automatic garbage collections.

<H4><EM>Objects</EM></H4>

Objects combine state with operations on that state. Modula-3, Reactor's
programming language, provides a simple single-inheritance object system
much like Simula's, Smalltalk's or the original C++'s. Its object model
is simpler than C++'s, making it easier to build more robust systems. Like
Smalltalk or Java, objects reside in a garbage collected heap. 

<H4><EM>Threads</EM></H4>

Today's applications are quite different from those of just a few years
ago. When C was invented, most applications were either batch-oriented or
presented a simple line-oriented interface. Today's applications are often
driven by multiple, asynchronous, external events; they must respond quickly
at all times, and need access to other applications on the network. For
instance, a server needs to respond in a timely fashion; otherwise clients
will perceive it as having crashed. A client may need to invoke operations
on multiple servers. This demanding environment has led to systems with
multi-threaded architectures. Programming responsive, event-driven applications
is simpler with threads. Reactor meets this need with language-level support
for multi-threaded applications. Standard libraries and the run-time on
all platforms are multi-threaded.

<H4><EM>Exception Handling</EM></H4>

One of the biggest problems in developing robust software is getting callers
of a routine to check error codes returned by that routine. In any large
software system, there may be numerous places where someone forgot to check
the error status after calling some routine. Often the system will crash
in some mysterious way unrelated to the original, missed error report. These
failures are time bombs waiting to go off long after the system has been
deployed.
<p>
Exception handling is an error signalling and handling technique. It ensures
that callers can't accidentally forget to check if a routine completed successfully.
When a routine encounters an error situation, it raises an exception. This
causes the language run-time to see if any of the callers have indicated
that they want to handle this exception. If so, then control is transferred
back to the point where the program is prepared to handle the exception.
If the program is unable to handle the exception, the program is terminated
in a controlled fashion. When a routine is declared to raise a set of exceptions,
the compiler checks all calls to that routine to see if they are in scopes
that handle the raised exceptions. If there are some exceptions that the
caller doesn't handle, then the compiler issues a warning. If you get rid
of all such warnings in a program, your program will never raise an exception
that would not be handled. This is yet another way Reactor helps create
robust code.

<H4><EM>Access to Unsafe Features</EM></H4>

No matter how complete a safe interface is, sometimes you need access to
the lower-levels of the system. Modula-3 allows such access for system programming,
for example, to tweak bits and bytes of memory locations. This kind of access
comes in handy for integrating legacy systems, connecting to foreign or
networked systems, or performing fast graphics operations. Indeed, unsafe
features have been used to integrate many standard C apis, such as x11,
Win32, tcp, and Opengl.

<H3>The Compilation System</H3>

Programming environments for languages such as C++ keep track of dependencies
on a per-file basis. Typically, when a procedure declaration in a header
file is changed, all compilation units that <code>#include</code> this header file must
be recompiled, even if they are completely unaffected by the change. For
large systems, this strategy results in unnecessary compilation that slows
the development. To avoid such delays, development teams often adopt strict
controls as to when a header file can be modified. This, of course, hinders
the developers. In a typical development group, such a scheme would require
changed header files to be submitted to a master repository late in the
day, and the entire system would be rebuilt overnight. Thus, group development
becomes a batch process. To avoid the delays of the nightly batch process,
most large C/C++ programmer shops spread logically related parts of the
system across seemingly unrelated header files in order to speed recompilation.
The outcome is a system that is harder to understand, change, and maintain.
<p>
Reactor's compilation system provides a much more elegant and practical
solution. In Reactor, cross-module dependencies are kept on a <EM>per-declaration
basis</EM>. When a declaration (such as a type or a procedure signature) is changed
in an interface, <EM>only those modules that depend on that particular declaration
are recompiled</EM>. Typically, only a small number of modules are affected by
a changed definition, resulting in much faster rebuild times, even when
changing an item in an interface used by many other modules. Programming
teams have much greater freedom in submitting, integrating, and testing
changes.
<p>
Reactor's builder keeps track of dependencies between various modules automatically.
Hence, writing makefiles is a breeze: all you have to do is list the modules
and interfaces in your program-the builder takes care of the rest.
<p>
Reactor's compiler also offers rapid compilation using a fast back-end that
generates native object code directly, instead of generating C code. This,
in conjunction with the minimal recompilation system, means that large systems
can be quickly rebuilt after a change. No more hour-long waits because someone
changed the <EM><code>globals.h</code></EM> file, and no more hassles with maintaining 
<code>make</code> dependencies.

<H3>The Infrastructure</H3>

Reactor provides a large set of reusable, thread-friendly, and portable
libraries, some of which are highlighted in this section.

<H4><EM>IO Framework</EM></H4>

The IO framework provides an extensible set of types for doing stream-oriented
input and output to screens, files, and network connection-all in a safe,
multi-threaded environment. New custom io stream types can be added easily.

<H4><EM>Simple Persistence (&quot;Pickles&quot;)</EM></H4>

Reactor provides a set of interfaces for writing and reading object state
to and from disks or network streams. This facility, called &quot;Pickles&quot;,
is extremely simple to use. With no help from the programmer, Pickles preserve
the shape (that is, the structure) of arbitrary, complex object graphs during
save and load operations. Pickles are designed to be customizable so that
applications can store objects in a form that is optimized based on their
type. For example, a sparse array can be stored in a compact form on disk
by writing a small procedure.

<H4><EM>Lightweight Object Storage (&quot;SmallDB&quot;)</EM></H4>

Smalldb allows &quot;pickled&quot; objects to be stored in a recoverable
fashion. If a crash occurs while the objects are being written to disk,
the object state will be restored from the latest consistent snapshot the
next time they are used. This kind of recoverable storage is vital in the
development of robust servers.

<H4><EM>Stable Object Storage </EM></H4>

Stable object storage extends the lightweight object storage provided by
Pickles and SmallDB to allow for recoverable storage of objects through
logging and checkpointing. Updates to objects are logged to stable storage
automatically. When the state of an object is restored from disk, the restoration
process checks to see if a crash occurred before the entire state of the
object was written to disk. If so, the state of the object is recovered
from the log of modifications to the object.

<H4><EM>High-level OS Interfaces</EM></H4>

Reactor provides a set of high-level object-oriented interfaces to the underlying
os facilities such as files, processes, directories, terminals, and keyboards.
The interfaces to these operating system functions are identical whether
you are running on Windows or Unix. You can have the <EM>same piece of code</EM>
on Unix and Win32 that uses operating systems services without messy <cede>#ifdef</code>
statements.

<H4><EM>Generic Collection Interfaces</EM></H4>

A standard set of generic collections, such as lists, tables, sets, sequences,
sorted lists, and priority queues are provided with the library.

<H4><EM>Safe &amp; Portable Relational Database Interfaces</EM></H4>

Reactor includes an interface for accessing relational databases. The default
implementation is based on the ODBC API on Win32 and Unix to access most
name-brand databases easily. The back-end of the relational database interface
can easily be extended to connect to a database interface via its native
API.

<H4><EM>Safe &amp; Portable TCP Interface</EM></H4>

With Reactor's TCP interfaces, you can write programs using sockets. The
TCP interfaces are safe, so you, as the programmer, do not need to worry
about the interaction of multi-threading or memory management with the lower-level
TCP libraries. Reactor's TCP interfaces are also portable, so the same code
works whether you use Unix sockets or Win32's Winsock. Hence, interaction
with Internet or Intranet TCP services is straightforward. For example,
a simple multi-threaded web server written using the safe TCP interface
takes less than a page of code.

<H4><EM>Safe &amp; Portable Web Server Construction Toolkit</EM></H4>

Using Reactor's construction toolkit for HTTP, you can build customized
web and proxy servers. Capitalizing on built-in support for concurrency
and the portable TCP interface, you can build multi-threaded, dynamic web
servers using the same code on Win32 and Unix platforms.

<H3>The Tools</H3>

In addition to the libraries, Reactor includes several useful utility programs,
a few of which are described in this section.

<H4><EM>ShowThread</EM></H4>

ShowThread provides a graphical display of the current state of each thread
running in an application. Thread information can be recorded to a file
and replayed for later analysis.

<H4><EM>ShowHeap and ShowNew</EM></H4>

ShowHeap and ShowNew display heap allocation information to aid the programmer
in finding memory usage patterns. This information can be recorded to file
and replayed for analysis.

<H4><EM>Stubgen</EM></H4>

Stubgen reads a Modula-3 object description and generates the code necessary
to make the distributed instances of the object. Reactor's distributed object
system is described in more detail later in this paper.

<H4><EM>Stablegen</EM></H4>

Stablegen reads an interface containing an object type and generates the
code that is necessary to allow instances of that object type to be stored
in a recoverable fashion.

<H4><EM>Cbind</EM></H4>

Modula-3 is a compiled language that can readily access existing C code.
The usual approach is to create a Modula-3 interface that is implemented
by a C module or library. Cbind is a tool for automatically generating interfaces
to existing C libraries and programs. Cbind reads a C header file for an
existing system and generates the corresponding Modula-3 interface. The
ability to directly call existing libraries makes the integration of existing
and legacy C applications much easier than in many other non-c systems.

<H3>An Open Infrastructure For Building Distributed Applications</H3>

<H4><EM>Network IO Framework</EM></H4>

The network io framework provides a set of high-level abstractions for sending
and receiving messages across the network. The Message Stream interface
is the simplest part to describe. A message stream is simply a type of io
stream that passes multi-byte chunks of data as atomic units.
<p>
The network io framework currently supports the tcp/ip protocol. However,
adding support for protocols such as IPX/SPX or NetBEUI is relatively straightforward.
<p>
Here is a short example for sending a &quot;Hello World&quot; message to
the process listening on the IP port <code>dest_port</code>:

<blockquote>
<pre>
VAR
  conn := TCP.Connect(dest_port);
  msgWr := ConnMsgRW.NewWr(conn);
BEGIN
  Wr.PutText(msgWr, &quot;Hello World\n&quot;);
  Wr.Flush(msgWr);
END
</pre>
</blockquote>

<H4><EM>Network Objects</EM></H4>

The Network Objects system is a robust mechanism for developing distributed
applications. Central to the robustness of Network Objects is a sophisticated
distributed garbage collector. This garbage collector simplifies one of
the most difficult problems faced by developers of distributed applications:
global memory management in the presence of machine and communication failures.

<p>
Network Objects allows a Modula-3 object to be handed to another process
in such a way that the process receiving the object can operate on it as
if it were local. The holder of a remote object can freely invoke operations
on that object just as if it had created that object locally. Further, it
can pass the object to other processes. Thus, the Network Objects system
allows the development of not just simple client-server applications, but
more general <EM>multi-tiered distributed</EM> applications.
<p>
In CORBA terms, Network Objects provides the equivalent of ORB functionality;
however, Network Objects is much more tightly integrated with the Modula-3
language. Most CORBA implementations are layered on top of C++, a language
which was not designed to host distributed programming. In contrast, the
Modula-3 language designers made the easy and natural design of distributed
applications one of their primary goals. Modula-3 programs are much easier
to make distributed than their C++ counterparts.
<p>
The current implementation of Network Objects is built on the TCP framework
described above. In addition, it is designed to make adoption to specialized
network protocols easy. For instance, it is relatively straightforward to
add a new transport for Network Objects for CORBA IIOP or DCE RPC.

<H4><EM>Putting It All Together: A Network Objects Example</EM></H4>

In this section we outline the canonical example of a distributed program,
namely that of a remotely accessible <EM>bank</EM> (ignoring possible communication
failures.) We first provide the interface to the bank:

<blockquote>
<pre>
INTERFACE Bank;
IMPORT NetObj;

TYPE
  T = NetObj.T OBJECT METHODS
    deposit (acct: AcctNum; amount: REAL) RAISES {BadAmount};
    withdraw (acct: AcctNum; amount: REAL) RAISES {BadAmount, InsufficientFunds};
    get_balance (acct: AcctNum): REAL;
  END;
  
TYPE
  AcctNum = [1..100];
  
EXCEPTION
  BadAmount;
  InsufficientFunds;
  
END Bank.
</pre>
</blockquote>
<p>
The Bank interface defines an object type <code>Bank.T</code> which inherits from the
type <code>NetObj.T</code>; inheriting from <code>NetObj.T</code> makes an object eligible for distribution.
The <code>Bank.T</code> type defines three operations: <code>deposit</code>, 
<code>withdraw</code>, and <code>get_balance</code>.
The <code>deposit</code> and <code>withdraw</code> operations will raise
<code>BadAmount</code> if the amount is
less than zero. The <code>withdraw</code> operation also raises the <code>InsufficientFunds</code>
exception if there isn't sufficient funds in the account to meet the requested
withdrawal amount.
<p>
Continuing our example, we show how the bank server can be implemented.
To save space, we show only the implementation of the <code>deposit</code> operation;
the other operations can be implemented in a similar fashion.

<blockquote>
<pre>
MODULE Server;
IMPORT Bank, NetObj;
<br>
TYPE
  BankImpl = Bank.T OBJECT
    accounts : ARRAY Bank.AcctNum OF Account;
    lock     : MUTEX;
  OVERRIDES
      deposit     := Deposit;
      withdraw    := Withdraw; (* not included *)
      get_balance := Balance; (* not included *)
  END;
<br>
  Account = RECORD
      balance : REAL := 0.0;
  END;
<br>
PROCEDURE Deposit (self: BankImpl; acct: Bank.AcctNum; amount: REAL)
                   RAISES {Bank.BadAmount} =
<br>
  BEGIN
    IF amount &lt; 0.0 THEN RAISE Bank.BadAmount; END;
    LOCK self.lock DO
      WITH bal = self.accounts[acct].balance DO
        bal := bal + amount;
      END;
    END;
  END Deposit;
<br>
(* The implementations of &quot;Withdraw&quot; and &quot;Balance&quot; would go here. *)
<br>
VAR bank := NEW (BankImpl, lock := NEW(MUTEX));
BEGIN
  NetObj.Export (&quot;LastNationalBank&quot;, bank);
<br>
(* Here would might start other threads to audit or manage the bank.<br>
Finally, the program must wait until the bank is closed. *)
END Server.
</pre></blockquote>
<P>
The above example demonstrates that coding a simple server in Reactor is
indeed simple. The code resembles quite closely the code that you would
write if you were building a non-distributed version of the <code>Bank</code> interface.
The primary difference is the need to make the <code>bank</code> object visible via the
<code>NetObj.Export</code> operation. This operation binds a name 
(&quot;<code>LastNationalBank</code>&quot;)
in the global namespace to a local object (<code>bank</code>), allowing clients running
on other machines to access it. The Network Objects run-time creates threads
to handle incoming connections as they are needed. When incoming calls arrive
for the object named &quot;<code>LastNationalBank</code>&quot;, they are dispatched to
our implementation.
<p>
Next we outline a simple client of the bank. This client receives the object
representing the &quot;<code>LastNationalBank</code>&quot;, deposits some money in an
account via the <code>deposit</code> command and prints the final balance. Despite its
simplicity, this client will work properly regardless of whether the bank
is located in the same room, down the street, or across the county.

<blockquote>
<pre>
MODULE Client;
IMPORT Bank, NetObj;
IMPORT IO, Fmt;
<br>
CONST
  MyBank : TEXT = &quot;LastNationalBank&quot;;
  MyAcct : Bank.AcctNum = 99;
<br>
VAR
  bank: Bank.T;
BEGIN
  TRY
    bank := NetObj.Import (MyBank);
    bank.deposit (MyAcct, 125.00);
    WITH balance = bank.get_balance(MyAcct) DO
      IO.Put (&quot;My account balance is &quot; &amp; Fmt.Real(balance) &amp;&quot;\n&quot;);
    END;
  EXCEPT
  | NetObj.Error =&gt; IO.Put (&quot;A network error occured\n&quot;);
  | Bank.BadAmount =&gt; &lt;* ASSERT FALSE *&gt;
  (* BadAmount will not be raised for positive deposits. *)
  END;
END Client.
</pre></blockquote>

<H4><EM>A Slightly More Realistic Example</EM></H4>

In the example above, the <code>Bank.T</code> object provided operations for modifying
accounts. We now extend the example to include separate <code>Bank.Account</code> objects
which could implement different interest, penalty or usage policies. <code>Bank.T</code>
provides operations for looking up accounts, while <code>Bank.Account</code> provides
operations for depositing and withdrawing money. Here is the new <code>Bank</code> interface:

<blockquote>
<pre>
INTERFACE Bank;
IMPORT NetObj;
<br>
TYPE
  T = NetObj.T OBJECT METHODS
    findAccount (acct: AcctNum): Account;
  END;
<br>
TYPE
  Account = NetObj.T OBJECT METHODS
    deposit (amount: REAL) RAISES {BadAmount};
    withdraw (amount: REAL) RAISES {BadAmount, InsufficientFunds};
    get_balance (): REAL;
  END;
<br>
TYPE
  AcctNum = [1..100];
<br>
EXCEPTION
  BadAmount;
  InsufficientFunds;
<br>
END Bank.
</pre></blockquote>
<p>
We now sketch the implementation of a bank server that manages both banks
and accounts:

<blockquote>
<pre>
MODULE Server;
<br>
IMPORT Bank, NetObj;
<br>
TYPE
    BankImpl = Bank.T OBJECT
    accounts : ARRAY Bank.AcctNum OF Account;
  OVERRIDES
    findAccount := FindAccount;
  END;
<br>
TYPE
  Account = Bank.Account OBJECT
    lock    : MUTEX;
    balance : REAL := 0.0;
  OVERRIDES
    deposit := Deposit;
    withdraw := Withdraw; (* not included *)
    get_balance := Balance; (* not included *)
  END;
<br>
PROCEDURE FindAccount (self: BankImpl; acct: Bank.AcctNum): Bank.Account =
  BEGIN
    RETURN self.accounts[acct];
  END FindAccount;
<br>
PROCEDURE Deposit (self: Account; amount: REAL) RAISES {Bank.BadAmount} =
(* Deposit the money,
   making sure to serialize access with others trying to operate on this account.*)
  BEGIN
    IF amount &lt; 0.0 THEN RAISE Bank.BadAmount; END;
      LOCK self.lock DO
        self.balance := self.balance + amount;
      END;
  END Deposit;
<br>
(* The implementations of &quot;Withdraw&quot; and &quot;Balance&quot; would go here. *)
<br>
PROCEDURE NewBank () : BankImpl =
  VAR b := NEW (BankImpl);
  BEGIN
    FOR i := FIRST (b.accounts) TO LAST (b.accounts) DO
      b.accounts[i] := NEW (Account, lock := NEW (MUTEX));
    END;
    RETURN b;
  END NewBank;
<br>
BEGIN
  NetObj.Export (&quot;LastNationalBank&quot;, NewBank ());
<br>
  (* Here would might start other threads to audit or manage the bank.
     Finally, the program must wait until the bank is closed. *)
END Server.
</pre></blockquote>
<p>
In this version, the client gets an account object (of type <code>Bank.Account</code>)
from the bank and then makes deposits, withdrawals, and checks balances
on that account object. When the client finishes using that account object,
it does not need to clean up after itself, unlike what would be required
in most client/server or corba systems today. Instead, the garbage collector
on the client will determine that the account object is no longer being
used. Then, it will inform the garbage collector at the server that the
account object has one less client. When the garbage collector on the server
determines there are no more clients using this account object, it will
reclaim the storage used by the Network Objects run-time. 
<p>
Distributed garbage collection is key in creating robust client/server programs.
Manually managing memory within a single program is hard enough; manual
memory management across clients and servers when hardware failures are
possible is nearly impossible. Without distributed garbage collection, the
application designer would need to invent and follow conventions that allow
a client to inform the server when it finishes using the account object.
What would happen if the client crashed unexpectedly or failed to make that
call? Slowly, the server would accumulate more and more objects that it
couldn't free; eventually it would crash. By providing a robust distributed
garbage collection protocol, Reactor dramatically eases the development
of long-running client-server and distributed applications. Distributed
garbage collection also simplifies the development of the middle layers
in multi-tiered systems.

<H3>Future Directions</H3>

<H4><EM>Network OLE/Distributed COM</EM></H4>

As Network ole becomes a major force in enterprise connectivity, we are
planning an implementation of our distribution architecture on top of Network
ole. The goal of this effort is to allow remote ole objects to be treated
in a uniform fashion with Reactor programming language level objects. 

<H4><EM>Microsoft IIS &amp; Netscape Communications Server</EM></H4>

IIs is the Microsoft architecture for developing extensible Internet information
servers (HTTP servers). As this architecture becomes finalized, we intend
to provide a framework that allows HTTP server extensions to be written
in Modula-3. This will allow extensions to be written in a safe and compiled
programming language. We expect our system to perform better and be safer
than current web-based solutions. Safety is critical as HTTP servers are
expected to run continuously. Dynamically loaded extensions should not be
able to corrupt a server's memory. Current solutions (such as Netscape's
Communication Server) require a multi-process architecture where the server
process keeps extensions in separate processes. Because they are separate,
they pose no safety threat and are often killed to reclaim resources.

<H4><EM>Advanced Distributed Services: Distributed Transactions</EM></H4>

Based on the Network and Stable Objects platform, Critical Mass intends
to release a set of portable, distributed services, such as distributed
transactions performing two-phase commit and recovery.

<H4><EM>Many Other Libraries</EM></H4>

The Reactor distribution contains a large number of Modula-3 packages not
mentioned here. These libraries also take advantage of Modula-3's state-of-the-art
features. Some examples are a multi-threaded windowing toolkit called Trestle,
packages that extend Trestle with animation and 3D graphics, and m3tk, a
meta-programming library for Modula-3 programs.
<p>
<img src="architecture.gif">
<P>
<blockquote>
<em>The Reactor Architecture: Reactor¹s robust core is the basis for
its tight integration with industry standards on the front-end and
the back-end, making Reactor into an ideal choice for serious systems
architects and programmers.
</em>
<a href="architecture_full.gif">Full size image, 35K.</a>
</blockquote>

<H3>Conclusions</H3>

Reactor is an environment for developing robust and distributed applications
that can handle the requirements of today's businesses. With its state-of-the-art
web-based user interface, training programmers to use Reactor is straightforward.
Reactor greatly aids the development of large distributed programs with
features such as distributed memory management, integral support for threads,
Win32/Unix portability, and a rich collection of safe, multi-threaded libraries.
<p>
<hr>
Copyright &copy 1996 Critical Mass, Inc. All Rights Reserved. Reactor is a trademark of Critical Mass, Inc.

<!-- Copyright (C) 1996 Critical Mass. All rights reserved. -->
</BODY>
</HTML>
