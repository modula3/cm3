(*******************************************************************************
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.4.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
*******************************************************************************)

INTERFACE LLVM;



IMPORT LLVMTypes, Word;

TYPE
  int64_t = LLVMTypes.int64_t;
  uint64_t = LLVMTypes.uint64_t;
  int32_t = LLVMTypes.int32_t;
  uint32_t = LLVMTypes.uint32_t;
  uint8_t = LLVMTypes.uint8_t;

TYPE
  Opaque = RECORD END;

  MetadataRef = LLVMTypes.MetadataRef;
  PassRegistryRef = UNTRACED BRANDED "LLVMOpaquePassRegistry" REF Opaque;
  ContextRef = UNTRACED BRANDED "LLVMOpaqueContext" REF Opaque;
  DiagnosticInfoRef =
    UNTRACED BRANDED "LLVMOpaqueDiagnosticInfo" REF Opaque;
  AttributeRef = UNTRACED BRANDED "LLVMOpaqueAttribute" REF Opaque;
  ModuleRef = UNTRACED BRANDED "LLVMOpaqueModule" REF Opaque;
  TypeRef = UNTRACED BRANDED "LLVMOpaqueType" REF Opaque;
  ValueRef = UNTRACED BRANDED "LLVMOpaqueValue" REF Opaque;
  NamedMDNodeRef = UNTRACED BRANDED "LLVMOpaqueNamedMDNode" REF Opaque;
  TypeKindRef = UNTRACED BRANDED "LLVMOpaqueTypeKind" REF Opaque;
  UseRef = UNTRACED BRANDED "LLVMOpaqueUse" REF Opaque;
  BasicBlockRef = UNTRACED BRANDED "LLVMOpaqueBasicBlock" REF Opaque;
  ValueMetadataEntryRef =
    UNTRACED BRANDED "LLVMOpaqueValueMetadataEntry" REF Opaque;
  BuilderRef = UNTRACED BRANDED "LLVMOpaqueBuilder" REF Opaque;
  ModuleProviderRef =
    UNTRACED BRANDED "LLVMOpaqueModuleProvider" REF Opaque;
  MemoryBufferRef = UNTRACED BRANDED "LLVMOpaqueMemoryBuffer" REF Opaque;
  PassManagerRef = UNTRACED BRANDED "LLVMOpaquePassManager" REF Opaque;
  ModuleFlagEntry =
    UNTRACED BRANDED "LLVMOpaqueModuleFlagEntry" REF Opaque;

  DiagnosticHandler = PROCEDURE (info: DiagnosticInfoRef; parm: ADDRESS);
  YieldCallback = PROCEDURE (info: ContextRef; parm: ADDRESS);

  DbgRecordRef = UNTRACED BRANDED "LLVMDbgRecordRef" REF Opaque;
  OperandBundleRef = UNTRACED BRANDED "LLVMOperandBundleRef" REF Opaque;
  TargetDataRef = UNTRACED BRANDED "LLVMTargetDataRef" REF Opaque;
  TargetLibraryInfoRef =
    UNTRACED BRANDED "LLVMTargetLibraryInfoRef" REF Opaque;

TYPE
  DiagnosticSeverity = LLVMDiagnosticSeverity;
  ModuleFlagBehaviour = LLVMModuleFlagBehavior;
  InLineAsmDialect = LLVMInlineAsmDialect;
  LLStorageClass = LLVMDLLStorageClass;
  Visibility = LLVMVisibility;
  Linkage = LLVMLinkage;
  Opcode = LLVMOpcode;
  ValueKind = LLVMValueKind;
  UnnameAddr = LLVMUnnamedAddr;
  ThreadLocalMode = LLVMThreadLocalMode;
  IntPredicate = LLVMIntPredicate;
  RealPredicate = LLVMRealPredicate;
  AtomicOrdering = LLVMAtomicOrdering;
  AtomicRMWBinOp = LLVMAtomicRMWBinOp;
  TailCallKind = LLVMTailCallKind;

  QuadArr = ARRAY [0 .. 1] OF uint64_t;
  QuadRef = UNTRACED REF QuadArr;

  AttributeIndex = Word.T;


TYPE
  LLVMOpcode =
    {XXXX_0, LLVMRet, LLVMBr, LLVMSwitch, LLVMIndirectBr, LLVMInvoke,
     XXXX_6, LLVMUnreachable, LLVMAdd, LLVMFAdd, LLVMSub, LLVMFSub,
     LLVMMul, LLVMFMul, LLVMUDiv, LLVMSDiv, LLVMFDiv, LLVMURem, LLVMSRem,
     LLVMFRem, LLVMShl, LLVMLShr, LLVMAShr, LLVMAnd, LLVMOr, LLVMXor,
     LLVMAlloca, LLVMLoad, LLVMStore, LLVMGetElementPtr, LLVMTrunc,
     LLVMZExt, LLVMSExt, LLVMFPToUI, LLVMFPToSI, LLVMUIToFP, LLVMSIToFP,
     LLVMFPTrunc, LLVMFPExt, LLVMPtrToInt, LLVMIntToPtr, LLVMBitCast,
     LLVMICmp, LLVMFCmp, LLVMPHI, LLVMCall, LLVMSelect, LLVMUserOp1,
     LLVMUserOp2, LLVMVAArg, LLVMExtractElement, LLVMInsertElement,
     LLVMShuffleVector, LLVMExtractValue, LLVMInsertValue, LLVMFence,
     LLVMAtomicCmpXchg, LLVMAtomicRMW, LLVMResume, LLVMLandingPad,
     LLVMAddrSpaceCast, LLVMCleanupRet, LLVMCatchRet, LLVMCatchPad,
     LLVMCleanupPad, LLVMCatchSwitch, LLVMFNeg, LLVMCallBr, LLVMFreeze,
     LLVMPtrToAddr};


TYPE
  LLVMTypeKind =
    {LLVMVoidTypeKind (** type with no size *),
     LLVMHalfTypeKind (** 16 bit floating point type *),
     LLVMFloatTypeKind (** 32 bit floating point type *),
     LLVMDoubleTypeKind (** 64 bit floating point type *),
     LLVMX86_FP80TypeKind (** 80 bit floating point type (X87) *),
     LLVMFP128TypeKind (** 128 bit floating point type (112-bit mantissa)*),
     LLVMPPC_FP128TypeKind (** 128 bit floating point type (two 64-bits) *),
     LLVMLabelTypeKind (** Labels *),
     LLVMIntegerTypeKind (** Arbitrary bit width integers *),
     LLVMFunctionTypeKind (** Functions *),
     LLVMStructTypeKind (** Structures *), LLVMArrayTypeKind (** Arrays *),
     LLVMPointerTypeKind (** Pointers *),
     LLVMVectorTypeKind (** Fixed width SIMD vector type *),
     LLVMMetadataTypeKind (** Metadata *), XXXX_15,
     LLVMTokenTypeKind (** Tokens *),
     LLVMScalableVectorTypeKind (** Scalable SIMD vector type *),
     LLVMBFloatTypeKind (** 16 bit brain floating point type *),
     LLVMX86_AMXTypeKind (** X86 AMX *),
     LLVMTargetExtTypeKind (** Target extension type *)};


TYPE
  LLVMLinkage =
    {LLVMExternalLinkage,        (** Externally visible function *)
     LLVMAvailableExternallyLinkage,
     LLVMLinkOnceAnyLinkage,     (** Keep one copy of function when linking (inline)*)
     LLVMLinkOnceODRLinkage,     (** Same, but only replaced by something                            * equivalent.                             *)
     LLVMLinkOnceODRAutoHideLinkage, (** Obsolete *)
     LLVMWeakAnyLinkage,         (** Keep one copy of function when linking (weak) *)
     LLVMWeakODRLinkage,         (** Same, but only replaced by something                            * equivalent.                             *)
     LLVMAppendingLinkage,       (** Special purpose, only applies to global arrays *)
     LLVMInternalLinkage,        (** Rename collisions when linking (static                               * functions)                                *)
     LLVMPrivateLinkage,         (** Like Internal, but omit from symbol table *)
     LLVMDLLImportLinkage,       (** Obsolete *)
     LLVMDLLExportLinkage,       (** Obsolete *)
     LLVMExternalWeakLinkage,    (** ExternalWeak linkage description *)
     LLVMGhostLinkage,           (** Obsolete *)
     LLVMCommonLinkage,          (** Tentative definitions *)
     LLVMLinkerPrivateLinkage,   (** Like Private, but linker removes. *)
     LLVMLinkerPrivateWeakLinkage (** Like LinkerPrivate, but is weak. *)
    };


TYPE
  LLVMVisibility = {LLVMDefaultVisibility, (** The GV is visible *)
                    LLVMHiddenVisibility, (** The GV is hidden *)
                    LLVMProtectedVisibility (** The GV is protected *)
                   };


TYPE
  LLVMUnnamedAddr =
    {LLVMNoUnnamedAddr,          (** Address of the GV is significant. *)
     LLVMLocalUnnamedAddr,       (** Address of the GV is locally insignificant. *)
     LLVMGlobalUnnamedAddr       (** Address of the GV is globally insignificant. *)
    };


TYPE
  LLVMDLLStorageClass =
    {LLVMDefaultStorageClass,
     LLVMDLLImportStorageClass (** Function to be imported from DLL. *),
     LLVMDLLExportStorageClass (** Function to be accessible from DLL. *)};


TYPE
  LLVMCallConv = {LLVMCCallConv, XXXX_1, XXXX_2, XXXX_3, XXXX_4, XXXX_5,
                  XXXX_6, XXXX_7, LLVMFastCallConv, LLVMColdCallConv,
                  LLVMGHCCallConv, LLVMHiPECallConv, XXXX_12,
                  LLVMAnyRegCallConv, LLVMPreserveMostCallConv,
                  LLVMPreserveAllCallConv, LLVMSwiftCallConv,
                  LLVMCXXFASTTLSCallConv, XXXX_18, XXXX_19, XXXX_20,
                  XXXX_21, XXXX_22, XXXX_23, XXXX_24, XXXX_25, XXXX_26,
                  XXXX_27, XXXX_28, XXXX_29, XXXX_30, XXXX_31, XXXX_32,
                  XXXX_33, XXXX_34, XXXX_35, XXXX_36, XXXX_37, XXXX_38,
                  XXXX_39, XXXX_40, XXXX_41, XXXX_42, XXXX_43, XXXX_44,
                  XXXX_45, XXXX_46, XXXX_47, XXXX_48, XXXX_49, XXXX_50,
                  XXXX_51, XXXX_52, XXXX_53, XXXX_54, XXXX_55, XXXX_56,
                  XXXX_57, XXXX_58, XXXX_59, XXXX_60, XXXX_61, XXXX_62,
                  XXXX_63, LLVMX86StdcallCallConv, LLVMX86FastcallCallConv,
                  LLVMARMAPCSCallConv, LLVMARMAAPCSCallConv,
                  LLVMARMAAPCSVFPCallConv, LLVMMSP430INTRCallConv,
                  LLVMX86ThisCallCallConv, LLVMPTXKernelCallConv,
                  LLVMPTXDeviceCallConv, XXXX_73, XXXX_74,
                  LLVMSPIRFUNCCallConv, LLVMSPIRKERNELCallConv,
                  LLVMIntelOCLBICallConv, LLVMX8664SysVCallConv,
                  LLVMWin64CallConv, LLVMX86VectorCallCallConv,
                  LLVMHHVMCallConv, LLVMHHVMCCallConv, LLVMX86INTRCallConv,
                  LLVMAVRINTRCallConv, LLVMAVRSIGNALCallConv,
                  LLVMAVRBUILTINCallConv, LLVMAMDGPUVSCallConv,
                  LLVMAMDGPUGSCallConv, LLVMAMDGPUPSCallConv,
                  LLVMAMDGPUCSCallConv, LLVMAMDGPUKERNELCallConv,
                  LLVMX86RegCallCallConv, LLVMAMDGPUHSCallConv,
                  LLVMMSP430BUILTINCallConv, LLVMAMDGPULSCallConv,
                  LLVMAMDGPUESCallConv};


TYPE
  LLVMValueKind =
    {LLVMArgumentValueKind, LLVMBasicBlockValueKind,
     LLVMMemoryUseValueKind, LLVMMemoryDefValueKind,
     LLVMMemoryPhiValueKind, LLVMFunctionValueKind,
     LLVMGlobalAliasValueKind, LLVMGlobalIFuncValueKind,
     LLVMGlobalVariableValueKind, LLVMBlockAddressValueKind,
     LLVMConstantExprValueKind, LLVMConstantArrayValueKind,
     LLVMConstantStructValueKind, LLVMConstantVectorValueKind,
     LLVMUndefValueValueKind, LLVMConstantAggregateZeroValueKind,
     LLVMConstantDataArrayValueKind, LLVMConstantDataVectorValueKind,
     LLVMConstantIntValueKind, LLVMConstantFPValueKind,
     LLVMConstantPointerNullValueKind, LLVMConstantTokenNoneValueKind,
     LLVMMetadataAsValueValueKind, LLVMInlineAsmValueKind,
     LLVMInstructionValueKind, LLVMPoisonValueValueKind,
     LLVMConstantTargetNoneValueKind, LLVMConstantPtrAuthValueKind};


TYPE
  LLVMIntPredicate =
    {XXXX_0, XXXX_1, XXXX_2, XXXX_3, XXXX_4, XXXX_5, XXXX_6, XXXX_7,
     XXXX_8, XXXX_9, XXXX_10, XXXX_11, XXXX_12, XXXX_13, XXXX_14, XXXX_15,
     XXXX_16, XXXX_17, XXXX_18, XXXX_19, XXXX_20, XXXX_21, XXXX_22,
     XXXX_23, XXXX_24, XXXX_25, XXXX_26, XXXX_27, XXXX_28, XXXX_29,
     XXXX_30, XXXX_31, LLVMIntEQ (** equal *), LLVMIntNE (** not equal *),
     LLVMIntUGT (** unsigned greater than *),
     LLVMIntUGE (** unsigned greater or equal *),
     LLVMIntULT (** unsigned less than *),
     LLVMIntULE (** unsigned less or equal *),
     LLVMIntSGT (** signed greater than *),
     LLVMIntSGE (** signed greater or equal *),
     LLVMIntSLT (** signed less than *),
     LLVMIntSLE (** signed less or equal *)};


TYPE
  LLVMRealPredicate =
    {LLVMRealPredicateFalse,     (** Always false (always folded) *)
     LLVMRealOEQ,                (** True if ordered and equal *)
     LLVMRealOGT,                (** True if ordered and greater than *)
     LLVMRealOGE,                (** True if ordered and greater than or equal *)
     LLVMRealOLT,                (** True if ordered and less than *)
     LLVMRealOLE,                (** True if ordered and less than or equal *)
     LLVMRealONE,                (** True if ordered and operands are unequal *)
     LLVMRealORD,                (** True if ordered (no nans) *)
     LLVMRealUNO,                (** True if unordered: isnan(X) | isnan(Y) *)
     LLVMRealUEQ,                (** True if unordered or equal *)
     LLVMRealUGT,                (** True if unordered or greater than *)
     LLVMRealUGE,                (** True if unordered, greater than, or equal *)
     LLVMRealULT,                (** True if unordered or less than *)
     LLVMRealULE,                (** True if unordered, less than, or equal *)
     LLVMRealUNE,                (** True if unordered or not equal *)
     LLVMRealPredicateTrue       (** Always true (always folded) *)
    };


TYPE
  LLVMThreadLocalMode = {LLVMNotThreadLocal, LLVMGeneralDynamicTLSModel,
                         LLVMLocalDynamicTLSModel, LLVMInitialExecTLSModel,
                         LLVMLocalExecTLSModel};


TYPE
  LLVMAtomicOrdering =
    {LLVMAtomicOrderingNotAtomic (** A load or store which is not atomic *),
     LLVMAtomicOrderingUnordered (** Lowest level of atomicity, guarantees                                     * somewhat sane results, lock free.                                      *),
     LLVMAtomicOrderingMonotonic (** guarantees that if you take all the                                     * operations affecting a specific address,                                     * a consistent ordering exists                                      *),
     XXXX_3,
     LLVMAtomicOrderingAcquire (** Acquire provides a barrier of the sort                                   * necessary to acquire a lock to access other                                   * memory with normal loads and stores.                                    *),
     LLVMAtomicOrderingRelease (** Release is similar to Acquire, but with                                   * a barrier of the sort necessary to release                                   * a lock.                                    *),
     LLVMAtomicOrderingAcquireRelease (** provides both an Acquire and a                                          * Release barrier (for fences and                                          * operations which both read and write                                           * memory).                                           *),
     LLVMAtomicOrderingSequentiallyConsistent (** provides Acquire semantics                                                 * for loads and Release                                                 * semantics for stores.                                                 * Additionally, it guarantees                                                 * that a total ordering exists                                                 * between all                                                 * SequentiallyConsistent                                                 * operations.                                                  *)};


TYPE
  LLVMAtomicRMWBinOp =
    {LLVMAtomicRMWBinOpXchg,     (** Set the new value and return the one old *)
     LLVMAtomicRMWBinOpAdd,      (** Add a value and return the old one *)
     LLVMAtomicRMWBinOpSub,      (** Subtract a value and return the old one *)
     LLVMAtomicRMWBinOpAnd,      (** And a value and return the old one *)
     LLVMAtomicRMWBinOpNand,     (** Not-And a value and return the old one *)
     LLVMAtomicRMWBinOpOr,       (** OR a value and return the old one *)
     LLVMAtomicRMWBinOpXor,      (** Xor a value and return the old one *)
     LLVMAtomicRMWBinOpMax,      (** Sets the value if it's greater than the                            * original using a signed comparison and return                            * the old one                             *)
     LLVMAtomicRMWBinOpMin,      (** Sets the value if it's Smaller than the                            * original using a signed comparison and return                            * the old one                             *)
     LLVMAtomicRMWBinOpUMax,     (** Sets the value if it's greater than the                           * original using an unsigned comparison and return                           * the old one                            *)
     LLVMAtomicRMWBinOpUMin,     (** Sets the value if it's greater than the                            * original using an unsigned comparison and return                            * the old one                             *)
     LLVMAtomicRMWBinOpFAdd,     (** Add a floating point value and return the                            * old one                             *)
     LLVMAtomicRMWBinOpFSub,     (** Subtract a floating point value and return the                          * old one                           *)
     LLVMAtomicRMWBinOpFMax,     (** Sets the value if it's greater than the                           * original using an floating point comparison and                           * return the old one                            *)
     LLVMAtomicRMWBinOpFMin,     (** Sets the value if it's smaller than the                           * original using an floating point comparison and                           * return the old one                            *)
     LLVMAtomicRMWBinOpUIncWrap, (** Increments the value, wrapping back to zero                               * when incremented above input value                                *)
     LLVMAtomicRMWBinOpUDecWrap, (** Decrements the value, wrapping back to                               * the input value when decremented below zero                                *)
     LLVMAtomicRMWBinOpUSubCond, (**Subtracts the value only if no unsigned                                 * overflow                                  *)
     LLVMAtomicRMWBinOpUSubSat,  (**Subtracts the value, clamping to zero *)
     LLVMAtomicRMWBinOpFMaximum, (** Sets the value if it's greater than the                           * original using an floating point comparison and                           * return the old one                            *)
     LLVMAtomicRMWBinOpFMinimum  (** Sets the value if it's smaller than the                           * original using an floating point comparison and                           * return the old one                            *)
    };


TYPE
  LLVMDiagnosticSeverity =
    {LLVMDSError, LLVMDSWarning, LLVMDSRemark, LLVMDSNote};


TYPE
  LLVMInlineAsmDialect =
    {LLVMInlineAsmDialectATT, LLVMInlineAsmDialectIntel};


TYPE
  LLVMModuleFlagBehavior =
    {LLVMModuleFlagBehaviorError, (**   * Emits an error if two values disagree, otherwise the resulting value is   * that of the operands.   *   * @see Module::ModFlagBehavior::Error   *)
     LLVMModuleFlagBehaviorWarning, (**   * Emits a warning if two values disagree. The result value will be the   * operand for the flag from the first module being linked.   *   * @see Module::ModFlagBehavior::Warning   *)
     LLVMModuleFlagBehaviorRequire, (**   * Adds a requirement that another module flag be present and have a   * specified value after linking is performed. The value must be a metadata   * pair, where the first element of the pair is the ID of the module flag   * to be restricted, and the second element of the pair is the value the   * module flag should be restricted to. This behavior can be used to   * restrict the allowable results (via triggering of an error) of linking   * IDs with the **Override** behavior.   *   * @see Module::ModFlagBehavior::Require   *)
     LLVMModuleFlagBehaviorOverride, (**   * Uses the specified value, regardless of the behavior or value of the   * other module. If both modules specify **Override**, but the values   * differ, an error will be emitted.   *   * @see Module::ModFlagBehavior::Override   *)
     LLVMModuleFlagBehaviorAppend, (**   * Appends the two values, which are required to be metadata nodes.   *   * @see Module::ModFlagBehavior::Append   *)
     LLVMModuleFlagBehaviorAppendUnique (**   * Appends the two values, which are required to be metadata   * nodes. However, duplicate entries in the second list are dropped   * during the append operation.   *   * @see Module::ModFlagBehavior::AppendUnique   *)
    };


CONST                            (* Enum Enum1 *)
  LLVMAttributeReturnIndex   = 0;
  LLVMAttributeFunctionIndex = -1;

TYPE                             (* Enum Enum1 *)
  Enum1 = [-1 .. 0];


TYPE
  LLVMTailCallKind = {LLVMTailCallKindNone, LLVMTailCallKindTail,
                      LLVMTailCallKindMustTail, LLVMTailCallKindNoTail};


TYPE
  Enum2 =
    {LLVMFastMathNone, LLVMFastMathAllowReassoc, LLVMFastMathNoNaNs,
     XXXX_3, LLVMFastMathNoInfs, XXXX_5, XXXX_6, XXXX_7,
     LLVMFastMathNoSignedZeros, XXXX_9, XXXX_10, XXXX_11, XXXX_12, XXXX_13,
     XXXX_14, XXXX_15, LLVMFastMathAllowReciprocal, XXXX_17, XXXX_18,
     XXXX_19, XXXX_20, XXXX_21, XXXX_22, XXXX_23, XXXX_24, XXXX_25,
     XXXX_26, XXXX_27, XXXX_28, XXXX_29, XXXX_30, XXXX_31,
     LLVMFastMathAllowContract, XXXX_33, XXXX_34, XXXX_35, XXXX_36,
     XXXX_37, XXXX_38, XXXX_39, XXXX_40, XXXX_41, XXXX_42, XXXX_43,
     XXXX_44, XXXX_45, XXXX_46, XXXX_47, XXXX_48, XXXX_49, XXXX_50,
     XXXX_51, XXXX_52, XXXX_53, XXXX_54, XXXX_55, XXXX_56, XXXX_57,
     XXXX_58, XXXX_59, XXXX_60, XXXX_61, XXXX_62, XXXX_63,
     LLVMFastMathApproxFunc, XXXX_65, XXXX_66, XXXX_67, XXXX_68, XXXX_69,
     XXXX_70, XXXX_71, XXXX_72, XXXX_73, XXXX_74, XXXX_75, XXXX_76,
     XXXX_77, XXXX_78, XXXX_79, XXXX_80, XXXX_81, XXXX_82, XXXX_83,
     XXXX_84, XXXX_85, XXXX_86, XXXX_87, XXXX_88, XXXX_89, XXXX_90,
     XXXX_91, XXXX_92, XXXX_93, XXXX_94, XXXX_95, XXXX_96, XXXX_97,
     XXXX_98, XXXX_99, XXXX_100, XXXX_101, XXXX_102, XXXX_103, XXXX_104,
     XXXX_105, XXXX_106, XXXX_107, XXXX_108, XXXX_109, XXXX_110, XXXX_111,
     XXXX_112, XXXX_113, XXXX_114, XXXX_115, XXXX_116, XXXX_117, XXXX_118,
     XXXX_119, XXXX_120, XXXX_121, XXXX_122, XXXX_123, XXXX_124, XXXX_125,
     XXXX_126, LLVMFastMathAll};


TYPE
  Enum3 =
    {XXXX_0, LLVMGEPFlagInBounds, LLVMGEPFlagNUSW, XXXX_3, LLVMGEPFlagNUW};


(**
 * @}
  * Deallocate and destroy all ManagedStatic variables.
    * @see llvm::llvm_shutdown
    * @see ManagedStatic
 *)

PROCEDURE Shutdown ();


(**
 * Return the major, minor, and patch version of LLVM
 *
 * The version components are returned via the function's three output
 * parameters or skipped if a NULL pointer was supplied.
 *)

PROCEDURE GetVersion (VAR Major, Minor, Patch: uint32_t; );

PROCEDURE CreateMessage (Message: TEXT; ): TEXT;

PROCEDURE DisposeMessage (Message: TEXT; );


(**
 * Create a new context.
 *
 * Every call to this function should be paired with a call to
 * LLVMContextDispose() or the context will leak memory.
 *)

PROCEDURE ContextCreate (): ContextRef;


(**
 * Obtain the global context instance.
 *)

PROCEDURE GetGlobalContext (): ContextRef;


(**
 * Set the diagnostic handler for this context.
 *)

PROCEDURE ContextSetDiagnosticHandler (context: ContextRef;
                                       Handler: DiagnosticHandler;
                                       DiagnosticContext: ADDRESS; );


(**
 * Get the diagnostic handler of this context.
 *)

PROCEDURE ContextGetDiagnosticHandler (context: ContextRef; ):
  DiagnosticHandler;


(**
 * Get the diagnostic context of this context.
 *)

PROCEDURE ContextGetDiagnosticContext (context: ContextRef; ): ADDRESS;


(**
 * Set the yield callback function for this context.
 *
 * @see LLVMContext::setYieldCallback()
 *)

PROCEDURE ContextSetYieldCallback
  (context: ContextRef; Callback: YieldCallback; OpaqueHandle: ADDRESS; );


(**
 * Retrieve whether the given context is set to discard all value names.
 *
 * @see LLVMContext::shouldDiscardValueNames()
 *)

PROCEDURE ContextShouldDiscardValueNames (context: ContextRef; ): BOOLEAN;


(**
 * Set whether the given context discards all value names.
 *
 * If true, only the names of GlobalValue objects will be available in the IR.
 * This can be used to save memory and runtime, especially in release mode.
 *
 * @see LLVMContext::setDiscardValueNames()
 *)

PROCEDURE ContextSetDiscardValueNames
  (context: ContextRef; Discard: BOOLEAN; );


(**
 * Destroy a context instance.
 *
 * This should be called for every call to LLVMContextCreate() or memory
 * will be leaked.
 *)

PROCEDURE ContextDispose (context: ContextRef; );


(**
 * Return a string representation of the DiagnosticInfo. Use
 * LLVMDisposeMessage to free the string.
 *
 * @see DiagnosticInfo::print()
 *)

PROCEDURE GetDiagInfoDescription (DI: DiagnosticInfoRef; ): TEXT;


(**
 * Return an enum LLVMDiagnosticSeverity.
 *
 * @see DiagnosticInfo::getSeverity()
 *)

PROCEDURE GetDiagInfoSeverity (DI: DiagnosticInfoRef; ):
  LLVMDiagnosticSeverity;

PROCEDURE GetMDKindIDInContext
  (context: ContextRef; Name: TEXT; SLen: uint32_t; ): uint32_t;

PROCEDURE GetMDKindID (Name: TEXT; SLen: uint32_t; ): uint32_t;


(**
 * Maps a synchronization scope name to a ID unique within this context.
 *)

PROCEDURE GetSyncScopeID (context: ContextRef; Name: TEXT; SLen: Word.T; ):
  uint32_t;


(**
 * Return an unique id given the name of a enum attribute,
 * or 0 if no attribute by that name exists.
 *
 * See http://llvm.org/docs/LangRef.html#parameter-attributes
 * and http://llvm.org/docs/LangRef.html#function-attributes
 * for the list of available attributes.
 *
 * NB: Attribute names and/or id are subject to change without
 * going through the C API deprecation cycle.
 *)

PROCEDURE GetEnumAttributeKindForName (Name: TEXT; SLen: Word.T; ):
  uint32_t;

PROCEDURE GetLastEnumAttributeKind (): uint32_t;


(**
 * Create an enum attribute.
 *)

PROCEDURE CreateEnumAttribute
  (context: ContextRef; KindID: uint32_t; Val: uint64_t; ): AttributeRef;


(**
 * Get the unique id corresponding to the enum attribute
 * passed as argument.
 *)

PROCEDURE GetEnumAttributeKind (A: AttributeRef; ): uint32_t;


(**
 * Get the enum attribute's value. 0 is returned if none exists.
 *)

PROCEDURE GetEnumAttributeValue (A: AttributeRef; ): uint64_t;


(**
 * Create a type attribute
 *)

PROCEDURE CreateTypeAttribute
  (context: ContextRef; KindID: uint32_t; type_ref: TypeRef; ):
  AttributeRef;


(**
 * Get the type attribute's value.
 *)

PROCEDURE GetTypeAttributeValue (A: AttributeRef; ): TypeRef;


(**
 * Create a ConstantRange attribute.
 *
 * LowerWords and UpperWords need to be NumBits divided by 64 rounded up
 * elements long.
 *)

PROCEDURE CreateConstantRangeAttribute
  (context               : ContextRef;
   KindID, NumBits       : uint32_t;
   LowerWords, UpperWords: REF ARRAY OF uint64_t; ): AttributeRef;


(**
 * Create a string attribute.
 *)

PROCEDURE CreateStringAttribute (context: ContextRef;
                                 K      : TEXT;
                                 KLength: uint32_t;
                                 V      : TEXT;
                                 VLength: uint32_t;   ): AttributeRef;


(**
 * Get the string attribute's kind.
 *)

PROCEDURE GetStringAttributeKind (A: AttributeRef; VAR Length: uint32_t; ):
  TEXT;


(**
 * Get the string attribute's value.
 *)

PROCEDURE GetStringAttributeValue
  (A: AttributeRef; VAR Length: uint32_t; ): TEXT;


(**
 * Check for the different types of attributes.
 *)

PROCEDURE IsEnumAttribute (A: AttributeRef; ): BOOLEAN;

PROCEDURE IsStringAttribute (A: AttributeRef; ): BOOLEAN;

PROCEDURE IsTypeAttribute (A: AttributeRef; ): BOOLEAN;


(**
 * Obtain a Type from a context by its registered name.
 *)

PROCEDURE GetTypeByName2 (context: ContextRef; Name: TEXT; ): TypeRef;


(**
 * @}
 *
 * Create a new, empty module in the global context.
 *
 * This is equivalent to calling LLVMModuleCreateWithNameInContext with
 * LLVMGetGlobalContext() as the context parameter.
 *
 * Every invocation should be paired with LLVMDisposeModule() or memory
 * will be leaked.
 *)

PROCEDURE ModuleCreateWithName (ModuleID: TEXT; ): ModuleRef;


(**
 * Create a new, empty module in a specific context.
 *
 * Every invocation should be paired with LLVMDisposeModule() or memory
 * will be leaked.
 *)

PROCEDURE ModuleCreateWithNameInContext
  (ModuleID: TEXT; context: ContextRef; ): ModuleRef;


(**
 * Return an exact copy of the specified module.
 *)

PROCEDURE CloneModule (M: ModuleRef; ): ModuleRef;


(**
 * Destroy a module instance.
 *
 * This must be called for every created module or memory will be
 * leaked.
 *)

PROCEDURE DisposeModule (M: ModuleRef; );


(**
 * Soon to be deprecated.
 * See https://llvm.org/docs/RemoveDIsDebugInfo.html#c-api-changes
 *
 * Returns true if the module is in the new debug info mode which uses
 * non-instruction debug records instead of debug intrinsics for variable
 * location tracking.
 *)

PROCEDURE IsNewDbgInfoFormat (M: ModuleRef; ): BOOLEAN;


(**
 * Soon to be deprecated.
 * See https://llvm.org/docs/RemoveDIsDebugInfo.html#c-api-changes
 *
 * Convert module into desired debug info format.
 *)

PROCEDURE SetIsNewDbgInfoFormat (M: ModuleRef; UseNewFormat: BOOLEAN; );


(**
 * Obtain the identifier of a module.
 *
 * @param M Module to obtain identifier of
 * @param Len Out parameter which holds the length of the returned string.
 * @return The identifier of M.
 * @see Module::getModuleIdentifier()
 *)

PROCEDURE GetModuleIdentifier (M: ModuleRef; VAR Len: Word.T; ): TEXT;


(**
 * Set the identifier of a module to a string Ident with length Len.
 *
 * @param M The module to set identifier
 * @param Ident The string to set M's identifier to
 * @param Len Length of Ident
 * @see Module::setModuleIdentifier()
 *)

PROCEDURE SetModuleIdentifier (M: ModuleRef; Ident: TEXT; Len: Word.T; );


(**
 * Obtain the module's original source file name.
 *
 * @param M Module to obtain the name of
 * @param Len Out parameter which holds the length of the returned string
 * @return The original source file name of M
 * @see Module::getSourceFileName()
 *)

PROCEDURE GetSourceFileName (M: ModuleRef; VAR Len: Word.T; ): TEXT;


(**
 * Set the original source file name of a module to a string Name with length
 * Len.
 *
 * @param M The module to set the source file name of
 * @param Name The string to set M's source file name to
 * @param Len Length of Name
 * @see Module::setSourceFileName()
 *)

PROCEDURE SetSourceFileName (M: ModuleRef; Name: TEXT; Len: Word.T; );


(**
 * Obtain the data layout for a module.
 *
 * @see Module::getDataLayoutStr()
 *
 * LLVMGetDataLayout is DEPRECATED, as the name is not only incorrect,
 * but match the name of another method on the module. Prefer the use
 * of LLVMGetDataLayoutStr, which is not ambiguous.
 *)

PROCEDURE GetDataLayoutStr (M: ModuleRef; ): TEXT;

PROCEDURE GetDataLayout (M: ModuleRef; ): TEXT;


(**
 * Set the data layout for a module.
 *
 * @see Module::setDataLayout()
 *)

PROCEDURE SetDataLayout (M: ModuleRef; DataLayoutStr: TEXT; );


(**
 * Obtain the target triple for a module.
 *
 * @see Module::getTargetTriple()
 *)

PROCEDURE GetTarget (M: ModuleRef; ): TEXT;


(**
 * Set the target triple for a module.
 *
 * @see Module::setTargetTriple()
 *)

PROCEDURE SetTarget (M: ModuleRef; Triple: TEXT; );


(**
 * Returns the module flags as an array of flag-key-value triples.  The caller
 * is responsible for freeing this array by calling
 * \c LLVMDisposeModuleFlagsMetadata.
 *
 * @see Module::getModuleFlagsMetadata()
 *)

PROCEDURE CopyModuleFlagsMetadata (M: ModuleRef; VAR Len: Word.T; ):
  UNTRACED REF ModuleFlagEntry;


(**
 * Destroys module flags metadata entries.
 *)

PROCEDURE DisposeModuleFlagsMetadata
  (Entries: UNTRACED REF ModuleFlagEntry; );


(**
 * Returns the flag behavior for a module flag entry at a specific index.
 *
 * @see Module::ModuleFlagEntry::Behavior
 *)

PROCEDURE ModuleFlagEntriesGetFlagBehavior
  (Entries: UNTRACED REF ModuleFlagEntry; Index: uint32_t; ):
  LLVMModuleFlagBehavior;


(**
 * Returns the key for a module flag entry at a specific index.
 *
 * @see Module::ModuleFlagEntry::Key
 *)

PROCEDURE ModuleFlagEntriesGetKey (Entries: UNTRACED REF ModuleFlagEntry;
                                   Index  : uint32_t;
                                   VAR Len: Word.T; ): TEXT;


(**
 * Returns the metadata for a module flag entry at a specific index.
 *
 * @see Module::ModuleFlagEntry::Val
 *)

PROCEDURE ModuleFlagEntriesGetMetadata
  (Entries: UNTRACED REF ModuleFlagEntry; Index: uint32_t; ): MetadataRef;


(**
 * Add a module-level flag to the module-level flags metadata if it doesn't
 * already exist.
 *
 * @see Module::getModuleFlag()
 *)

PROCEDURE GetModuleFlag (M: ModuleRef; Key: TEXT; KeyLen: Word.T; ):
  MetadataRef;


(**
 * Add a module-level flag to the module-level flags metadata if it doesn't
 * already exist.
 *
 * @see Module::addModuleFlag()
 *)

PROCEDURE AddModuleFlag (M       : ModuleRef;
                         Behavior: LLVMModuleFlagBehavior;
                         Key     : TEXT;
                         KeyLen  : Word.T;
                         Val     : MetadataRef;            );


(**
 * Dump a representation of a module to stderr.
 *
 * @see Module::dump()
 *)

PROCEDURE DumpModule (M: ModuleRef; );


(**
 * Print a representation of a module to a file. The ErrorMessage needs to be
 * disposed with LLVMDisposeMessage. Returns 0 on success, 1 otherwise.
 *
 * @see Module::print()
 *)

PROCEDURE PrintModuleToFile
  (M: ModuleRef; Filename: TEXT; VAR ErrorMessage: TEXT; ): BOOLEAN;


(**
 * Return a string representation of the module. Use
 * LLVMDisposeMessage to free the string.
 *
 * @see Module::print()
 *)

PROCEDURE PrintModuleToString (M: ModuleRef; ): TEXT;


(**
 * Get inline assembly for a module.
 *
 * @see Module::getModuleInlineAsm()
 *)

PROCEDURE GetModuleInlineAsm (M: ModuleRef; VAR Len: Word.T; ): TEXT;


(**
 * Set inline assembly for a module.
 *
 * @see Module::setModuleInlineAsm()
 *)

PROCEDURE SetModuleInlineAsm2 (M: ModuleRef; Asm: TEXT; Len: Word.T; );


(**
 * Append inline assembly to a module.
 *
 * @see Module::appendModuleInlineAsm()
 *)

PROCEDURE AppendModuleInlineAsm (M: ModuleRef; Asm: TEXT; Len: Word.T; );


(**
 * Create the specified uniqued inline asm string.
 *
 * @see InlineAsm::get()
 *)

PROCEDURE GetInlineAsm (Ty                          : TypeRef;
                        AsmString                   : TEXT;
                        AsmStringSize               : Word.T;
                        Constraints                 : TEXT;
                        ConstraintsSize             : Word.T;
                        HasSideEffects, IsAlignStack: BOOLEAN;
                        Dialect : LLVMInlineAsmDialect;
                        CanThrow: BOOLEAN;              ): ValueRef;


(**
 * Get the template string used for an inline assembly snippet
 *
 *)

PROCEDURE GetInlineAsmAsmString
  (InlineAsmVal: ValueRef; VAR Len: Word.T; ): TEXT;


(**
 * Get the raw constraint string for an inline assembly snippet
 *
 *)

PROCEDURE GetInlineAsmConstraintString
  (InlineAsmVal: ValueRef; VAR Len: Word.T; ): TEXT;


(**
 * Get the dialect used by the inline asm snippet
 *
 *)

PROCEDURE GetInlineAsmDialect (InlineAsmVal: ValueRef; ):
  LLVMInlineAsmDialect;


(**
 * Get the function type of the inline assembly snippet. The same type that
 * was passed into LLVMGetInlineAsm originally
 *
 * @see LLVMGetInlineAsm
 *
 *)

PROCEDURE GetInlineAsmFunctionType (InlineAsmVal: ValueRef; ): TypeRef;


(**
 * Get if the inline asm snippet has side effects
 *
 *)

PROCEDURE GetInlineAsmHasSideEffects (InlineAsmVal: ValueRef; ): BOOLEAN;


(**
 * Get if the inline asm snippet needs an aligned stack
 *
 *)

PROCEDURE GetInlineAsmNeedsAlignedStack (InlineAsmVal: ValueRef; ):
  BOOLEAN;


(**
 * Get if the inline asm snippet may unwind the stack
 *
 *)

PROCEDURE GetInlineAsmCanUnwind (InlineAsmVal: ValueRef; ): BOOLEAN;


(**
 * Obtain the context to which this module is associated.
 *
 * @see Module::getContext()
 *)

PROCEDURE GetModuleContext (M: ModuleRef; ): ContextRef;


(** Deprecated: Use LLVMGetTypeByName2 instead. *)

PROCEDURE GetTypeByName (M: ModuleRef; Name: TEXT; ): TypeRef;


(**
 * Obtain an iterator to the first NamedMDNode in a Module.
 *
 * @see llvm::Module::named_metadata_begin()
 *)

PROCEDURE GetFirstNamedMetadata (M: ModuleRef; ): NamedMDNodeRef;


(**
 * Obtain an iterator to the last NamedMDNode in a Module.
 *
 * @see llvm::Module::named_metadata_end()
 *)

PROCEDURE GetLastNamedMetadata (M: ModuleRef; ): NamedMDNodeRef;


(**
 * Advance a NamedMDNode iterator to the next NamedMDNode.
 *
 * Returns NULL if the iterator was already at the end and there are no more
 * named metadata nodes.
 *)

PROCEDURE GetNextNamedMetadata (NamedMDNode: NamedMDNodeRef; ):
  NamedMDNodeRef;


(**
 * Decrement a NamedMDNode iterator to the previous NamedMDNode.
 *
 * Returns NULL if the iterator was already at the beginning and there are
 * no previous named metadata nodes.
 *)

PROCEDURE GetPreviousNamedMetadata (NamedMDNode: NamedMDNodeRef; ):
  NamedMDNodeRef;


(**
 * Retrieve a NamedMDNode with the given name, returning NULL if no such
 * node exists.
 *
 * @see llvm::Module::getNamedMetadata()
 *)

PROCEDURE GetNamedMetadata (M: ModuleRef; Name: TEXT; NameLen: Word.T; ):
  NamedMDNodeRef;


(**
 * Retrieve a NamedMDNode with the given name, creating a new node if no such
 * node exists.
 *
 * @see llvm::Module::getOrInsertNamedMetadata()
 *)

PROCEDURE GetOrInsertNamedMetadata
  (M: ModuleRef; Name: TEXT; NameLen: Word.T; ): NamedMDNodeRef;


(**
 * Retrieve the name of a NamedMDNode.
 *
 * @see llvm::NamedMDNode::getName()
 *)

PROCEDURE GetNamedMetadataName
  (NamedMD: NamedMDNodeRef; VAR NameLen: Word.T; ): TEXT;


(**
 * Obtain the number of operands for named metadata in a module.
 *
 * @see llvm::Module::getNamedMetadata()
 *)

PROCEDURE GetNamedMetadataNumOperands (M: ModuleRef; Name: TEXT; ):
  uint32_t;


(**
 * Obtain the named metadata operands for a module.
 *
 * The passed LLVMValueRef pointer should refer to an array of
 * LLVMValueRef at least LLVMGetNamedMetadataNumOperands long. This
 * array will be populated with the LLVMValueRef instances. Each
 * instance corresponds to a llvm::MDNode.
 *
 * @see llvm::Module::getNamedMetadata()
 * @see llvm::MDNode::getOperand()
 *)

PROCEDURE GetNamedMetadataOperands
  (M: ModuleRef; Name: TEXT; Dest: UNTRACED REF ValueRef; );


(**
 * Add an operand to named metadata.
 *
 * @see llvm::Module::getNamedMetadata()
 * @see llvm::MDNode::addOperand()
 *)

PROCEDURE AddNamedMetadataOperand
  (M: ModuleRef; Name: TEXT; Val: ValueRef; );


(**
 * Return the directory of the debug location for this value, which must be
 * an llvm::Instruction, llvm::GlobalVariable, or llvm::Function.
 *
 * @see llvm::Instruction::getDebugLoc()
 * @see llvm::GlobalVariable::getDebugInfo()
 * @see llvm::Function::getSubprogram()
 *)

PROCEDURE GetDebugLocDirectory (Val: ValueRef; VAR Length: uint32_t; ):
  TEXT;


(**
 * Return the filename of the debug location for this value, which must be
 * an llvm::Instruction, llvm::GlobalVariable, or llvm::Function.
 *
 * @see llvm::Instruction::getDebugLoc()
 * @see llvm::GlobalVariable::getDebugInfo()
 * @see llvm::Function::getSubprogram()
 *)

PROCEDURE GetDebugLocFilename (Val: ValueRef; VAR Length: uint32_t; ):
  TEXT;


(**
 * Return the line number of the debug location for this value, which must be
 * an llvm::Instruction, llvm::GlobalVariable, or llvm::Function.
 *
 * @see llvm::Instruction::getDebugLoc()
 * @see llvm::GlobalVariable::getDebugInfo()
 * @see llvm::Function::getSubprogram()
 *)

PROCEDURE GetDebugLocLine (Val: ValueRef; ): uint32_t;


(**
 * Return the column number of the debug location for this value, which must be
 * an llvm::Instruction.
 *
 * @see llvm::Instruction::getDebugLoc()
 *)

PROCEDURE GetDebugLocColumn (Val: ValueRef; ): uint32_t;


(**
 * Add a function to a module under a specified name.
 *
 * @see llvm::Function::Create()
 *)

PROCEDURE AddFunction (M: ModuleRef; Name: TEXT; FunctionTy: TypeRef; ):
  ValueRef;


(**
 * Obtain or insert a function into a module.
 *
 * If a function with the specified name already exists in the module, it
 * is returned. Otherwise, a new function is created in the module with the
 * specified name and type and is returned.
 *
 * The returned value corresponds to a llvm::Function instance.
 *
 * @see llvm::Module::getOrInsertFunction()
 *)

PROCEDURE GetOrInsertFunction
  (M: ModuleRef; Name: TEXT; NameLen: Word.T; FunctionTy: TypeRef; ):
  ValueRef;


(**
 * Obtain a Function value from a Module by its name.
 *
 * The returned value corresponds to a llvm::Function value.
 *
 * @see llvm::Module::getFunction()
 *)

PROCEDURE GetNamedFunction (M: ModuleRef; Name: TEXT; ): ValueRef;


(**
 * Obtain a Function value from a Module by its name.
 *
 * The returned value corresponds to a llvm::Function value.
 *
 * @see llvm::Module::getFunction()
 *)

PROCEDURE GetNamedFunctionWithLength
  (M: ModuleRef; Name: TEXT; Length: Word.T; ): ValueRef;


(**
 * Obtain an iterator to the first Function in a Module.
 *
 * @see llvm::Module::begin()
 *)

PROCEDURE GetFirstFunction (M: ModuleRef; ): ValueRef;


(**
 * Obtain an iterator to the last Function in a Module.
 *
 * @see llvm::Module::end()
 *)

PROCEDURE GetLastFunction (M: ModuleRef; ): ValueRef;


(**
 * Advance a Function iterator to the next Function.
 *
 * Returns NULL if the iterator was already at the end and there are no more
 * functions.
 *)

PROCEDURE GetNextFunction (Fn: ValueRef; ): ValueRef;


(**
 * Decrement a Function iterator to the previous Function.
 *
 * Returns NULL if the iterator was already at the beginning and there are
 * no previous functions.
 *)

PROCEDURE GetPreviousFunction (Fn: ValueRef; ): ValueRef;


(** Deprecated: Use LLVMSetModuleInlineAsm2 instead. *)

PROCEDURE SetModuleInlineAsm (M: ModuleRef; Asm: TEXT; );


(**
 * @}
 *
 * Obtain the enumerated type of a Type instance.
 *
 * @see llvm::Type:getTypeID()
 *)

PROCEDURE GetTypeKind (Ty: TypeRef; ): TypeKindRef;


(**
 * Whether the type has a known size.
 *
 * Things that don't have a size are abstract types, labels, and void.a
 *
 * @see llvm::Type::isSized()
 *)

PROCEDURE TypeIsSized (Ty: TypeRef; ): BOOLEAN;


(**
 * Obtain the context to which this type instance is associated.
 *
 * @see llvm::Type::getContext()
 *)

PROCEDURE GetTypeContext (Ty: TypeRef; ): ContextRef;


(**
 * Dump a representation of a type to stderr.
 *
 * @see llvm::Type::dump()
 *)

PROCEDURE DumpType (Val: TypeRef; );


(**
 * Return a string representation of the type. Use
 * LLVMDisposeMessage to free the string.
 *
 * @see llvm::Type::print()
 *)

PROCEDURE PrintTypeToString (Val: TypeRef; ): TEXT;


(**
 * Obtain an integer type from a context with specified bit width.
 *)

PROCEDURE Int1TypeInContext (context: ContextRef; ): TypeRef;

PROCEDURE Int8TypeInContext (context: ContextRef; ): TypeRef;

PROCEDURE Int16TypeInContext (context: ContextRef; ): TypeRef;

PROCEDURE Int32TypeInContext (context: ContextRef; ): TypeRef;

PROCEDURE Int64TypeInContext (context: ContextRef; ): TypeRef;

PROCEDURE Int128TypeInContext (context: ContextRef; ): TypeRef;

PROCEDURE IntTypeInContext (context: ContextRef; NumBits: uint32_t; ):
  TypeRef;


(**
 * Obtain an integer type from the global context with a specified bit
 * width.
 *)

PROCEDURE Int1Type (): TypeRef;

PROCEDURE Int8Type (): TypeRef;

PROCEDURE Int16Type (): TypeRef;

PROCEDURE Int32Type (): TypeRef;

PROCEDURE Int64Type (): TypeRef;

PROCEDURE Int128Type (): TypeRef;

PROCEDURE IntType (NumBits: uint32_t; ): TypeRef;

PROCEDURE GetIntTypeWidth (IntegerTy: TypeRef; ): uint32_t;


(**
 * @}
 *
 * Obtain a 16-bit floating point type from a context.
 *)

PROCEDURE HalfTypeInContext (context: ContextRef; ): TypeRef;


(**
 * Obtain a 16-bit brain floating point type from a context.
 *)

PROCEDURE BFloatTypeInContext (context: ContextRef; ): TypeRef;


(**
 * Obtain a 32-bit floating point type from a context.
 *)

PROCEDURE FloatTypeInContext (context: ContextRef; ): TypeRef;


(**
 * Obtain a 64-bit floating point type from a context.
 *)

PROCEDURE DoubleTypeInContext (context: ContextRef; ): TypeRef;


(**
 * Obtain a 80-bit floating point type (X87) from a context.
 *)

PROCEDURE X86FP80TypeInContext (context: ContextRef; ): TypeRef;


(**
 * Obtain a 128-bit floating point type (112-bit mantissa) from a
 * context.
 *)

PROCEDURE FP128TypeInContext (context: ContextRef; ): TypeRef;


(**
 * Obtain a 128-bit floating point type (two 64-bits) from a context.
 *)

PROCEDURE PPCFP128TypeInContext (context: ContextRef; ): TypeRef;


(**
 * Obtain a floating point type from the global context.
 *
 * These map to the functions in this group of the same name.
 *)

PROCEDURE HalfType (): TypeRef;

PROCEDURE BFloatType (): TypeRef;

PROCEDURE FloatType (): TypeRef;

PROCEDURE DoubleType (): TypeRef;

PROCEDURE X86FP80Type (): TypeRef;

PROCEDURE FP128Type (): TypeRef;

PROCEDURE PPCFP128Type (): TypeRef;


(**
 * @}
 *
 * Obtain a function type consisting of a specified signature.
 *
 * The function is defined as a tuple of a return Type, a list of
 * parameter types, and whether the function is variadic.
 *)

PROCEDURE FunctionType (ReturnType: TypeRef;
                        ParamTypes: UNTRACED REF TypeRef;
                        ParamCount: uint32_t;
                        IsVarArg  : BOOLEAN;              ): TypeRef;


(**
 * Returns whether a function type is variadic.
 *)

PROCEDURE IsFunctionVarArg (FunctionTy: TypeRef; ): BOOLEAN;


(**
 * Obtain the Type this function Type returns.
 *)

PROCEDURE GetReturnType (FunctionTy: TypeRef; ): TypeRef;


(**
 * Obtain the number of parameters this function accepts.
 *)

PROCEDURE CountParamTypes (FunctionTy: TypeRef; ): uint32_t;


(**
 * Obtain the types of a function's parameters.
 *
 * The Dest parameter should point to a pre-allocated array of
 * LLVMTypeRef at least LLVMCountParamTypes() large. On return, the
 * first LLVMCountParamTypes() entries in the array will be populated
 * with LLVMTypeRef instances.
 *
 * @param FunctionTy The function type to operate on.
 * @param Dest Memory address of an array to be filled with result.
 *)

PROCEDURE GetParamTypes
  (FunctionTy: TypeRef; Dest: UNTRACED REF TypeRef; );


(**
 * @}
 *
 * Create a new structure type in a context.
 *
 * A structure is specified by a list of inner elements/types and
 * whether these can be packed together.
 *
 * @see llvm::StructType::create()
 *)

PROCEDURE StructTypeInContext (context     : ContextRef;
                               ElementTypes: UNTRACED REF TypeRef;
                               ElementCount: uint32_t;
                               Packed      : BOOLEAN;              ):
  TypeRef;


(**
 * Create a new structure type in the global context.
 *
 * @see llvm::StructType::create()
 *)

PROCEDURE StructType (ElementTypes: UNTRACED REF TypeRef;
                      ElementCount: uint32_t;
                      Packed      : BOOLEAN;              ): TypeRef;


(**
 * Create an empty structure in a context having a specified name.
 *
 * @see llvm::StructType::create()
 *)

PROCEDURE StructCreateNamed (context: ContextRef; Name: TEXT; ): TypeRef;


(**
 * Obtain the name of a structure.
 *
 * @see llvm::StructType::getName()
 *)

PROCEDURE GetStructName (Ty: TypeRef; ): TEXT;


(**
 * Set the contents of a structure type.
 *
 * @see llvm::StructType::setBody()
 *)

PROCEDURE StructSetBody (StructTy    : TypeRef;
                         ElementTypes: UNTRACED REF TypeRef;
                         ElementCount: uint32_t;
                         Packed      : BOOLEAN;              );


(**
 * Get the number of elements defined inside the structure.
 *
 * @see llvm::StructType::getNumElements()
 *)

PROCEDURE CountStructElementTypes (StructTy: TypeRef; ): uint32_t;


(**
 * Get the elements within a structure.
 *
 * The function is passed the address of a pre-allocated array of
 * LLVMTypeRef at least LLVMCountStructElementTypes() long. After
 * invocation, this array will be populated with the structure's
 * elements. The objects in the destination array will have a lifetime
 * of the structure type itself, which is the lifetime of the context it
 * is contained in.
 *)

PROCEDURE GetStructElementTypes
  (StructTy: TypeRef; Dest: UNTRACED REF TypeRef; );


(**
 * Get the type of the element at a given index in the structure.
 *
 * @see llvm::StructType::getTypeAtIndex()
 *)

PROCEDURE StructGetTypeAtIndex (StructTy: TypeRef; i: uint32_t; ): TypeRef;


(**
 * Determine whether a structure is packed.
 *
 * @see llvm::StructType::isPacked()
 *)

PROCEDURE IsPackedStruct (StructTy: TypeRef; ): BOOLEAN;


(**
 * Determine whether a structure is opaque.
 *
 * @see llvm::StructType::isOpaque()
 *)

PROCEDURE IsOpaqueStruct (StructTy: TypeRef; ): BOOLEAN;


(**
 * Determine whether a structure is literal.
 *
 * @see llvm::StructType::isLiteral()
 *)

PROCEDURE IsLiteralStruct (StructTy: TypeRef; ): BOOLEAN;


(**
 * @}
 *
 * Obtain the element type of an array or vector type.
 *
 * @see llvm::SequentialType::getElementType()
 *)

PROCEDURE GetElementType (Ty: TypeRef; ): TypeRef;


(**
 * Returns type's subtypes
 *
 * @see llvm::Type::subtypes()
 *)

PROCEDURE GetSubtypes (Tp: TypeRef; Arr: UNTRACED REF TypeRef; );


(**
 *  Return the number of types in the derived type.
 *
 * @see llvm::Type::getNumContainedTypes()
 *)

PROCEDURE GetNumContainedTypes (Tp: TypeRef; ): uint32_t;


(**
 * Create a fixed size array type that refers to a specific type.
 *
 * The created type will exist in the context that its element type
 * exists in.
 *
 * @deprecated LLVMArrayType is deprecated in favor of the API accurate
 * LLVMArrayType2
 * @see llvm::ArrayType::get()
 *)

PROCEDURE ArrayType (ElementType: TypeRef; ElementCount: uint32_t; ):
  TypeRef;


(**
 * Create a fixed size array type that refers to a specific type.
 *
 * The created type will exist in the context that its element type
 * exists in.
 *
 * @see llvm::ArrayType::get()
 *)

PROCEDURE ArrayType2 (ElementType: TypeRef; ElementCount: uint64_t; ):
  TypeRef;


(**
 * Obtain the length of an array type.
 *
 * This only works on types that represent arrays.
 *
 * @deprecated LLVMGetArrayLength is deprecated in favor of the API accurate
 * LLVMGetArrayLength2
 * @see llvm::ArrayType::getNumElements()
 *)

PROCEDURE GetArrayLength (ArrayTy: TypeRef; ): uint32_t;


(**
 * Obtain the length of an array type.
 *
 * This only works on types that represent arrays.
 *
 * @see llvm::ArrayType::getNumElements()
 *)

PROCEDURE GetArrayLength2 (ArrayTy: TypeRef; ): uint64_t;


(**
 * Create a pointer type that points to a defined type.
 *
 * The created type will exist in the context that its pointee type
 * exists in.
 *
 * @see llvm::PointerType::get()
 *)

PROCEDURE PointerType
  (ElementType: TypeRef; AddressSpace: uint32_t := 0; ): TypeRef;


(**
 * Determine whether a pointer is opaque.
 *
 * True if this is an instance of an opaque PointerType.
 *
 * @see llvm::Type::isOpaquePointerTy()
 *)

PROCEDURE PointerTypeIsOpaque (Ty: TypeRef; ): BOOLEAN;


(**
 * Create an opaque pointer type in a context.
 *
 * @see llvm::PointerType::get()
 *)

PROCEDURE PointerTypeInContext
  (context: ContextRef; AddressSpace: uint32_t := 0; ): TypeRef;


(**
 * Obtain the address space of a pointer type.
 *
 * This only works on types that represent pointers.
 *
 * @see llvm::PointerType::getAddressSpace()
 *)

PROCEDURE GetPointerAddressSpace (PointerTy: TypeRef; ): uint32_t;


(**
 * Create a vector type that contains a defined type and has a specific
 * number of elements.
 *
 * The created type will exist in the context thats its element type
 * exists in.
 *
 * @see llvm::VectorType::get()
 *)

PROCEDURE VectorType (ElementType: TypeRef; ElementCount: uint32_t; ):
  TypeRef;


(**
 * Create a vector type that contains a defined type and has a scalable
 * number of elements.
 *
 * The created type will exist in the context thats its element type
 * exists in.
 *
 * @see llvm::ScalableVectorType::get()
 *)

PROCEDURE ScalableVectorType
  (ElementType: TypeRef; ElementCount: uint32_t; ): TypeRef;


(**
 * Obtain the (possibly scalable) number of elements in a vector type.
 *
 * This only works on types that represent vectors (fixed or scalable).
 *
 * @see llvm::VectorType::getNumElements()
 *)

PROCEDURE GetVectorSize (VectorTy: TypeRef; ): uint32_t;


(**
 * Get the pointer value for the associated ConstantPtrAuth constant.
 *
 * @see llvm::ConstantPtrAuth::getPointer
 *)

PROCEDURE GetConstantPtrAuthPointer (PtrAuth: ValueRef; ): ValueRef;


(**
 * Get the key value for the associated ConstantPtrAuth constant.
 *
 * @see llvm::ConstantPtrAuth::getKey
 *)

PROCEDURE GetConstantPtrAuthKey (PtrAuth: ValueRef; ): ValueRef;


(**
 * Get the discriminator value for the associated ConstantPtrAuth constant.
 *
 * @see llvm::ConstantPtrAuth::getDiscriminator
 *)

PROCEDURE GetConstantPtrAuthDiscriminator (PtrAuth: ValueRef; ): ValueRef;


(**
 * Get the address discriminator value for the associated ConstantPtrAuth
 * constant.
 *
 * @see llvm::ConstantPtrAuth::getAddrDiscriminator
 *)

PROCEDURE GetConstantPtrAuthAddrDiscriminator (PtrAuth: ValueRef; ):
  ValueRef;


(**
 * @}
 *
 * Create a void type in a context.
 *)

PROCEDURE VoidTypeInContext (context: ContextRef; ): TypeRef;


(**
 * Create a label type in a context.
 *)

PROCEDURE LabelTypeInContext (context: ContextRef; ): TypeRef;


(**
 * Create a X86 AMX type in a context.
 *)

PROCEDURE X86AMXTypeInContext (context: ContextRef; ): TypeRef;


(**
 * Create a token type in a context.
 *)

PROCEDURE TokenTypeInContext (context: ContextRef; ): TypeRef;


(**
 * Create a metadata type in a context.
 *)

PROCEDURE MetadataTypeInContext (context: ContextRef; ): TypeRef;


(**
 * These are similar to the above functions except they operate on the
 * global context.
 *)

PROCEDURE VoidType (): TypeRef;

PROCEDURE LabelType (): TypeRef;

PROCEDURE X86AMXType (): TypeRef;


(**
 * Create a target extension type in LLVM context.
 *)

PROCEDURE TargetExtTypeInContext (context       : ContextRef;
                                  Name          : TEXT;
                                  TypeParams    : UNTRACED REF TypeRef;
                                  TypeParamCount: uint32_t;
                                  VAR IntParams    : uint32_t;
                                      IntParamCount: uint32_t; ): TypeRef;


(**
 * Obtain the name for this target extension type.
 *
 * @see llvm::TargetExtType::getName()
 *)

PROCEDURE GetTargetExtTypeName (TargetExtTy: TypeRef; ): TEXT;


(**
 * Obtain the number of type parameters for this target extension type.
 *
 * @see llvm::TargetExtType::getNumTypeParameters()
 *)

PROCEDURE GetTargetExtTypeNumTypeParams (TargetExtTy: TypeRef; ): uint32_t;


(**
 * Get the type parameter at the given index for the target extension type.
 *
 * @see llvm::TargetExtType::getTypeParameter()
 *)

PROCEDURE GetTargetExtTypeTypeParam
  (TargetExtTy: TypeRef; Idx: uint32_t; ): TypeRef;


(**
 * Obtain the number of int parameters for this target extension type.
 *
 * @see llvm::TargetExtType::getNumIntParameters()
 *)

PROCEDURE GetTargetExtTypeNumIntParams (TargetExtTy: TypeRef; ): uint32_t;


(**
 * Get the int parameter at the given index for the target extension type.
 *
 * @see llvm::TargetExtType::getIntParameter()
 *)

PROCEDURE GetTargetExtTypeIntParam (TargetExtTy: TypeRef; Idx: uint32_t; ):
  uint32_t;


(**
 * @}
 *
 * @}
 *
 * Obtain the type of a value.
 *
 * @see llvm::Value::getType()
 *)

PROCEDURE TypeOf (Val: ValueRef; ): TypeRef;


(**
 * Obtain the enumerated type of a Value instance.
 *
 * @see llvm::Value::getValueID()
 *)

PROCEDURE GetValueKind (Val: ValueRef; ): LLVMValueKind;


(**
 * Obtain the string name of a value.
 *
 * @see llvm::Value::getName()
 *)

PROCEDURE GetValueName2 (Val: ValueRef; VAR Length: Word.T; ): TEXT;


(**
 * Set the string name of a value.
 *
 * @see llvm::Value::setName()
 *)

PROCEDURE SetValueName2 (Val: ValueRef; Name: TEXT; NameLen: Word.T; );


(**
 * Dump a representation of a value to stderr.
 *
 * @see llvm::Value::dump()
 *)

PROCEDURE DumpValue (Val: ValueRef; );


(**
 * Return a string representation of the value. Use
 * LLVMDisposeMessage to free the string.
 *
 * @see llvm::Value::print()
 *)

PROCEDURE PrintValueToString (Val: ValueRef; ): TEXT;


(**
 * Obtain the context to which this value is associated.
 *
 * @see llvm::Value::getContext()
 *)

PROCEDURE GetValueContext (Val: ValueRef; ): ContextRef;


(**
 * Return a string representation of the DbgRecord. Use
 * LLVMDisposeMessage to free the string.
 *
 * @see llvm::DbgRecord::print()
 *)

PROCEDURE PrintDbgRecordToString (Record: DbgRecordRef; ): TEXT;


(**
 * Replace all uses of a value with another one.
 *
 * @see llvm::Value::replaceAllUsesWith()
 *)

PROCEDURE ReplaceAllUsesWith (OldVal, NewVal: ValueRef; );


(**
 * Determine whether the specified value instance is constant.
 *)

PROCEDURE IsConstant (Val: ValueRef; ): BOOLEAN;


(**
 * Determine whether a value instance is undefined.
 *)

PROCEDURE IsUndef (Val: ValueRef; ): BOOLEAN;


(**
 * Determine whether a value instance is poisonous.
 *)

PROCEDURE IsPoison (Val: ValueRef; ): BOOLEAN;


(**
 * Convert value instances between types.
 *
 * Internally, an LLVMValueRef is "pinned" to a specific type. This
 * series of functions allows you to cast an instance to a specific
 * type.
 *
 * If the cast is not valid for the specified type, NULL is returned.
 *
 * @see llvm::dyn_cast_or_null<>
 *)

PROCEDURE IsAArgument (Val: ValueRef; ): ValueRef;

PROCEDURE IsABasicBlock (Val: ValueRef; ): ValueRef;

PROCEDURE IsAInlineAsm (Val: ValueRef; ): ValueRef;

PROCEDURE IsAUser (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstant (Val: ValueRef; ): ValueRef;

PROCEDURE IsABlockAddress (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstantAggregateZero (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstantArray (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstantDataSequential (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstantDataArray (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstantDataVector (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstantExpr (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstantFP (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstantInt (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstantPointerNull (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstantStruct (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstantTokenNone (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstantVector (Val: ValueRef; ): ValueRef;

PROCEDURE IsAConstantPtrAuth (Val: ValueRef; ): ValueRef;

PROCEDURE IsAGlobalValue (Val: ValueRef; ): ValueRef;

PROCEDURE IsAGlobalAlias (Val: ValueRef; ): ValueRef;

PROCEDURE IsAGlobalObject (Val: ValueRef; ): ValueRef;

PROCEDURE IsAFunction (Val: ValueRef; ): ValueRef;

PROCEDURE IsAGlobalVariable (Val: ValueRef; ): ValueRef;

PROCEDURE IsAGlobalIFunc (Val: ValueRef; ): ValueRef;

PROCEDURE IsAUndefValue (Val: ValueRef; ): ValueRef;

PROCEDURE IsAPoisonValue (Val: ValueRef; ): ValueRef;

PROCEDURE IsAInstruction (Val: ValueRef; ): ValueRef;

PROCEDURE IsAUnaryOperator (Val: ValueRef; ): ValueRef;

PROCEDURE IsABinaryOperator (Val: ValueRef; ): ValueRef;

PROCEDURE IsACallInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAIntrinsicInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsADbgInfoIntrinsic (Val: ValueRef; ): ValueRef;

PROCEDURE IsADbgVariableIntrinsic (Val: ValueRef; ): ValueRef;

PROCEDURE IsADbgDeclareInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsADbgLabelInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAMemIntrinsic (Val: ValueRef; ): ValueRef;

PROCEDURE IsAMemCpyInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAMemMoveInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAMemSetInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsACmpInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAFCmpInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAICmpInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAExtractElementInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAGetElementPtrInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAInsertElementInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAInsertValueInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsALandingPadInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAPHINode (Val: ValueRef; ): ValueRef;

PROCEDURE IsASelectInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAShuffleVectorInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAStoreInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsABranchInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAIndirectBrInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAInvokeInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAReturnInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsASwitchInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAUnreachableInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAResumeInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsACleanupReturnInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsACatchReturnInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsACatchSwitchInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsACallBrInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAFuncletPadInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsACatchPadInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsACleanupPadInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAUnaryInstruction (Val: ValueRef; ): ValueRef;

PROCEDURE IsAAllocaInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsACastInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAAddrSpaceCastInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsABitCastInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAFPExtInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAFPToSIInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAFPToUIInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAFPTruncInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAIntToPtrInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAPtrToIntInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsASExtInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsASIToFPInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsATruncInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAUIToFPInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAZExtInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAExtractValueInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsALoadInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAVAArgInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAFreezeInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAAtomicCmpXchgInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAAtomicRMWInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAFenceInst (Val: ValueRef; ): ValueRef;

PROCEDURE IsAMDNode (Val: ValueRef; ): ValueRef;

PROCEDURE IsAValueAsMetadata (Val: ValueRef; ): ValueRef;

PROCEDURE IsAMDString (Val: ValueRef; ): ValueRef;


(** Deprecated: Use LLVMGetValueName2 instead. *)

PROCEDURE GetValueName (Val: ValueRef; ): TEXT;


(** Deprecated: Use LLVMSetValueName2 instead. *)

PROCEDURE SetValueName (Val: ValueRef; Name: TEXT; );


(**
 * @}
 *
 * Obtain the first use of a value.
 *
 * Uses are obtained in an iterator fashion. First, call this function
 * to obtain a reference to the first use. Then, call LLVMGetNextUse()
 * on that instance and all subsequently obtained instances until
 * LLVMGetNextUse() returns NULL.
 *
 * @see llvm::Value::use_begin()
 *)

PROCEDURE GetFirstUse (Val: ValueRef; ): UseRef;


(**
 * Obtain the next use of a value.
 *
 * This effectively advances the iterator. It returns NULL if you are on
 * the final use and no more are available.
 *)

PROCEDURE GetNextUse (U: UseRef; ): UseRef;


(**
 * Obtain the user value for a user.
 *
 * The returned value corresponds to a llvm::User type.
 *
 * @see llvm::Use::getUser()
 *)

PROCEDURE GetUser (U: UseRef; ): ValueRef;


(**
 * Obtain the value this use corresponds to.
 *
 * @see llvm::Use::get().
 *)

PROCEDURE GetUsedValue (U: UseRef; ): ValueRef;


(**
 * @}
 *
 * Obtain an operand at a specific index in a llvm::User value.
 *
 * @see llvm::User::getOperand()
 *)

PROCEDURE GetOperand (Val: ValueRef; Index: uint32_t; ): ValueRef;


(**
 * Obtain the use of an operand at a specific index in a llvm::User value.
 *
 * @see llvm::User::getOperandUse()
 *)

PROCEDURE GetOperandUse (Val: ValueRef; Index: uint32_t; ): UseRef;


(**
 * Set an operand at a specific index in a llvm::User value.
 *
 * @see llvm::User::setOperand()
 *)

PROCEDURE SetOperand (User: ValueRef; Index: uint32_t; Val: ValueRef; );


(**
 * Obtain the number of operands in a llvm::User value.
 *
 * @see llvm::User::getNumOperands()
 *)

PROCEDURE GetNumOperands (Val: ValueRef; ): INTEGER;


(**
 * @}
 *
 * Obtain a constant value referring to the null instance of a type.
 *
 * @see llvm::Constant::getNullValue()
 *)

PROCEDURE ConstNull (Ty: TypeRef; ): ValueRef;


(**
 * Obtain a constant value referring to the instance of a type
 * consisting of all ones.
 *
 * This is only valid for integer types.
 *
 * @see llvm::Constant::getAllOnesValue()
 *)

PROCEDURE ConstAllOnes (Ty: TypeRef; ): ValueRef;


(**
 * Obtain a constant value referring to an undefined value of a type.
 *
 * @see llvm::UndefValue::get()
 *)

PROCEDURE GetUndef (Ty: TypeRef; ): ValueRef;


(**
 * Obtain a constant value referring to a poison value of a type.
 *
 * @see llvm::PoisonValue::get()
 *)

PROCEDURE GetPoison (Ty: TypeRef; ): ValueRef;


(**
 * Determine whether a value instance is null.
 *
 * @see llvm::Constant::isNullValue()
 *)

PROCEDURE IsNull (Val: ValueRef; ): BOOLEAN;


(**
 * Obtain a constant that is a constant pointer pointing to NULL for a
 * specified type.
 *)

PROCEDURE ConstPointerNull (Ty: TypeRef; ): ValueRef;


(**
 * Obtain a constant value for an integer type.
 *
 * The returned value corresponds to a llvm::ConstantInt.
 *
 * @see llvm::ConstantInt::get()
 *
 * @param IntTy Integer type to obtain value of.
 * @param N The value the returned instance should refer to.
 * @param SignExtend Whether to sign extend the produced value.
 *)

PROCEDURE ConstInt (IntTy: TypeRef; N: uint64_t; SignExtend: BOOLEAN; ):
  ValueRef;


(**
 * Obtain a constant value for an integer of arbitrary precision.
 *
 * @see llvm::ConstantInt::get()
 *)

PROCEDURE ConstIntOfArbitraryPrecision
  (IntTy: TypeRef; NumWords: uint32_t; Words: REF ARRAY OF uint64_t; ):
  ValueRef;


(**
 * Obtain a constant value for an integer parsed from a string.
 *
 * A similar API, LLVMConstIntOfStringAndSize is also available. If the
 * string's length is available, it is preferred to call that function
 * instead.
 *
 * @see llvm::ConstantInt::get()
 *)

PROCEDURE ConstIntOfString (IntTy: TypeRef; Text: TEXT; Radix: uint8_t; ):
  ValueRef;


(**
 * Obtain a constant value for an integer parsed from a string with
 * specified length.
 *
 * @see llvm::ConstantInt::get()
 *)

PROCEDURE ConstIntOfStringAndSize
  (IntTy: TypeRef; Text: TEXT; SLen: uint32_t; Radix: uint8_t; ): ValueRef;


(**
 * Obtain a constant value referring to a double floating point value.
 *)

PROCEDURE ConstReal (RealTy: TypeRef; N: LONGREAL; ): ValueRef;


(**
 * Obtain a constant for a floating point value parsed from a string.
 *
 * A similar API, LLVMConstRealOfStringAndSize is also available. It
 * should be used if the input string's length is known.
 *)

PROCEDURE ConstRealOfString (RealTy: TypeRef; Text: TEXT; ): ValueRef;


(**
 * Obtain a constant for a floating point value parsed from a string.
 *)

PROCEDURE ConstRealOfStringAndSize
  (RealTy: TypeRef; Text: TEXT; SLen: uint32_t; ): ValueRef;


(**
 * Obtain a constant for a floating point value from array of 64 bit values.
 * The length of the array N must be ceildiv(bits, 64), where bits is the
 * scalar size in bits of the floating-point type.
 *)

PROCEDURE ConstFPFromBits (Ty: TypeRef; N: QuadRef; ): ValueRef;


(**
 * Obtain the zero extended value for an integer constant value.
 *
 * @see llvm::ConstantInt::getZExtValue()
 *)

PROCEDURE ConstIntGetZExtValue (ConstantVal: ValueRef; ): uint64_t;


(**
 * Obtain the sign extended value for an integer constant value.
 *
 * @see llvm::ConstantInt::getSExtValue()
 *)

PROCEDURE ConstIntGetSExtValue (ConstantVal: ValueRef; ): int64_t;


(**
 * Obtain the double value for an floating point constant value.
 * losesInfo indicates if some precision was lost in the conversion.
 *
 * @see llvm::ConstantFP::getDoubleValue
 *)

PROCEDURE ConstRealGetDouble
  (ConstantVal: ValueRef; VAR losesInfo: BOOLEAN; ): LONGREAL;


(**
 * @}
 *
 * Create a ConstantDataSequential and initialize it with a string.
 *
 * @deprecated LLVMConstStringInContext is deprecated in favor of the API
 * accurate LLVMConstStringInContext2
 * @see llvm::ConstantDataArray::getString()
 *)

PROCEDURE ConstStringInContext (context          : ContextRef;
                                Str              : TEXT;
                                Length           : uint32_t;
                                DontNullTerminate: BOOLEAN;    ): ValueRef;


(**
 * Create a ConstantDataSequential and initialize it with a string.
 *
 * @see llvm::ConstantDataArray::getString()
 *)

PROCEDURE ConstStringInContext2 (context          : ContextRef;
                                 Str              : TEXT;
                                 Length           : Word.T;
                                 DontNullTerminate: BOOLEAN;    ):
  ValueRef;


(**
 * Create a ConstantDataSequential with string content in the global context.
 *
 * This is the same as LLVMConstStringInContext except it operates on the
 * global context.
 *
 * @see LLVMConstStringInContext()
 * @see llvm::ConstantDataArray::getString()
 *)

PROCEDURE ConstString
  (Str: TEXT; Length: uint32_t; DontNullTerminate: BOOLEAN; ): ValueRef;


(**
 * Returns true if the specified constant is an array of i8.
 *
 * @see ConstantDataSequential::getAsString()
 *)

PROCEDURE IsConstantString (c: ValueRef; ): BOOLEAN;


(**
 * Get the given constant data sequential as a string.
 *
 * @see ConstantDataSequential::getAsString()
 *)

PROCEDURE GetAsString (c: ValueRef; VAR Length: Word.T; ): TEXT;


(**
 * Get the raw, underlying bytes of the given constant data sequential.
 *
 * This is the same as LLVMGetAsString except it works for all constant data
 * sequentials, not just i8 arrays.
 *
 * @see ConstantDataSequential::getRawDataValues()
 *)

PROCEDURE GetRawDataValues (c: ValueRef; VAR SizeInBytes: Word.T; ): TEXT;


(**
 * Create an anonymous ConstantStruct with the specified values.
 *
 * @see llvm::ConstantStruct::getAnon()
 *)

PROCEDURE ConstStructInContext (context     : ContextRef;
                                ConstantVals: UNTRACED REF ValueRef;
                                Count       : uint32_t;
                                Packed      : BOOLEAN;               ):
  ValueRef;


(**
 * Create a ConstantStruct in the global Context.
 *
 * This is the same as LLVMConstStructInContext except it operates on the
 * global Context.
 *
 * @see LLVMConstStructInContext()
 *)

PROCEDURE ConstStruct (ConstantVals: UNTRACED REF ValueRef;
                       Count       : uint32_t;
                       Packed      : BOOLEAN;               ): ValueRef;


(**
 * Create a ConstantArray from values.
 *
 * @deprecated LLVMConstArray is deprecated in favor of the API accurate
 * LLVMConstArray2
 * @see llvm::ConstantArray::get()
 *)

PROCEDURE ConstArray (ElementTy   : TypeRef;
                      ConstantVals: UNTRACED REF ValueRef;
                      Length      : uint32_t;              ): ValueRef;


(**
 * Create a ConstantArray from values.
 *
 * @see llvm::ConstantArray::get()
 *)

PROCEDURE ConstArray2 (ElementTy   : TypeRef;
                       ConstantVals: UNTRACED REF ValueRef;
                       Length      : uint64_t;              ): ValueRef;


(**
 * Create a ConstantDataArray from raw values.
 *
 * ElementTy must be one of i8, i16, i32, i64, half, bfloat, float, or double.
 * Data points to a contiguous buffer of raw values in the host endianness. The
 * element count is inferred from the element type and the data size in bytes.
 *
 * @see llvm::ConstantDataArray::getRaw()
 *)

PROCEDURE ConstDataArray
  (ElementTy: TypeRef; Data: TEXT; SizeInBytes: Word.T; ): ValueRef;


(**
 * Create a non-anonymous ConstantStruct from values.
 *
 * @see llvm::ConstantStruct::get()
 *)

PROCEDURE ConstNamedStruct (StructTy    : TypeRef;
                            ConstantVals: UNTRACED REF ValueRef;
                            Count       : uint32_t;              ):
  ValueRef;


(**
 * Get element of a constant aggregate (struct, array or vector) at the
 * specified index. Returns null if the index is out of range, or it's not
 * possible to determine the element (e.g., because the constant is a
 * constant expression.)
 *
 * @see llvm::Constant::getAggregateElement()
 *)

PROCEDURE GetAggregateElement (context: ValueRef; Idx: uint32_t; ):
  ValueRef;


(**
 * Create a ConstantVector from values.
 *
 * @see llvm::ConstantVector::get()
 *)

PROCEDURE ConstVector
  (ScalarConstantVals: UNTRACED REF ValueRef; Size: uint32_t; ): ValueRef;


(**
 * Create a ConstantPtrAuth constant with the given values.
 *
 * @see llvm::ConstantPtrAuth::get()
 *)

PROCEDURE ConstantPtrAuth (Ptr, Key, Disc, AddrDisc: ValueRef; ): ValueRef;


(**
 * @}
 *)

PROCEDURE GetConstOpcode (ConstantVal: ValueRef; ): LLVMOpcode;

PROCEDURE AlignOf (Ty: TypeRef; ): ValueRef;

PROCEDURE SizeOf (Ty: TypeRef; ): ValueRef;

PROCEDURE ConstNeg (ConstantVal: ValueRef; ): ValueRef;

PROCEDURE ConstNSWNeg (ConstantVal: ValueRef; ): ValueRef;

PROCEDURE ConstNot (ConstantVal: ValueRef; ): ValueRef;

PROCEDURE ConstAdd (LHSConstant, RHSConstant: ValueRef; ): ValueRef;

PROCEDURE ConstNSWAdd (LHSConstant, RHSConstant: ValueRef; ): ValueRef;

PROCEDURE ConstNUWAdd (LHSConstant, RHSConstant: ValueRef; ): ValueRef;

PROCEDURE ConstSub (LHSConstant, RHSConstant: ValueRef; ): ValueRef;

PROCEDURE ConstNSWSub (LHSConstant, RHSConstant: ValueRef; ): ValueRef;

PROCEDURE ConstNUWSub (LHSConstant, RHSConstant: ValueRef; ): ValueRef;

PROCEDURE ConstXor (LHSConstant, RHSConstant: ValueRef; ): ValueRef;

PROCEDURE ConstGEP2 (Ty             : TypeRef;
                     ConstantVal    : ValueRef;
                     ConstantIndices: UNTRACED REF ValueRef;
                     NumIndices     : uint32_t;              ): ValueRef;

PROCEDURE ConstInBoundsGEP2 (Ty             : TypeRef;
                             ConstantVal    : ValueRef;
                             ConstantIndices: UNTRACED REF ValueRef;
                             NumIndices     : uint32_t;              ):
  ValueRef;


(**
 * Creates a constant GetElementPtr expression. Similar to LLVMConstGEP2, but
 * allows specifying the no-wrap flags.
 *
 * @see llvm::ConstantExpr::getGetElementPtr()
 *)

PROCEDURE ConstGEPWithNoWrapFlags (Ty             : TypeRef;
                                   ConstantVal    : ValueRef;
                                   ConstantIndices: UNTRACED REF ValueRef;
                                   NumIndices, NoWrapFlags: uint32_t; ):
  ValueRef;

PROCEDURE ConstTrunc (ConstantVal: ValueRef; ToType: TypeRef; ): ValueRef;

PROCEDURE ConstPtrToInt (ConstantVal: ValueRef; ToType: TypeRef; ):
  ValueRef;

PROCEDURE ConstIntToPtr (ConstantVal: ValueRef; ToType: TypeRef; ):
  ValueRef;

PROCEDURE ConstBitCast (ConstantVal: ValueRef; ToType: TypeRef; ):
  ValueRef;

PROCEDURE ConstAddrSpaceCast (ConstantVal: ValueRef; ToType: TypeRef; ):
  ValueRef;

PROCEDURE ConstTruncOrBitCast (ConstantVal: ValueRef; ToType: TypeRef; ):
  ValueRef;

PROCEDURE ConstPointerCast (ConstantVal: ValueRef; ToType: TypeRef; ):
  ValueRef;

PROCEDURE ConstExtractElement (VectorConstant, IndexConstant: ValueRef; ):
  ValueRef;

PROCEDURE ConstInsertElement
  (VectorConstant, ElementValueConstant, IndexConstant: ValueRef; ):
  ValueRef;

PROCEDURE ConstShuffleVector
  (VectorAConstant, VectorBConstant, MaskConstant: ValueRef; ): ValueRef;

PROCEDURE BlockAddress (F: ValueRef; BB: BasicBlockRef; ): ValueRef;


(**
 * Gets the function associated with a given BlockAddress constant value.
 *)

PROCEDURE GetBlockAddressFunction (BlockAddr: ValueRef; ): ValueRef;


(**
 * Gets the basic block associated with a given BlockAddress constant value.
 *)

PROCEDURE GetBlockAddressBasicBlock (BlockAddr: ValueRef; ): BasicBlockRef;


(** Deprecated: Use LLVMGetInlineAsm instead. *)

PROCEDURE ConstInlineAsm (Ty                          : TypeRef;
                          AsmString, Constraints      : TEXT;
                          HasSideEffects, IsAlignStack: BOOLEAN; ):
  ValueRef;


(**
 * @}
 *)

PROCEDURE GetGlobalParent (Global: ValueRef; ): ModuleRef;

PROCEDURE IsDeclaration (Global: ValueRef; ): BOOLEAN;

PROCEDURE GetLinkage (Global: ValueRef; ): LLVMLinkage;

PROCEDURE SetLinkage (Global: ValueRef; Linkage: LLVMLinkage; );

PROCEDURE GetSection (Global: ValueRef; ): TEXT;

PROCEDURE SetSection (Global: ValueRef; Section: TEXT; );

PROCEDURE GetVisibility (Global: ValueRef; ): LLVMVisibility;

PROCEDURE SetVisibility (Global: ValueRef; Viz: LLVMVisibility; );

PROCEDURE GetDLLStorageClass (Global: ValueRef; ): LLVMDLLStorageClass;

PROCEDURE SetDLLStorageClass
  (Global: ValueRef; Class: LLVMDLLStorageClass; );

PROCEDURE GetUnnamedAddress (Global: ValueRef; ): LLVMUnnamedAddr;

PROCEDURE SetUnnamedAddress
  (Global: ValueRef; UnnamedAddr: LLVMUnnamedAddr; );


(**
 * Returns the "value type" of a global value.  This differs from the formal
 * type of a global value which is always a pointer type.
 *
 * @see llvm::GlobalValue::getValueType()
 * @see llvm::Function::getFunctionType()
 *)

PROCEDURE GlobalGetValueType (Global: ValueRef; ): TypeRef;


(** Deprecated: Use LLVMGetUnnamedAddress instead. *)

PROCEDURE HasUnnamedAddr (Global: ValueRef; ): BOOLEAN;


(** Deprecated: Use LLVMSetUnnamedAddress instead. *)

PROCEDURE SetUnnamedAddr (Global: ValueRef; HasUnnamedAddr: BOOLEAN; );


(**
 * Obtain the preferred alignment of the value.
 * @see llvm::AllocaInst::getAlignment()
 * @see llvm::LoadInst::getAlignment()
 * @see llvm::StoreInst::getAlignment()
 * @see llvm::AtomicRMWInst::setAlignment()
 * @see llvm::AtomicCmpXchgInst::setAlignment()
 * @see llvm::GlobalValue::getAlignment()
 *)

PROCEDURE GetAlignment (V: ValueRef; ): uint32_t;


(**
 * Set the preferred alignment of the value.
 * @see llvm::AllocaInst::setAlignment()
 * @see llvm::LoadInst::setAlignment()
 * @see llvm::StoreInst::setAlignment()
 * @see llvm::AtomicRMWInst::setAlignment()
 * @see llvm::AtomicCmpXchgInst::setAlignment()
 * @see llvm::GlobalValue::setAlignment()
 *)

PROCEDURE SetAlignment (V: ValueRef; Bytes: uint32_t; );


(**
 * Sets a metadata attachment, erasing the existing metadata attachment if
 * it already exists for the given kind.
 *
 * @see llvm::GlobalObject::setMetadata()
 *)

PROCEDURE GlobalSetMetadata
  (Global: ValueRef; Kind: uint32_t; MD: MetadataRef; );


(**
 * Adds a metadata attachment.
 *
 * @see llvm::GlobalObject::addMetadata()
 *)

PROCEDURE GlobalAddMetadata
  (Global: ValueRef; Kind: uint32_t; MD: MetadataRef; );


(**
 * Erases a metadata attachment of the given kind if it exists.
 *
 * @see llvm::GlobalObject::eraseMetadata()
 *)

PROCEDURE GlobalEraseMetadata (Global: ValueRef; Kind: uint32_t; );


(**
 * Removes all metadata attachments from this value.
 *
 * @see llvm::GlobalObject::clearMetadata()
 *)

PROCEDURE GlobalClearMetadata (Global: ValueRef; );


(**
 * Add debuginfo metadata to this global.
 *
 * @see llvm::GlobalVariable::addDebugInfo()
 *)

PROCEDURE GlobalAddDebugInfo (Global: ValueRef; GVE: MetadataRef; );


(**
 * Retrieves an array of metadata entries representing the metadata attached to
 * this value. The caller is responsible for freeing this array by calling
 * \c LLVMDisposeValueMetadataEntries.
 *
 * @see llvm::GlobalObject::getAllMetadata()
 *)

PROCEDURE GlobalCopyAllMetadata
  (Value: ValueRef; VAR NumEntries: Word.T; ):
  UNTRACED REF ValueMetadataEntryRef;


(**
 * Destroys value metadata entries.
 *)

PROCEDURE DisposeValueMetadataEntries
  (Entries: UNTRACED REF ValueMetadataEntryRef; );


(**
 * Returns the kind of a value metadata entry at a specific index.
 *)

PROCEDURE ValueMetadataEntriesGetKind
  (Entries: UNTRACED REF ValueMetadataEntryRef; Index: uint32_t; ):
  uint32_t;


(**
 * Returns the underlying metadata node of a value metadata entry at a
 * specific index.
 *)

PROCEDURE ValueMetadataEntriesGetMetadata
  (Entries: UNTRACED REF ValueMetadataEntryRef; Index: uint32_t; ):
  MetadataRef;


(**
 * @}
 *)

PROCEDURE AddGlobal (M: ModuleRef; Ty: TypeRef; Name: TEXT; ): ValueRef;

PROCEDURE AddGlobalInAddressSpace
  (M: ModuleRef; Ty: TypeRef; Name: TEXT; AddressSpace: uint32_t := 0; ):
  ValueRef;

PROCEDURE GetNamedGlobal (M: ModuleRef; Name: TEXT; ): ValueRef;

PROCEDURE GetNamedGlobalWithLength
  (M: ModuleRef; Name: TEXT; Length: Word.T; ): ValueRef;

PROCEDURE GetFirstGlobal (M: ModuleRef; ): ValueRef;

PROCEDURE GetLastGlobal (M: ModuleRef; ): ValueRef;

PROCEDURE GetNextGlobal (GlobalVar: ValueRef; ): ValueRef;

PROCEDURE GetPreviousGlobal (GlobalVar: ValueRef; ): ValueRef;

PROCEDURE DeleteGlobal (GlobalVar: ValueRef; );

PROCEDURE GetInitializer (GlobalVar: ValueRef; ): ValueRef;

PROCEDURE SetInitializer (GlobalVar, ConstantVal: ValueRef; );

PROCEDURE IsThreadLocal (GlobalVar: ValueRef; ): BOOLEAN;

PROCEDURE SetThreadLocal (GlobalVar: ValueRef; IsThreadLocal: BOOLEAN; );

PROCEDURE IsGlobalConstant (GlobalVar: ValueRef; ): BOOLEAN;

PROCEDURE SetGlobalConstant (GlobalVar: ValueRef; IsConstant: BOOLEAN; );

PROCEDURE GetThreadLocalMode (GlobalVar: ValueRef; ): LLVMThreadLocalMode;

PROCEDURE SetThreadLocalMode
  (GlobalVar: ValueRef; Mode: LLVMThreadLocalMode; );

PROCEDURE IsExternallyInitialized (GlobalVar: ValueRef; ): BOOLEAN;

PROCEDURE SetExternallyInitialized
  (GlobalVar: ValueRef; IsExtInit: BOOLEAN; );


(**
 * @}
 *
 * Add a GlobalAlias with the given value type, address space and aliasee.
 *
 * @see llvm::GlobalAlias::create()
 *)

PROCEDURE AddAlias2 (M        : ModuleRef;
                     ValueTy  : TypeRef;
                     AddrSpace: uint32_t;
                     Aliasee  : ValueRef;
                     Name     : TEXT;      ): ValueRef;


(**
 * Obtain a GlobalAlias value from a Module by its name.
 *
 * The returned value corresponds to a llvm::GlobalAlias value.
 *
 * @see llvm::Module::getNamedAlias()
 *)

PROCEDURE GetNamedGlobalAlias
  (M: ModuleRef; Name: TEXT; NameLen: Word.T; ): ValueRef;


(**
 * Obtain an iterator to the first GlobalAlias in a Module.
 *
 * @see llvm::Module::alias_begin()
 *)

PROCEDURE GetFirstGlobalAlias (M: ModuleRef; ): ValueRef;


(**
 * Obtain an iterator to the last GlobalAlias in a Module.
 *
 * @see llvm::Module::alias_end()
 *)

PROCEDURE GetLastGlobalAlias (M: ModuleRef; ): ValueRef;


(**
 * Advance a GlobalAlias iterator to the next GlobalAlias.
 *
 * Returns NULL if the iterator was already at the end and there are no more
 * global aliases.
 *)

PROCEDURE GetNextGlobalAlias (GA: ValueRef; ): ValueRef;


(**
 * Decrement a GlobalAlias iterator to the previous GlobalAlias.
 *
 * Returns NULL if the iterator was already at the beginning and there are
 * no previous global aliases.
 *)

PROCEDURE GetPreviousGlobalAlias (GA: ValueRef; ): ValueRef;


(**
 * Retrieve the target value of an alias.
 *)

PROCEDURE AliasGetAliasee (Alias: ValueRef; ): ValueRef;


(**
 * Set the target value of an alias.
 *)

PROCEDURE AliasSetAliasee (Alias, Aliasee: ValueRef; );


(**
 * @}
 *
 * Remove a function from its containing module and deletes it.
 *
 * @see llvm::Function::eraseFromParent()
 *)

PROCEDURE DeleteFunction (Fn: ValueRef; );


(**
 * Check whether the given function has a personality function.
 *
 * @see llvm::Function::hasPersonalityFn()
 *)

PROCEDURE HasPersonalityFn (Fn: ValueRef; ): BOOLEAN;


(**
 * Obtain the personality function attached to the function.
 *
 * @see llvm::Function::getPersonalityFn()
 *)

PROCEDURE GetPersonalityFn (Fn: ValueRef; ): ValueRef;


(**
 * Set the personality function attached to the function.
 *
 * @see llvm::Function::setPersonalityFn()
 *)

PROCEDURE SetPersonalityFn (Fn, PersonalityFn: ValueRef; );


(**
 * Obtain the intrinsic ID number which matches the given function name.
 *
 * @see llvm::Intrinsic::lookupIntrinsicID()
 *)

PROCEDURE LookupIntrinsicID (Name: TEXT; NameLen: Word.T; ): uint32_t;


(**
 * Obtain the ID number from a function instance.
 *
 * @see llvm::Function::getIntrinsicID()
 *)

PROCEDURE GetIntrinsicID (Fn: ValueRef; ): uint32_t;


(**
 * Get or insert the declaration of an intrinsic.  For overloaded intrinsics,
 * parameter types must be provided to uniquely identify an overload.
 *
 * @see llvm::Intrinsic::getOrInsertDeclaration()
 *)

PROCEDURE GetIntrinsicDeclaration (Mod       : ModuleRef;
                                   ID        : uint32_t;
                                   ParamTypes: UNTRACED REF TypeRef;
                                   ParamCount: Word.T;               ):
  ValueRef;


(**
 * Retrieves the type of an intrinsic.  For overloaded intrinsics, parameter
 * types must be provided to uniquely identify an overload.
 *
 * @see llvm::Intrinsic::getType()
 *)

PROCEDURE IntrinsicGetType (Ctx       : ContextRef;
                            ID        : uint32_t;
                            ParamTypes: UNTRACED REF TypeRef;
                            ParamCount: Word.T;               ): TypeRef;


(**
 * Retrieves the name of an intrinsic.
 *
 * @see llvm::Intrinsic::getName()
 *)

PROCEDURE IntrinsicGetName (ID: uint32_t; VAR NameLength: Word.T; ): TEXT;


(** Deprecated: Use LLVMIntrinsicCopyOverloadedName2 instead. *)

PROCEDURE IntrinsicCopyOverloadedName (ID        : uint32_t;
                                       ParamTypes: UNTRACED REF TypeRef;
                                       ParamCount: Word.T;
                                       VAR NameLength: Word.T; ): TEXT;


(**
 * Copies the name of an overloaded intrinsic identified by a given list of
 * parameter types.
 *
 * Unlike LLVMIntrinsicGetName, the caller is responsible for freeing the
 * returned string.
 *
 * This version also supports unnamed types.
 *
 * @see llvm::Intrinsic::getName()
 *)

PROCEDURE IntrinsicCopyOverloadedName2 (Mod       : ModuleRef;
                                        ID        : uint32_t;
                                        ParamTypes: UNTRACED REF TypeRef;
                                        ParamCount: Word.T;
                                        VAR NameLength: Word.T; ): TEXT;


(**
 * Obtain if the intrinsic identified by the given ID is overloaded.
 *
 * @see llvm::Intrinsic::isOverloaded()
 *)

PROCEDURE IntrinsicIsOverloaded (ID: uint32_t; ): BOOLEAN;


(**
 * Obtain the calling function of a function.
 *
 * The returned value corresponds to the LLVMCallConv enumeration.
 *
 * @see llvm::Function::getCallingConv()
 *)

PROCEDURE GetFunctionCallConv (Fn: ValueRef; ): uint32_t;


(**
 * Set the calling convention of a function.
 *
 * @see llvm::Function::setCallingConv()
 *
 * @param Fn Function to operate on
 * @param CC LLVMCallConv to set calling convention to
 *)

PROCEDURE SetFunctionCallConv (Fn: ValueRef; CC: uint32_t; );


(**
 * Obtain the name of the garbage collector to use during code
 * generation.
 *
 * @see llvm::Function::getGC()
 *)

PROCEDURE GetGC (Fn: ValueRef; ): TEXT;


(**
 * Define the garbage collector to use during code generation.
 *
 * @see llvm::Function::setGC()
 *)

PROCEDURE SetGC (Fn: ValueRef; Name: TEXT; );


(**
 * Gets the prefix data associated with a function. Only valid on functions, and
 * only if LLVMHasPrefixData returns true.
 * See https://llvm.org/docs/LangRef.html#prefix-data
 *)

PROCEDURE GetPrefixData (Fn: ValueRef; ): ValueRef;


(**
 * Check if a given function has prefix data. Only valid on functions.
 * See https://llvm.org/docs/LangRef.html#prefix-data
 *)

PROCEDURE HasPrefixData (Fn: ValueRef; ): BOOLEAN;


(**
 * Sets the prefix data for the function. Only valid on functions.
 * See https://llvm.org/docs/LangRef.html#prefix-data
 *)

PROCEDURE SetPrefixData (Fn, prefixData: ValueRef; );


(**
 * Gets the prologue data associated with a function. Only valid on functions,
 * and only if LLVMHasPrologueData returns true.
 * See https://llvm.org/docs/LangRef.html#prologue-data
 *)

PROCEDURE GetPrologueData (Fn: ValueRef; ): ValueRef;


(**
 * Check if a given function has prologue data. Only valid on functions.
 * See https://llvm.org/docs/LangRef.html#prologue-data
 *)

PROCEDURE HasPrologueData (Fn: ValueRef; ): BOOLEAN;


(**
 * Sets the prologue data for the function. Only valid on functions.
 * See https://llvm.org/docs/LangRef.html#prologue-data
 *)

PROCEDURE SetPrologueData (Fn, prologueData: ValueRef; );


(**
 * Add an attribute to a function.
 *
 * @see llvm::Function::addAttribute()
 *)

PROCEDURE AddAttributeAtIndex
  (F: ValueRef; Idx: AttributeIndex; A: AttributeRef; );

PROCEDURE GetAttributeCountAtIndex (F: ValueRef; Idx: AttributeIndex; ):
  uint32_t;

PROCEDURE GetAttributesAtIndex
  (F: ValueRef; Idx: AttributeIndex; Attrs: UNTRACED REF AttributeRef; );

PROCEDURE GetEnumAttributeAtIndex
  (F: ValueRef; Idx: AttributeIndex; KindID: uint32_t; ): AttributeRef;

PROCEDURE GetStringAttributeAtIndex
  (F: ValueRef; Idx: AttributeIndex; K: TEXT; KLen: uint32_t; ):
  AttributeRef;

PROCEDURE RemoveEnumAttributeAtIndex
  (F: ValueRef; Idx: AttributeIndex; KindID: uint32_t; );

PROCEDURE RemoveStringAttributeAtIndex
  (F: ValueRef; Idx: AttributeIndex; K: TEXT; KLen: uint32_t; );


(**
 * Add a target-dependent attribute to a function
 * @see llvm::AttrBuilder::addAttribute()
 *)

PROCEDURE AddTargetDependentFunctionAttr (Fn: ValueRef; A, V: TEXT; );


(**
 * Obtain the number of parameters in a function.
 *
 * @see llvm::Function::arg_size()
 *)

PROCEDURE CountParams (Fn: ValueRef; ): uint32_t;


(**
 * Obtain the parameters in a function.
 *
 * The takes a pointer to a pre-allocated array of LLVMValueRef that is
 * at least LLVMCountParams() long. This array will be filled with
 * LLVMValueRef instances which correspond to the parameters the
 * function receives. Each LLVMValueRef corresponds to a llvm::Argument
 * instance.
 *
 * @see llvm::Function::arg_begin()
 *)

PROCEDURE GetParams (Fn: ValueRef; Params: UNTRACED REF ValueRef; );


(**
 * Obtain the parameter at the specified index.
 *
 * Parameters are indexed from 0.
 *
 * @see llvm::Function::arg_begin()
 *)

PROCEDURE GetParam (Fn: ValueRef; Index: uint32_t; ): ValueRef;


(**
 * Obtain the function to which this argument belongs.
 *
 * Unlike other functions in this group, this one takes an LLVMValueRef
 * that corresponds to a llvm::Attribute.
 *
 * The returned LLVMValueRef is the llvm::Function to which this
 * argument belongs.
 *)

PROCEDURE GetParamParent (Inst: ValueRef; ): ValueRef;


(**
 * Obtain the first parameter to a function.
 *
 * @see llvm::Function::arg_begin()
 *)

PROCEDURE GetFirstParam (Fn: ValueRef; ): ValueRef;


(**
 * Obtain the last parameter to a function.
 *
 * @see llvm::Function::arg_end()
 *)

PROCEDURE GetLastParam (Fn: ValueRef; ): ValueRef;


(**
 * Obtain the next parameter to a function.
 *
 * This takes an LLVMValueRef obtained from LLVMGetFirstParam() (which is
 * actually a wrapped iterator) and obtains the next parameter from the
 * underlying iterator.
 *)

PROCEDURE GetNextParam (Arg: ValueRef; ): ValueRef;


(**
 * Obtain the previous parameter to a function.
 *
 * This is the opposite of LLVMGetNextParam().
 *)

PROCEDURE GetPreviousParam (Arg: ValueRef; ): ValueRef;


(**
 * Set the alignment for a function parameter.
 *
 * @see llvm::Argument::addAttr()
 * @see llvm::AttrBuilder::addAlignmentAttr()
 *)

PROCEDURE SetParamAlignment (Arg: ValueRef; Align: uint32_t; );


(**
 * @}
 *
 * Add a global indirect function to a module under a specified name.
 *
 * @see llvm::GlobalIFunc::create()
 *)

PROCEDURE AddGlobalIFunc (M        : ModuleRef;
                          Name     : TEXT;
                          NameLen  : Word.T;
                          Ty       : TypeRef;
                          AddrSpace: uint32_t;
                          Resolver : ValueRef;  ): ValueRef;


(**
 * Obtain a GlobalIFunc value from a Module by its name.
 *
 * The returned value corresponds to a llvm::GlobalIFunc value.
 *
 * @see llvm::Module::getNamedIFunc()
 *)

PROCEDURE GetNamedGlobalIFunc
  (M: ModuleRef; Name: TEXT; NameLen: Word.T; ): ValueRef;


(**
 * Obtain an iterator to the first GlobalIFunc in a Module.
 *
 * @see llvm::Module::ifunc_begin()
 *)

PROCEDURE GetFirstGlobalIFunc (M: ModuleRef; ): ValueRef;


(**
 * Obtain an iterator to the last GlobalIFunc in a Module.
 *
 * @see llvm::Module::ifunc_end()
 *)

PROCEDURE GetLastGlobalIFunc (M: ModuleRef; ): ValueRef;


(**
 * Advance a GlobalIFunc iterator to the next GlobalIFunc.
 *
 * Returns NULL if the iterator was already at the end and there are no more
 * global aliases.
 *)

PROCEDURE GetNextGlobalIFunc (IFunc: ValueRef; ): ValueRef;


(**
 * Decrement a GlobalIFunc iterator to the previous GlobalIFunc.
 *
 * Returns NULL if the iterator was already at the beginning and there are
 * no previous global aliases.
 *)

PROCEDURE GetPreviousGlobalIFunc (IFunc: ValueRef; ): ValueRef;


(**
 * Retrieves the resolver function associated with this indirect function, or
 * NULL if it doesn't not exist.
 *
 * @see llvm::GlobalIFunc::getResolver()
 *)

PROCEDURE GetGlobalIFuncResolver (IFunc: ValueRef; ): ValueRef;


(**
 * Sets the resolver function associated with this indirect function.
 *
 * @see llvm::GlobalIFunc::setResolver()
 *)

PROCEDURE SetGlobalIFuncResolver (IFunc, Resolver: ValueRef; );


(**
 * Remove a global indirect function from its parent module and delete it.
 *
 * @see llvm::GlobalIFunc::eraseFromParent()
 *)

PROCEDURE EraseGlobalIFunc (IFunc: ValueRef; );


(**
 * Remove a global indirect function from its parent module.
 *
 * This unlinks the global indirect function from its containing module but
 * keeps it alive.
 *
 * @see llvm::GlobalIFunc::removeFromParent()
 *)

PROCEDURE RemoveGlobalIFunc (IFunc: ValueRef; );


(**
 * @}
 *
 * @}
 *
 * @}
 *
 * @}
 *
 * Create an MDString value from a given string value.
 *
 * The MDString value does not take ownership of the given string, it remains
 * the responsibility of the caller to free it.
 *
 * @see llvm::MDString::get()
 *)

PROCEDURE MDStringInContext2
  (context: ContextRef; Str: TEXT; SLen: Word.T; ): MetadataRef;


(**
 * Create an MDNode value with the given array of operands.
 *
 * @see llvm::MDNode::get()
 *)

PROCEDURE MDNodeInContext2
  (context: ContextRef; MDs: UNTRACED REF MetadataRef; Count: Word.T; ):
  MetadataRef;


(**
 * Obtain a Metadata as a Value.
 *)

PROCEDURE MetadataAsValue (context: ContextRef; MD: MetadataRef; ):
  ValueRef;


(**
 * Obtain a Value as a Metadata.
 *)

PROCEDURE ValueAsMetadata (Val: ValueRef; ): MetadataRef;


(**
 * Obtain the underlying string from a MDString value.
 *
 * @param V Instance to obtain string from.
 * @param Length Memory address which will hold length of returned string.
 * @return String data in MDString.
 *)

PROCEDURE GetMDString (V: ValueRef; VAR Length: uint32_t; ): TEXT;


(**
 * Obtain the number of operands from an MDNode value.
 *
 * @param V MDNode to get number of operands from.
 * @return Number of operands of the MDNode.
 *)

PROCEDURE GetMDNodeNumOperands (V: ValueRef; ): uint32_t;


(**
 * Obtain the given MDNode's operands.
 *
 * The passed LLVMValueRef pointer should point to enough memory to hold all of
 * the operands of the given MDNode (see LLVMGetMDNodeNumOperands) as
 * LLVMValueRefs. This memory will be populated with the LLVMValueRefs of the
 * MDNode's operands.
 *
 * @param V MDNode to get the operands from.
 * @param Dest Destination array for operands.
 *)

PROCEDURE GetMDNodeOperands (V: ValueRef; Dest: UNTRACED REF ValueRef; );


(**
 * Replace an operand at a specific index in a llvm::MDNode value.
 *
 * @see llvm::MDNode::replaceOperandWith()
 *)

PROCEDURE ReplaceMDNodeOperandWith
  (V: ValueRef; Index: uint32_t; Replacement: MetadataRef; );


(** Deprecated: Use LLVMMDStringInContext2 instead. *)

PROCEDURE MDStringInContext
  (context: ContextRef; Str: TEXT; SLen: uint32_t; ): ValueRef;


(** Deprecated: Use LLVMMDStringInContext2 instead. *)

PROCEDURE MDString (Str: TEXT; SLen: uint32_t; ): ValueRef;


(** Deprecated: Use LLVMMDNodeInContext2 instead. *)

PROCEDURE MDNodeInContext
  (context: ContextRef; Vals: UNTRACED REF ValueRef; Count: uint32_t; ):
  ValueRef;


(** Deprecated: Use LLVMMDNodeInContext2 instead. *)

PROCEDURE MDNode (Vals: UNTRACED REF ValueRef; Count: uint32_t; ):
  ValueRef;


(**
 * @}
 *
 * Create a new operand bundle.
 *
 * Every invocation should be paired with LLVMDisposeOperandBundle() or memory
 * will be leaked.
 *
 * @param Tag Tag name of the operand bundle
 * @param TagLen Length of Tag
 * @param Args Memory address of an array of bundle operands
 * @param NumArgs Length of Args
 *)

PROCEDURE CreateOperandBundle (Tag    : TEXT;
                               TagLen : Word.T;
                               Args   : UNTRACED REF ValueRef;
                               NumArgs: uint32_t;              ):
  OperandBundleRef;


(**
 * Destroy an operand bundle.
 *
 * This must be called for every created operand bundle or memory will be
 * leaked.
 *)

PROCEDURE DisposeOperandBundle (Bundle: OperandBundleRef; );


(**
 * Obtain the tag of an operand bundle as a string.
 *
 * @param Bundle Operand bundle to obtain tag of.
 * @param Len Out parameter which holds the length of the returned string.
 * @return The tag name of Bundle.
 * @see OperandBundleDef::getTag()
 *)

PROCEDURE GetOperandBundleTag
  (Bundle: OperandBundleRef; VAR Len: Word.T; ): TEXT;


(**
 * Obtain the number of operands for an operand bundle.
 *
 * @param Bundle Operand bundle to obtain operand count of.
 * @return The number of operands.
 * @see OperandBundleDef::input_size()
 *)

PROCEDURE GetNumOperandBundleArgs (Bundle: OperandBundleRef; ): uint32_t;


(**
 * Obtain the operand for an operand bundle at the given index.
 *
 * @param Bundle Operand bundle to obtain operand of.
 * @param Index An operand index, must be less than
 * LLVMGetNumOperandBundleArgs().
 * @return The operand.
 *)

PROCEDURE GetOperandBundleArgAtIndex
  (Bundle: OperandBundleRef; Index: uint32_t; ): ValueRef;


(**
 * @}
 *
 * Convert a basic block instance to a value type.
 *)

PROCEDURE BasicBlockAsValue (BB: BasicBlockRef; ): ValueRef;


(**
 * Determine whether an LLVMValueRef is itself a basic block.
 *)

PROCEDURE ValueIsBasicBlock (Val: ValueRef; ): BOOLEAN;


(**
 * Convert an LLVMValueRef to an LLVMBasicBlockRef instance.
 *)

PROCEDURE ValueAsBasicBlock (Val: ValueRef; ): BasicBlockRef;


(**
 * Obtain the string name of a basic block.
 *)

PROCEDURE GetBasicBlockName (BB: BasicBlockRef; ): TEXT;


(**
 * Obtain the function to which a basic block belongs.
 *
 * @see llvm::BasicBlock::getParent()
 *)

PROCEDURE GetBasicBlockParent (BB: BasicBlockRef; ): ValueRef;


(**
 * Obtain the terminator instruction for a basic block.
 *
 * If the basic block does not have a terminator (it is not well-formed
 * if it doesn't), then NULL is returned.
 *
 * The returned LLVMValueRef corresponds to an llvm::Instruction.
 *
 * @see llvm::BasicBlock::getTerminator()
 *)

PROCEDURE GetBasicBlockTerminator (BB: BasicBlockRef; ): ValueRef;


(**
 * Obtain the number of basic blocks in a function.
 *
 * @param Fn Function value to operate on.
 *)

PROCEDURE CountBasicBlocks (Fn: ValueRef; ): uint32_t;


(**
 * Obtain all of the basic blocks in a function.
 *
 * This operates on a function value. The BasicBlocks parameter is a
 * pointer to a pre-allocated array of LLVMBasicBlockRef of at least
 * LLVMCountBasicBlocks() in length. This array is populated with
 * LLVMBasicBlockRef instances.
 *)

PROCEDURE GetBasicBlocks
  (Fn: ValueRef; BasicBlocks: UNTRACED REF BasicBlockRef; );


(**
 * Obtain the first basic block in a function.
 *
 * The returned basic block can be used as an iterator. You will likely
 * eventually call into LLVMGetNextBasicBlock() with it.
 *
 * @see llvm::Function::begin()
 *)

PROCEDURE GetFirstBasicBlock (Fn: ValueRef; ): BasicBlockRef;


(**
 * Obtain the last basic block in a function.
 *
 * @see llvm::Function::end()
 *)

PROCEDURE GetLastBasicBlock (Fn: ValueRef; ): BasicBlockRef;


(**
 * Advance a basic block iterator.
 *)

PROCEDURE GetNextBasicBlock (BB: BasicBlockRef; ): BasicBlockRef;


(**
 * Go backwards in a basic block iterator.
 *)

PROCEDURE GetPreviousBasicBlock (BB: BasicBlockRef; ): BasicBlockRef;


(**
 * Obtain the basic block that corresponds to the entry point of a
 * function.
 *
 * @see llvm::Function::getEntryBlock()
 *)

PROCEDURE GetEntryBasicBlock (Fn: ValueRef; ): BasicBlockRef;


(**
 * Insert the given basic block after the insertion point of the given builder.
 *
 * The insertion point must be valid.
 *
 * @see llvm::Function::BasicBlockListType::insertAfter()
 *)

PROCEDURE InsertExistingBasicBlockAfterInsertBlock
  (Builder: BuilderRef; BB: BasicBlockRef; );


(**
 * Append the given basic block to the basic block list of the given function.
 *
 * @see llvm::Function::BasicBlockListType::push_back()
 *)

PROCEDURE AppendExistingBasicBlock (Fn: ValueRef; BB: BasicBlockRef; );


(**
 * Create a new basic block without inserting it into a function.
 *
 * @see llvm::BasicBlock::Create()
 *)

PROCEDURE CreateBasicBlockInContext (context: ContextRef; Name: TEXT; ):
  BasicBlockRef;


(**
 * Append a basic block to the end of a function.
 *
 * @see llvm::BasicBlock::Create()
 *)

PROCEDURE AppendBasicBlockInContext
  (context: ContextRef; Fn: ValueRef; Name: TEXT; ): BasicBlockRef;


(**
 * Append a basic block to the end of a function using the global
 * context.
 *
 * @see llvm::BasicBlock::Create()
 *)

PROCEDURE AppendBasicBlock (Fn: ValueRef; Name: TEXT; ): BasicBlockRef;


(**
 * Insert a basic block in a function before another basic block.
 *
 * The function to add to is determined by the function of the
 * passed basic block.
 *
 * @see llvm::BasicBlock::Create()
 *)

PROCEDURE InsertBasicBlockInContext
  (context: ContextRef; BB: BasicBlockRef; Name: TEXT; ): BasicBlockRef;


(**
 * Insert a basic block in a function using the global context.
 *
 * @see llvm::BasicBlock::Create()
 *)

PROCEDURE InsertBasicBlock (InsertBeforeBB: BasicBlockRef; Name: TEXT; ):
  BasicBlockRef;


(**
 * Remove a basic block from a function and delete it.
 *
 * This deletes the basic block from its containing function and deletes
 * the basic block itself.
 *
 * @see llvm::BasicBlock::eraseFromParent()
 *)

PROCEDURE DeleteBasicBlock (BB: BasicBlockRef; );


(**
 * Remove a basic block from a function.
 *
 * This deletes the basic block from its containing function but keep
 * the basic block alive.
 *
 * @see llvm::BasicBlock::removeFromParent()
 *)

PROCEDURE RemoveBasicBlockFromParent (BB: BasicBlockRef; );


(**
 * Move a basic block to before another one.
 *
 * @see llvm::BasicBlock::moveBefore()
 *)

PROCEDURE MoveBasicBlockBefore (BB, MovePos: BasicBlockRef; );


(**
 * Move a basic block to after another one.
 *
 * @see llvm::BasicBlock::moveAfter()
 *)

PROCEDURE MoveBasicBlockAfter (BB, MovePos: BasicBlockRef; );


(**
 * Obtain the first instruction in a basic block.
 *
 * The returned LLVMValueRef corresponds to a llvm::Instruction
 * instance.
 *)

PROCEDURE GetFirstInstruction (BB: BasicBlockRef; ): ValueRef;


(**
 * Obtain the last instruction in a basic block.
 *
 * The returned LLVMValueRef corresponds to an LLVM:Instruction.
 *)

PROCEDURE GetLastInstruction (BB: BasicBlockRef; ): ValueRef;


(**
 * @}
 *
 * Determine whether an instruction has any metadata attached.
 *)

PROCEDURE HasMetadata (Val: ValueRef; ): INTEGER;


(**
 * Return metadata associated with an instruction value.
 *)

PROCEDURE GetMetadata (Val: ValueRef; KindID: uint32_t; ): ValueRef;


(**
 * Set metadata associated with an instruction value.
 *)

PROCEDURE SetMetadata (Val: ValueRef; KindID: uint32_t; Node: ValueRef; );


(**
 * Returns the metadata associated with an instruction value, but filters out
 * all the debug locations.
 *
 * @see llvm::Instruction::getAllMetadataOtherThanDebugLoc()
 *)

PROCEDURE InstructionGetAllMetadataOtherThanDebugLoc
  (Instr: ValueRef; VAR NumEntries: Word.T; ):
  UNTRACED REF ValueMetadataEntryRef;


(**
 * Obtain the basic block to which an instruction belongs.
 *
 * @see llvm::Instruction::getParent()
 *)

PROCEDURE GetInstructionParent (Inst: ValueRef; ): BasicBlockRef;


(**
 * Obtain the instruction that occurs after the one specified.
 *
 * The next instruction will be from the same basic block.
 *
 * If this is the last instruction in a basic block, NULL will be
 * returned.
 *)

PROCEDURE GetNextInstruction (Inst: ValueRef; ): ValueRef;


(**
 * Obtain the instruction that occurred before this one.
 *
 * If the instruction is the first instruction in a basic block, NULL
 * will be returned.
 *)

PROCEDURE GetPreviousInstruction (Inst: ValueRef; ): ValueRef;


(**
 * Remove an instruction.
 *
 * The instruction specified is removed from its containing building
 * block but is kept alive.
 *
 * @see llvm::Instruction::removeFromParent()
 *)

PROCEDURE InstructionRemoveFromParent (Inst: ValueRef; );


(**
 * Remove and delete an instruction.
 *
 * The instruction specified is removed from its containing building
 * block and then deleted.
 *
 * @see llvm::Instruction::eraseFromParent()
 *)

PROCEDURE InstructionEraseFromParent (Inst: ValueRef; );


(**
 * Delete an instruction.
 *
 * The instruction specified is deleted. It must have previously been
 * removed from its containing building block.
 *
 * @see llvm::Value::deleteValue()
 *)

PROCEDURE DeleteInstruction (Inst: ValueRef; );


(**
 * Obtain the code opcode for an individual instruction.
 *
 * @see llvm::Instruction::getOpCode()
 *)

PROCEDURE GetInstructionOpcode (Inst: ValueRef; ): LLVMOpcode;


(**
 * Obtain the predicate of an instruction.
 *
 * This is only valid for instructions that correspond to llvm::ICmpInst.
 *
 * @see llvm::ICmpInst::getPredicate()
 *)

PROCEDURE GetICmpPredicate (Inst: ValueRef; ): LLVMIntPredicate;


(**
 * Get whether or not an icmp instruction has the samesign flag.
 *
 * This is only valid for instructions that correspond to llvm::ICmpInst.
 *
 * @see llvm::ICmpInst::hasSameSign()
 *)

PROCEDURE GetICmpSameSign (Inst: ValueRef; ): BOOLEAN;


(**
 * Set the samesign flag on an icmp instruction.
 *
 * This is only valid for instructions that correspond to llvm::ICmpInst.
 *
 * @see llvm::ICmpInst::setSameSign()
 *)

PROCEDURE SetICmpSameSign (Inst: ValueRef; SameSign: BOOLEAN; );


(**
 * Obtain the float predicate of an instruction.
 *
 * This is only valid for instructions that correspond to llvm::FCmpInst.
 *
 * @see llvm::FCmpInst::getPredicate()
 *)

PROCEDURE GetFCmpPredicate (Inst: ValueRef; ): LLVMRealPredicate;


(**
 * Create a copy of 'this' instruction that is identical in all ways
 * except the following:
 *   * The instruction has no parent
 *   * The instruction has no name
 *
 * @see llvm::Instruction::clone()
 *)

PROCEDURE InstructionClone (Inst: ValueRef; ): ValueRef;


(**
 * Determine whether an instruction is a terminator. This routine is named to
 * be compatible with historical functions that did this by querying the
 * underlying C++ type.
 *
 * @see llvm::Instruction::isTerminator()
 *)

PROCEDURE IsATerminatorInst (Inst: ValueRef; ): ValueRef;


(**
 * Obtain the first debug record attached to an instruction.
 *
 * Use LLVMGetNextDbgRecord() and LLVMGetPreviousDbgRecord() to traverse the
 * sequence of DbgRecords.
 *
 * Return the first DbgRecord attached to Inst or NULL if there are none.
 *
 * @see llvm::Instruction::getDbgRecordRange()
 *)

PROCEDURE GetFirstDbgRecord (Inst: ValueRef; ): DbgRecordRef;


(**
 * Obtain the last debug record attached to an instruction.
 *
 * Return the last DbgRecord attached to Inst or NULL if there are none.
 *
 * @see llvm::Instruction::getDbgRecordRange()
 *)

PROCEDURE GetLastDbgRecord (Inst: ValueRef; ): DbgRecordRef;


(**
 * Obtain the next DbgRecord in the sequence or NULL if there are no more.
 *
 * @see llvm::Instruction::getDbgRecordRange()
 *)

PROCEDURE GetNextDbgRecord (DbgRecord: DbgRecordRef; ): DbgRecordRef;


(**
 * Obtain the previous DbgRecord in the sequence or NULL if there are no more.
 *
 * @see llvm::Instruction::getDbgRecordRange()
 *)

PROCEDURE GetPreviousDbgRecord (DbgRecord: DbgRecordRef; ): DbgRecordRef;


(**
 * Obtain the argument count for a call instruction.
 *
 * This expects an LLVMValueRef that corresponds to a llvm::CallInst,
 * llvm::InvokeInst, or llvm:FuncletPadInst.
 *
 * @see llvm::CallInst::getNumArgOperands()
 * @see llvm::InvokeInst::getNumArgOperands()
 * @see llvm::FuncletPadInst::getNumArgOperands()
 *)

PROCEDURE GetNumArgOperands (Instr: ValueRef; ): uint32_t;


(**
 * Set the calling convention for a call instruction.
 *
 * This expects an LLVMValueRef that corresponds to a llvm::CallInst or
 * llvm::InvokeInst.
 *
 * @see llvm::CallInst::setCallingConv()
 * @see llvm::InvokeInst::setCallingConv()
 *)

PROCEDURE SetInstructionCallConv (Instr: ValueRef; CC: uint32_t; );


(**
 * Obtain the calling convention for a call instruction.
 *
 * This is the opposite of LLVMSetInstructionCallConv(). Reads its
 * usage.
 *
 * @see LLVMSetInstructionCallConv()
 *)

PROCEDURE GetInstructionCallConv (Instr: ValueRef; ): uint32_t;

PROCEDURE SetInstrParamAlignment
  (Instr: ValueRef; Idx: AttributeIndex; Align: uint32_t; );

PROCEDURE AddCallSiteAttribute
  (context: ValueRef; Idx: AttributeIndex; A: AttributeRef; );

PROCEDURE GetCallSiteAttributeCount
  (context: ValueRef; Idx: AttributeIndex; ): uint32_t;

PROCEDURE GetCallSiteAttributes (context: ValueRef;
                                 Idx    : AttributeIndex;
                                 Attrs  : UNTRACED REF AttributeRef; );

PROCEDURE GetCallSiteEnumAttribute
  (context: ValueRef; Idx: AttributeIndex; KindID: uint32_t; ):
  AttributeRef;

PROCEDURE GetCallSiteStringAttribute
  (context: ValueRef; Idx: AttributeIndex; K: TEXT; KLen: uint32_t; ):
  AttributeRef;

PROCEDURE RemoveCallSiteEnumAttribute
  (context: ValueRef; Idx: AttributeIndex; KindID: uint32_t; );

PROCEDURE RemoveCallSiteStringAttribute
  (context: ValueRef; Idx: AttributeIndex; K: TEXT; KLen: uint32_t; );


(**
 * Obtain the function type called by this instruction.
 *
 * @see llvm::CallBase::getFunctionType()
 *)

PROCEDURE GetCalledFunctionType (context: ValueRef; ): TypeRef;


(**
 * Obtain the pointer to the function invoked by this instruction.
 *
 * This expects an LLVMValueRef that corresponds to a llvm::CallInst or
 * llvm::InvokeInst.
 *
 * @see llvm::CallInst::getCalledOperand()
 * @see llvm::InvokeInst::getCalledOperand()
 *)

PROCEDURE GetCalledValue (Instr: ValueRef; ): ValueRef;


(**
 * Obtain the number of operand bundles attached to this instruction.
 *
 * This only works on llvm::CallInst and llvm::InvokeInst instructions.
 *
 * @see llvm::CallBase::getNumOperandBundles()
 *)

PROCEDURE GetNumOperandBundles (context: ValueRef; ): uint32_t;


(**
 * Obtain the operand bundle attached to this instruction at the given index.
 * Use LLVMDisposeOperandBundle to free the operand bundle.
 *
 * This only works on llvm::CallInst and llvm::InvokeInst instructions.
 *)

PROCEDURE GetOperandBundleAtIndex (context: ValueRef; Index: uint32_t; ):
  OperandBundleRef;


(**
 * Obtain whether a call instruction is a tail call.
 *
 * This only works on llvm::CallInst instructions.
 *
 * @see llvm::CallInst::isTailCall()
 *)

PROCEDURE IsTailCall (CallInst: ValueRef; ): BOOLEAN;


(**
 * Set whether a call instruction is a tail call.
 *
 * This only works on llvm::CallInst instructions.
 *
 * @see llvm::CallInst::setTailCall()
 *)

PROCEDURE SetTailCall (CallInst: ValueRef; IsTailCall: BOOLEAN; );


(**
 * Obtain a tail call kind of the call instruction.
 *
 * @see llvm::CallInst::setTailCallKind()
 *)

PROCEDURE GetTailCallKind (CallInst: ValueRef; ): LLVMTailCallKind;


(**
 * Set the call kind of the call instruction.
 *
 * @see llvm::CallInst::getTailCallKind()
 *)

PROCEDURE SetTailCallKind (CallInst: ValueRef; kind: LLVMTailCallKind; );


(**
 * Return the normal destination basic block.
 *
 * This only works on llvm::InvokeInst instructions.
 *
 * @see llvm::InvokeInst::getNormalDest()
 *)

PROCEDURE GetNormalDest (InvokeInst: ValueRef; ): BasicBlockRef;


(**
 * Return the unwind destination basic block.
 *
 * Works on llvm::InvokeInst, llvm::CleanupReturnInst, and
 * llvm::CatchSwitchInst instructions.
 *
 * @see llvm::InvokeInst::getUnwindDest()
 * @see llvm::CleanupReturnInst::getUnwindDest()
 * @see llvm::CatchSwitchInst::getUnwindDest()
 *)

PROCEDURE GetUnwindDest (InvokeInst: ValueRef; ): BasicBlockRef;


(**
 * Set the normal destination basic block.
 *
 * This only works on llvm::InvokeInst instructions.
 *
 * @see llvm::InvokeInst::setNormalDest()
 *)

PROCEDURE SetNormalDest (InvokeInst: ValueRef; B: BasicBlockRef; );


(**
 * Set the unwind destination basic block.
 *
 * Works on llvm::InvokeInst, llvm::CleanupReturnInst, and
 * llvm::CatchSwitchInst instructions.
 *
 * @see llvm::InvokeInst::setUnwindDest()
 * @see llvm::CleanupReturnInst::setUnwindDest()
 * @see llvm::CatchSwitchInst::setUnwindDest()
 *)

PROCEDURE SetUnwindDest (InvokeInst: ValueRef; B: BasicBlockRef; );


(**
 * Get the default destination of a CallBr instruction.
 *
 * @see llvm::CallBrInst::getDefaultDest()
 *)

PROCEDURE GetCallBrDefaultDest (CallBr: ValueRef; ): BasicBlockRef;


(**
 * Get the number of indirect destinations of a CallBr instruction.
 *
 * @see llvm::CallBrInst::getNumIndirectDests()
 *
 *)

PROCEDURE GetCallBrNumIndirectDests (CallBr: ValueRef; ): uint32_t;


(**
 * Get the indirect destination of a CallBr instruction at the given index.
 *
 * @see llvm::CallBrInst::getIndirectDest()
 *)

PROCEDURE GetCallBrIndirectDest (CallBr: ValueRef; Idx: uint32_t; ):
  BasicBlockRef;


(**
 * @}
 *
 * Return the number of successors that this terminator has.
 *
 * @see llvm::Instruction::getNumSuccessors
 *)

PROCEDURE GetNumSuccessors (Term: ValueRef; ): uint32_t;


(**
 * Return the specified successor.
 *
 * @see llvm::Instruction::getSuccessor
 *)

PROCEDURE GetSuccessor (Term: ValueRef; i: uint32_t; ): BasicBlockRef;


(**
 * Update the specified successor to point at the provided block.
 *
 * @see llvm::Instruction::setSuccessor
 *)

PROCEDURE SetSuccessor
  (Term: ValueRef; i: uint32_t; block: BasicBlockRef; );


(**
 * Return if a branch is conditional.
 *
 * This only works on llvm::BranchInst instructions.
 *
 * @see llvm::BranchInst::isConditional
 *)

PROCEDURE IsConditional (Branch: ValueRef; ): BOOLEAN;


(**
 * Return the condition of a branch instruction.
 *
 * This only works on llvm::BranchInst instructions.
 *
 * @see llvm::BranchInst::getCondition
 *)

PROCEDURE GetCondition (Branch: ValueRef; ): ValueRef;


(**
 * Set the condition of a branch instruction.
 *
 * This only works on llvm::BranchInst instructions.
 *
 * @see llvm::BranchInst::setCondition
 *)

PROCEDURE SetCondition (Branch, Cond: ValueRef; );


(**
 * Obtain the default destination basic block of a switch instruction.
 *
 * This only works on llvm::SwitchInst instructions.
 *
 * @see llvm::SwitchInst::getDefaultDest()
 *)

PROCEDURE GetSwitchDefaultDest (SwitchInstr: ValueRef; ): BasicBlockRef;


(**
 * @}
 *
 * Obtain the type that is being allocated by the alloca instruction.
 *)

PROCEDURE GetAllocatedType (Alloca: ValueRef; ): TypeRef;


(**
 * @}
 *
 * Check whether the given GEP operator is inbounds.
 *)

PROCEDURE IsInBounds (GEP: ValueRef; ): BOOLEAN;


(**
 * Set the given GEP instruction to be inbounds or not.
 *)

PROCEDURE SetIsInBounds (GEP: ValueRef; InBounds: BOOLEAN; );


(**
 * Get the source element type of the given GEP operator.
 *)

PROCEDURE GetGEPSourceElementType (GEP: ValueRef; ): TypeRef;


(**
 * Get the no-wrap related flags for the given GEP instruction.
 *
 * @see llvm::GetElementPtrInst::getNoWrapFlags
 *)

PROCEDURE GEPGetNoWrapFlags (GEP: ValueRef; ): uint32_t;


(**
 * Set the no-wrap related flags for the given GEP instruction.
 *
 * @see llvm::GetElementPtrInst::setNoWrapFlags
 *)

PROCEDURE GEPSetNoWrapFlags (GEP: ValueRef; NoWrapFlags: uint32_t; );


(**
 * @}
 *
 * Add an incoming value to the end of a PHI list.
 *)

PROCEDURE AddIncoming (PhiNode       : ValueRef;
                       IncomingValues: UNTRACED REF ValueRef;
                       IncomingBlocks: UNTRACED REF BasicBlockRef;
                       Count         : uint32_t;                   );


(**
 * Obtain the number of incoming basic blocks to a PHI node.
 *)

PROCEDURE CountIncoming (PhiNode: ValueRef; ): uint32_t;


(**
 * Obtain an incoming value to a PHI node as an LLVMValueRef.
 *)

PROCEDURE GetIncomingValue (PhiNode: ValueRef; Index: uint32_t; ):
  ValueRef;


(**
 * Obtain an incoming value to a PHI node as an LLVMBasicBlockRef.
 *)

PROCEDURE GetIncomingBlock (PhiNode: ValueRef; Index: uint32_t; ):
  BasicBlockRef;


(**
 * @}
 *
 * Obtain the number of indices.
 * NB: This also works on GEP operators.
 *)

PROCEDURE GetNumIndices (Inst: ValueRef; ): uint32_t;


(**
 * Obtain the indices as an array.
 *)

PROCEDURE GetIndices (Inst: ValueRef; ): UNTRACED REF uint32_t;


(**
 * @}
 *
 * @}
 *
 * @}
 *)

PROCEDURE CreateBuilderInContext (context: ContextRef; ): BuilderRef;

PROCEDURE CreateBuilder (): BuilderRef;


(**
 * Set the builder position before Instr but after any attached debug records,
 * or if Instr is null set the position to the end of Block.
 *)

PROCEDURE PositionBuilder
  (Builder: BuilderRef; Block: BasicBlockRef; Instr: ValueRef; );


(**
 * Set the builder position before Instr and any attached debug records,
 * or if Instr is null set the position to the end of Block.
 *)

PROCEDURE PositionBuilderBeforeDbgRecords
  (Builder: BuilderRef; Block: BasicBlockRef; Inst: ValueRef; );


(**
 * Set the builder position before Instr but after any attached debug records.
 *)

PROCEDURE PositionBuilderBefore (Builder: BuilderRef; Instr: ValueRef; );


(**
 * Set the builder position before Instr and any attached debug records.
 *)

PROCEDURE PositionBuilderBeforeInstrAndDbgRecords
  (Builder: BuilderRef; Instr: ValueRef; );

PROCEDURE PositionBuilderAtEnd
  (Builder: BuilderRef; Block: BasicBlockRef; );

PROCEDURE GetInsertBlock (Builder: BuilderRef; ): BasicBlockRef;

PROCEDURE ClearInsertionPosition (Builder: BuilderRef; );

PROCEDURE InsertIntoBuilder (Builder: BuilderRef; Instr: ValueRef; );

PROCEDURE InsertIntoBuilderWithName
  (Builder: BuilderRef; Instr: ValueRef; Name: TEXT; );

PROCEDURE DisposeBuilder (Builder: BuilderRef; );


(**
 * Get location information used by debugging information.
 *
 * @see llvm::IRBuilder::getCurrentDebugLocation()
 *)

PROCEDURE GetCurrentDebugLocation2 (Builder: BuilderRef; ): MetadataRef;


(**
 * Set location information used by debugging information.
 *
 * To clear the location metadata of the given instruction, pass NULL to \p Loc.
 *
 * @see llvm::IRBuilder::SetCurrentDebugLocation()
 *)

PROCEDURE SetCurrentDebugLocation2
  (Builder: BuilderRef; Loc: MetadataRef; );


(**
 * Attempts to set the debug location for the given instruction using the
 * current debug location for the given builder.  If the builder has no current
 * debug location, this function is a no-op.
 *
 * @deprecated LLVMSetInstDebugLocation is deprecated in favor of the more general
 *             LLVMAddMetadataToInst.
 *
 * @see llvm::IRBuilder::SetInstDebugLocation()
 *)

PROCEDURE SetInstDebugLocation (Builder: BuilderRef; Inst: ValueRef; );


(**
 * Adds the metadata registered with the given builder to the given instruction.
 *
 * @see llvm::IRBuilder::AddMetadataToInst()
 *)

PROCEDURE AddMetadataToInst (Builder: BuilderRef; Inst: ValueRef; );


(**
 * Get the dafult floating-point math metadata for a given builder.
 *
 * @see llvm::IRBuilder::getDefaultFPMathTag()
 *)

PROCEDURE BuilderGetDefaultFPMathTag (Builder: BuilderRef; ): MetadataRef;


(**
 * Set the default floating-point math metadata for the given builder.
 *
 * To clear the metadata, pass NULL to \p FPMathTag.
 *
 * @see llvm::IRBuilder::setDefaultFPMathTag()
 *)

PROCEDURE BuilderSetDefaultFPMathTag
  (Builder: BuilderRef; FPMathTag: MetadataRef; );


(**
 * Obtain the context to which this builder is associated.
 *
 * @see llvm::IRBuilder::getContext()
 *)

PROCEDURE GetBuilderContext (Builder: BuilderRef; ): ContextRef;


(**
 * Deprecated: Passing the NULL location will crash.
 * Use LLVMGetCurrentDebugLocation2 instead.
 *)

PROCEDURE SetCurrentDebugLocation (Builder: BuilderRef; L: ValueRef; );


(**
 * Deprecated: Returning the NULL location will crash.
 * Use LLVMGetCurrentDebugLocation2 instead.
 *)

PROCEDURE GetCurrentDebugLocation (Builder: BuilderRef; ): ValueRef;

PROCEDURE BuildRetVoid (arg1: BuilderRef; ): ValueRef;

PROCEDURE BuildRet (arg1: BuilderRef; V: ValueRef; ): ValueRef;

PROCEDURE BuildAggregateRet
  (arg1: BuilderRef; RetVals: UNTRACED REF ValueRef; N: uint32_t; ):
  ValueRef;

PROCEDURE BuildBr (arg1: BuilderRef; Dest: BasicBlockRef; ): ValueRef;

PROCEDURE BuildCondBr
  (arg1: BuilderRef; If: ValueRef; Then, Else: BasicBlockRef; ): ValueRef;

PROCEDURE BuildSwitch (arg1    : BuilderRef;
                       V       : ValueRef;
                       Else    : BasicBlockRef;
                       NumCases: uint32_t;      ): ValueRef;

PROCEDURE BuildIndirectBr
  (B: BuilderRef; Addr: ValueRef; NumDests: uint32_t; ): ValueRef;

PROCEDURE BuildCallBr (B               : BuilderRef;
                       Ty              : TypeRef;
                       Fn              : ValueRef;
                       DefaultDest     : BasicBlockRef;
                       IndirectDests   : UNTRACED REF BasicBlockRef;
                       NumIndirectDests: uint32_t;
                       Args            : UNTRACED REF ValueRef;
                       NumArgs         : uint32_t;
                       Bundles         : UNTRACED REF OperandBundleRef;
                       NumBundles      : uint32_t;
                       Name            : TEXT;                          ):
  ValueRef;

PROCEDURE BuildInvoke2 (arg1       : BuilderRef;
                        Ty         : TypeRef;
                        Fn         : ValueRef;
                        Args       : UNTRACED REF ValueRef;
                        NumArgs    : uint32_t;
                        Then, Catch: BasicBlockRef;
                        Name       : TEXT;                  ): ValueRef;

PROCEDURE BuildInvokeWithOperandBundles
  (arg1       : BuilderRef;
   Ty         : TypeRef;
   Fn         : ValueRef;
   Args       : UNTRACED REF ValueRef;
   NumArgs    : uint32_t;
   Then, Catch: BasicBlockRef;
   Bundles    : UNTRACED REF OperandBundleRef;
   NumBundles : uint32_t;
   Name       : TEXT;                          ): ValueRef;

PROCEDURE BuildUnreachable (arg1: BuilderRef; ): ValueRef;

PROCEDURE BuildResume (B: BuilderRef; Exn: ValueRef; ): ValueRef;

PROCEDURE BuildLandingPad (B         : BuilderRef;
                           Ty        : TypeRef;
                           PersFn    : ValueRef;
                           NumClauses: uint32_t;
                           Name      : TEXT;       ): ValueRef;

PROCEDURE BuildCleanupRet
  (B: BuilderRef; CatchPad: ValueRef; BB: BasicBlockRef; ): ValueRef;

PROCEDURE BuildCatchRet
  (B: BuilderRef; CatchPad: ValueRef; BB: BasicBlockRef; ): ValueRef;

PROCEDURE BuildCatchPad (B        : BuilderRef;
                         ParentPad: ValueRef;
                         Args     : UNTRACED REF ValueRef;
                         NumArgs  : uint32_t;
                         Name     : TEXT;                  ): ValueRef;

PROCEDURE BuildCleanupPad (B        : BuilderRef;
                           ParentPad: ValueRef;
                           Args     : UNTRACED REF ValueRef;
                           NumArgs  : uint32_t;
                           Name     : TEXT;                  ): ValueRef;

PROCEDURE BuildCatchSwitch (B          : BuilderRef;
                            ParentPad  : ValueRef;
                            UnwindBB   : BasicBlockRef;
                            NumHandlers: uint32_t;
                            Name       : TEXT;          ): ValueRef;

PROCEDURE AddCase (Switch, OnVal: ValueRef; Dest: BasicBlockRef; );

PROCEDURE AddDestination (IndirectBr: ValueRef; Dest: BasicBlockRef; );

PROCEDURE GetNumClauses (LandingPad: ValueRef; ): uint32_t;

PROCEDURE GetClause (LandingPad: ValueRef; Idx: uint32_t; ): ValueRef;

PROCEDURE AddClause (LandingPad, ClauseVal: ValueRef; );

PROCEDURE IsCleanup (LandingPad: ValueRef; ): BOOLEAN;

PROCEDURE SetCleanup (LandingPad: ValueRef; Val: BOOLEAN; );

PROCEDURE AddHandler (CatchSwitch: ValueRef; Dest: BasicBlockRef; );

PROCEDURE GetNumHandlers (CatchSwitch: ValueRef; ): uint32_t;


(**
 * Obtain the basic blocks acting as handlers for a catchswitch instruction.
 *
 * The Handlers parameter should point to a pre-allocated array of
 * LLVMBasicBlockRefs at least LLVMGetNumHandlers() large. On return, the
 * first LLVMGetNumHandlers() entries in the array will be populated
 * with LLVMBasicBlockRef instances.
 *
 * @param CatchSwitch The catchswitch instruction to operate on.
 * @param Handlers Memory address of an array to be filled with basic blocks.
 *)

PROCEDURE GetHandlers
  (CatchSwitch: ValueRef; Handlers: UNTRACED REF BasicBlockRef; );

PROCEDURE GetArgOperand (Funclet: ValueRef; i: uint32_t; ): ValueRef;

PROCEDURE SetArgOperand
  (Funclet: ValueRef; i: uint32_t; value: ValueRef; );


(**
 * Get the parent catchswitch instruction of a catchpad instruction.
 *
 * This only works on llvm::CatchPadInst instructions.
 *
 * @see llvm::CatchPadInst::getCatchSwitch()
 *)

PROCEDURE GetParentCatchSwitch (CatchPad: ValueRef; ): ValueRef;


(**
 * Set the parent catchswitch instruction of a catchpad instruction.
 *
 * This only works on llvm::CatchPadInst instructions.
 *
 * @see llvm::CatchPadInst::setCatchSwitch()
 *)

PROCEDURE SetParentCatchSwitch (CatchPad, CatchSwitch: ValueRef; );

PROCEDURE BuildAdd (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildNSWAdd (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildNUWAdd (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildFAdd (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildSub (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildNSWSub (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildNUWSub (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildFSub (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildMul (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildNSWMul (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildNUWMul (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildFMul (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildUDiv (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildExactUDiv
  (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ): ValueRef;

PROCEDURE BuildSDiv (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildExactSDiv
  (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ): ValueRef;

PROCEDURE BuildFDiv (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildURem (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildSRem (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildFRem (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildShl (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildLShr (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildAShr (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildAnd (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildOr (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildXor (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildBinOp
  (B: BuilderRef; Op: LLVMOpcode; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildNeg (arg1: BuilderRef; V: ValueRef; Name: TEXT; ): ValueRef;

PROCEDURE BuildNSWNeg (B: BuilderRef; V: ValueRef; Name: TEXT; ): ValueRef;

PROCEDURE BuildFNeg (arg1: BuilderRef; V: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildNot (arg1: BuilderRef; V: ValueRef; Name: TEXT; ): ValueRef;

PROCEDURE GetNUW (ArithInst: ValueRef; ): BOOLEAN;

PROCEDURE SetNUW (ArithInst: ValueRef; HasNUW: BOOLEAN; );

PROCEDURE GetNSW (ArithInst: ValueRef; ): BOOLEAN;

PROCEDURE SetNSW (ArithInst: ValueRef; HasNSW: BOOLEAN; );

PROCEDURE GetExact (DivOrShrInst: ValueRef; ): BOOLEAN;

PROCEDURE SetExact (DivOrShrInst: ValueRef; IsExact: BOOLEAN; );


(**
 * Gets if the instruction has the non-negative flag set.
 * Only valid for zext instructions.
 *)

PROCEDURE GetNNeg (NonNegInst: ValueRef; ): BOOLEAN;


(**
 * Sets the non-negative flag for the instruction.
 * Only valid for zext instructions.
 *)

PROCEDURE SetNNeg (NonNegInst: ValueRef; IsNonNeg: BOOLEAN; );


(**
 * Get the flags for which fast-math-style optimizations are allowed for this
 * value.
 *
 * Only valid on floating point instructions.
 * @see LLVMCanValueUseFastMathFlags
 *)

PROCEDURE GetFastMathFlags (FPMathInst: ValueRef; ): uint32_t;


(**
 * Sets the flags for which fast-math-style optimizations are allowed for this
 * value.
 *
 * Only valid on floating point instructions.
 * @see LLVMCanValueUseFastMathFlags
 *)

PROCEDURE SetFastMathFlags (FPMathInst: ValueRef; FMF: uint32_t; );


(**
 * Check if a given value can potentially have fast math flags.
 *
 * Will return true for floating point arithmetic instructions, and for select,
 * phi, and call instructions whose type is a floating point type, or a vector
 * or array thereof. See https://llvm.org/docs/LangRef.html#fast-math-flags
 *)

PROCEDURE CanValueUseFastMathFlags (Inst: ValueRef; ): BOOLEAN;


(**
 * Gets whether the instruction has the disjoint flag set.
 * Only valid for or instructions.
 *)

PROCEDURE GetIsDisjoint (Inst: ValueRef; ): BOOLEAN;


(**
 * Sets the disjoint flag for the instruction.
 * Only valid for or instructions.
 *)

PROCEDURE SetIsDisjoint (Inst: ValueRef; IsDisjoint: BOOLEAN; );

PROCEDURE BuildMalloc (arg1: BuilderRef; Ty: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildArrayMalloc
  (arg1: BuilderRef; Ty: TypeRef; Val: ValueRef; Name: TEXT; ): ValueRef;


(**
 * Creates and inserts a memset to the specified pointer and the
 * specified value.
 *
 * @see llvm::IRRBuilder::CreateMemSet()
 *)

PROCEDURE BuildMemSet
  (B: BuilderRef; Ptr, Val, Len: ValueRef; Align: uint32_t; ): ValueRef;


(**
 * Creates and inserts a memcpy between the specified pointers.
 *
 * @see llvm::IRRBuilder::CreateMemCpy()
 *)

PROCEDURE BuildMemCpy (B       : BuilderRef;
                       Dst     : ValueRef;
                       DstAlign: uint32_t;
                       Src     : ValueRef;
                       SrcAlign: uint32_t;
                       Size    : ValueRef;   ): ValueRef;


(**
 * Creates and inserts a memmove between the specified pointers.
 *
 * @see llvm::IRRBuilder::CreateMemMove()
 *)

PROCEDURE BuildMemMove (B       : BuilderRef;
                        Dst     : ValueRef;
                        DstAlign: uint32_t;
                        Src     : ValueRef;
                        SrcAlign: uint32_t;
                        Size    : ValueRef;   ): ValueRef;

PROCEDURE BuildAlloca (arg1: BuilderRef; Ty: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildArrayAlloca
  (arg1: BuilderRef; Ty: TypeRef; Val: ValueRef; Name: TEXT; ): ValueRef;

PROCEDURE BuildFree (arg1: BuilderRef; PointerVal: ValueRef; ): ValueRef;

PROCEDURE BuildLoad2
  (arg1: BuilderRef; Ty: TypeRef; PointerVal: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildStore (arg1: BuilderRef; Val, Ptr: ValueRef; ): ValueRef;

PROCEDURE BuildGEP2 (B         : BuilderRef;
                     Ty        : TypeRef;
                     Pointer   : ValueRef;
                     Indices   : UNTRACED REF ValueRef;
                     NumIndices: uint32_t;
                     Name      : TEXT;                  ): ValueRef;

PROCEDURE BuildInBoundsGEP2 (B         : BuilderRef;
                             Ty        : TypeRef;
                             Pointer   : ValueRef;
                             Indices   : UNTRACED REF ValueRef;
                             NumIndices: uint32_t;
                             Name      : TEXT;                  ):
  ValueRef;


(**
 * Creates a GetElementPtr instruction. Similar to LLVMBuildGEP2, but allows
 * specifying the no-wrap flags.
 *
 * @see llvm::IRBuilder::CreateGEP()
 *)

PROCEDURE BuildGEPWithNoWrapFlags (B          : BuilderRef;
                                   Ty         : TypeRef;
                                   Pointer    : ValueRef;
                                   Indices    : UNTRACED REF ValueRef;
                                   NumIndices : uint32_t;
                                   Name       : TEXT;
                                   NoWrapFlags: uint32_t;              ):
  ValueRef;

PROCEDURE BuildStructGEP2 (B      : BuilderRef;
                           Ty     : TypeRef;
                           Pointer: ValueRef;
                           Idx    : uint32_t;
                           Name   : TEXT;       ): ValueRef;

PROCEDURE BuildGlobalString (B: BuilderRef; Str, Name: TEXT; ): ValueRef;


(**
 * Deprecated: Use LLVMBuildGlobalString instead, which has identical behavior.
 *)

PROCEDURE BuildGlobalStringPtr (B: BuilderRef; Str, Name: TEXT; ):
  ValueRef;

PROCEDURE GetVolatile (Inst: ValueRef; ): BOOLEAN;

PROCEDURE SetVolatile (MemoryAccessInst: ValueRef; IsVolatile: BOOLEAN; );

PROCEDURE GetWeak (CmpXchgInst: ValueRef; ): BOOLEAN;

PROCEDURE SetWeak (CmpXchgInst: ValueRef; IsWeak: BOOLEAN; );

PROCEDURE GetOrdering (MemoryAccessInst: ValueRef; ): LLVMAtomicOrdering;

PROCEDURE SetOrdering
  (MemoryAccessInst: ValueRef; Ordering: LLVMAtomicOrdering; );

PROCEDURE GetAtomicRMWBinOp (AtomicRMWInst: ValueRef; ):
  LLVMAtomicRMWBinOp;

PROCEDURE SetAtomicRMWBinOp
  (AtomicRMWInst: ValueRef; BinOp: LLVMAtomicRMWBinOp; );

PROCEDURE BuildTrunc
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildZExt
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildSExt
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildFPToUI
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildFPToSI
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildUIToFP
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildSIToFP
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildFPTrunc
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildFPExt
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildPtrToInt
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildIntToPtr
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildBitCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildAddrSpaceCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildZExtOrBitCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildSExtOrBitCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildTruncOrBitCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildCast (B     : BuilderRef;
                     Op    : LLVMOpcode;
                     Val   : ValueRef;
                     DestTy: TypeRef;
                     Name  : TEXT;       ): ValueRef;

PROCEDURE BuildPointerCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildIntCast2 (arg1    : BuilderRef;
                         Val     : ValueRef;
                         DestTy  : TypeRef;
                         IsSigned: BOOLEAN;
                         Name    : TEXT;       ): ValueRef;

PROCEDURE BuildFPCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;


(** Deprecated: This cast is always signed. Use LLVMBuildIntCast2 instead. *)

PROCEDURE BuildIntCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef;

PROCEDURE GetCastOpcode (Src         : ValueRef;
                         SrcIsSigned : BOOLEAN;
                         DestTy      : TypeRef;
                         DestIsSigned: BOOLEAN;  ): LLVMOpcode;

PROCEDURE BuildICmp (arg1    : BuilderRef;
                     Op      : LLVMIntPredicate;
                     LHS, RHS: ValueRef;
                     Name    : TEXT;             ): ValueRef;

PROCEDURE BuildFCmp (arg1    : BuilderRef;
                     Op      : LLVMRealPredicate;
                     LHS, RHS: ValueRef;
                     Name    : TEXT;              ): ValueRef;

PROCEDURE BuildPhi (arg1: BuilderRef; Ty: TypeRef; Name: TEXT; ): ValueRef;

PROCEDURE BuildCall2 (arg1   : BuilderRef;
                      arg2   : TypeRef;
                      Fn     : ValueRef;
                      Args   : UNTRACED REF ValueRef;
                      NumArgs: uint32_t;
                      Name   : TEXT;                  ): ValueRef;

PROCEDURE BuildCallWithOperandBundles
  (arg1      : BuilderRef;
   arg2      : TypeRef;
   Fn        : ValueRef;
   Args      : UNTRACED REF ValueRef;
   NumArgs   : uint32_t;
   Bundles   : UNTRACED REF OperandBundleRef;
   NumBundles: uint32_t;
   Name      : TEXT;                          ): ValueRef;

PROCEDURE BuildSelect
  (arg1: BuilderRef; If, Then, Else: ValueRef; Name: TEXT; ): ValueRef;

PROCEDURE BuildVAArg
  (arg1: BuilderRef; List: ValueRef; Ty: TypeRef; Name: TEXT; ): ValueRef;

PROCEDURE BuildExtractElement
  (arg1: BuilderRef; VecVal, Index: ValueRef; Name: TEXT; ): ValueRef;

PROCEDURE BuildInsertElement
  (arg1: BuilderRef; VecVal, EltVal, Index: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildShuffleVector
  (arg1: BuilderRef; V1, V2, Mask: ValueRef; Name: TEXT; ): ValueRef;

PROCEDURE BuildExtractValue
  (arg1: BuilderRef; AggVal: ValueRef; Index: uint32_t; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildInsertValue (arg1          : BuilderRef;
                            AggVal, EltVal: ValueRef;
                            Index         : uint32_t;
                            Name          : TEXT;       ): ValueRef;

PROCEDURE BuildFreeze (arg1: BuilderRef; Val: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildIsNull (arg1: BuilderRef; Val: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildIsNotNull (arg1: BuilderRef; Val: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildPtrDiff2
  (arg1: BuilderRef; ElemTy: TypeRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef;

PROCEDURE BuildFence (B           : BuilderRef;
                      ordering    : LLVMAtomicOrdering;
                      singleThread: BOOLEAN;
                      Name        : TEXT;               ): ValueRef;

PROCEDURE BuildFenceSyncScope (B       : BuilderRef;
                               ordering: LLVMAtomicOrdering;
                               SSID    : uint32_t;
                               Name    : TEXT;               ): ValueRef;

PROCEDURE BuildAtomicRMW (B           : BuilderRef;
                          op          : LLVMAtomicRMWBinOp;
                          PTR, Val    : ValueRef;
                          ordering    : LLVMAtomicOrdering;
                          singleThread: BOOLEAN;            ): ValueRef;

PROCEDURE BuildAtomicRMWSyncScope (B       : BuilderRef;
                                   op      : LLVMAtomicRMWBinOp;
                                   PTR, Val: ValueRef;
                                   ordering: LLVMAtomicOrdering;
                                   SSID    : uint32_t;           ):
  ValueRef;

PROCEDURE BuildAtomicCmpXchg
  (B                               : BuilderRef;
   Ptr, Cmp, New                   : ValueRef;
   SuccessOrdering, FailureOrdering: LLVMAtomicOrdering;
   SingleThread                    : BOOLEAN;            ): ValueRef;

PROCEDURE BuildAtomicCmpXchgSyncScope
  (B                               : BuilderRef;
   Ptr, Cmp, New                   : ValueRef;
   SuccessOrdering, FailureOrdering: LLVMAtomicOrdering;
   SSID                            : uint32_t;           ): ValueRef;


(**
 * Get the number of elements in the mask of a ShuffleVector instruction.
 *)

PROCEDURE GetNumMaskElements (ShuffleVectorInst: ValueRef; ): uint32_t;


(**
 * \returns a constant that specifies that the result of a \c ShuffleVectorInst
 * is undefined.
 *)

PROCEDURE GetUndefMaskElem (): INTEGER;


(**
 * Get the mask value at position Elt in the mask of a ShuffleVector
 * instruction.
 *
 * \Returns the result of \c LLVMGetUndefMaskElem() if the mask value is
 * poison at that position.
 *)

PROCEDURE GetMaskValue (ShuffleVectorInst: ValueRef; Elt: uint32_t; ):
  INTEGER;

PROCEDURE IsAtomicSingleThread (AtomicInst: ValueRef; ): BOOLEAN;

PROCEDURE SetAtomicSingleThread
  (AtomicInst: ValueRef; SingleThread: BOOLEAN; );


(**
 * Returns whether an instruction is an atomic instruction, e.g., atomicrmw,
 * cmpxchg, fence, or loads and stores with atomic ordering.
 *)

PROCEDURE IsAtomic (Inst: ValueRef; ): BOOLEAN;


(**
 * Returns the synchronization scope ID of an atomic instruction.
 *)

PROCEDURE GetAtomicSyncScopeID (AtomicInst: ValueRef; ): uint32_t;


(**
 * Sets the synchronization scope ID of an atomic instruction.
 *)

PROCEDURE SetAtomicSyncScopeID (AtomicInst: ValueRef; SSID: uint32_t; );

PROCEDURE GetCmpXchgSuccessOrdering (CmpXchgInst: ValueRef; ):
  LLVMAtomicOrdering;

PROCEDURE SetCmpXchgSuccessOrdering
  (CmpXchgInst: ValueRef; Ordering: LLVMAtomicOrdering; );

PROCEDURE GetCmpXchgFailureOrdering (CmpXchgInst: ValueRef; ):
  LLVMAtomicOrdering;

PROCEDURE SetCmpXchgFailureOrdering
  (CmpXchgInst: ValueRef; Ordering: LLVMAtomicOrdering; );


(**
 * @}
 *
 * Changes the type of M so it can be passed to FunctionPassManagers and the
 * JIT.  They take ModuleProviders for historical reasons.
 *)

PROCEDURE CreateModuleProviderForExistingModule (M: ModuleRef; ):
  ModuleProviderRef;


(**
 * Destroys the module M.
 *)

PROCEDURE DisposeModuleProvider (M: ModuleProviderRef; );


(**
 * @}
 *)

PROCEDURE CreateMemoryBufferWithContentsOfFile
  (    Path      : TEXT;
       OutMemBuf : UNTRACED REF MemoryBufferRef;
   VAR OutMessage: TEXT;                         ): BOOLEAN;

PROCEDURE CreateMemoryBufferWithSTDIN
  (OutMemBuf: UNTRACED REF MemoryBufferRef; VAR OutMessage: TEXT; ):
  BOOLEAN;

PROCEDURE CreateMemoryBufferWithMemoryRange
  (InputData             : TEXT;
   InputDataLength       : Word.T;
   BufferName            : TEXT;
   RequiresNullTerminator: BOOLEAN; ): MemoryBufferRef;

PROCEDURE CreateMemoryBufferWithMemoryRangeCopy
  (InputData: TEXT; InputDataLength: Word.T; BufferName: TEXT; ):
  MemoryBufferRef;

PROCEDURE GetBufferStart (MemBuf: MemoryBufferRef; ): TEXT;

PROCEDURE GetBufferSize (MemBuf: MemoryBufferRef; ): Word.T;

PROCEDURE DisposeMemoryBuffer (MemBuf: MemoryBufferRef; );


(**
 * @}
  * Constructs a new whole-module pass pipeline. This type of pipeline is
    * suitable for link-time optimization and whole-module transformations.
    * @see llvm::PassManager::PassManager
 *)

PROCEDURE CreatePassManager (): PassManagerRef;


(** Constructs a new function-by-function pass pipeline over the module
    * provider. It does not take ownership of the module provider. This type of
    * pipeline is suitable for code generation and JIT compilation tasks.
    * @see llvm::FunctionPassManager::FunctionPassManager
    *)

PROCEDURE CreateFunctionPassManagerForModule (M: ModuleRef; ):
  PassManagerRef;


(** Deprecated: Use LLVMCreateFunctionPassManagerForModule instead. *)

PROCEDURE CreateFunctionPassManager (MP: ModuleProviderRef; ):
  PassManagerRef;


(** Initializes, executes on the provided module, and finalizes all of the
    * passes scheduled in the pass manager. Returns 1 if any of the passes
    * modified the module, 0 otherwise.
    * @see llvm::PassManager::run(Module&)
    *)

PROCEDURE RunPassManager (PM: PassManagerRef; M: ModuleRef; ): BOOLEAN;


(** Initializes all of the function passes scheduled in the function pass
    * manager. Returns 1 if any of the passes modified the module, 0 otherwise.
    * @see llvm::FunctionPassManager::doInitialization
    *)

PROCEDURE InitializeFunctionPassManager (FPM: PassManagerRef; ): BOOLEAN;


(** Executes all of the function passes scheduled in the function pass manager
    * on the provided function. Returns 1 if any of the passes modified the
    * function, false otherwise.
    * @see llvm::FunctionPassManager::run(Function&)
    *)

PROCEDURE RunFunctionPassManager (FPM: PassManagerRef; F: ValueRef; ):
  BOOLEAN;


(** Finalizes all of the function passes scheduled in the function pass
    * manager. Returns 1 if any of the passes modified the module, 0 otherwise.
    * @see llvm::FunctionPassManager::doFinalization
    *)

PROCEDURE FinalizeFunctionPassManager (FPM: PassManagerRef; ): BOOLEAN;


(** Frees the memory of a pass pipeline. For function pipelines, does not free
    * the module provider.
    * @see llvm::PassManagerBase::~PassManagerBase.
    *)

PROCEDURE DisposePassManager (PM: PassManagerRef; );


(**
 * @}
  * Deprecated: Multi-threading can only be enabled/disabled with the compile
    * time define LLVM_ENABLE_THREADS.  This function always returns
    * LLVMIsMultithreaded().
 *)

PROCEDURE StartMultithreaded (): BOOLEAN;


(** Deprecated: Multi-threading can only be enabled/disabled with the compile
    * time define LLVM_ENABLE_THREADS.
    *)

PROCEDURE StopMultithreaded ();


(** Check whether LLVM is executing in thread-safe mode or not.
    * @see llvm::llvm_is_multithreaded
    *)

PROCEDURE IsMultithreaded (): BOOLEAN;


(** Writes a module to the specified path. Returns 0 on success. *)

PROCEDURE WriteBitcodeToFile (M: ModuleRef; Path: TEXT; ): INTEGER;


(** Writes a module to an open file descriptor. Returns 0 on success. *)

PROCEDURE WriteBitcodeToFD
  (M: ModuleRef; FD, ShouldClose, Unbuffered: INTEGER; ): INTEGER;


(** Deprecated for LLVMWriteBitcodeToFD. Writes a module to an open file
    * descriptor. Returns 0 on success. Closes the Handle.
    *)

PROCEDURE WriteBitcodeToFileHandle (M: ModuleRef; Handle: INTEGER; ):
  INTEGER;


(** Writes a module to a new memory buffer and returns it. *)

PROCEDURE WriteBitcodeToMemoryBuffer (M: ModuleRef; ): MemoryBufferRef;


TYPE LLVMByteOrdering = {LLVMBigEndian, LLVMLittleEndian};


(**
 * Obtain the data layout for a module.
 *
 * @see Module::getDataLayout()
 *)

PROCEDURE GetModuleDataLayout (M: ModuleRef; ): TargetDataRef;


(**
 * Set the data layout for a module.
 *
 * @see Module::setDataLayout()
 *)

PROCEDURE SetModuleDataLayout (M: ModuleRef; DL: TargetDataRef; );


(** Creates target data from a target layout string.
    * See the constructor llvm::DataLayout::DataLayout.
    *)

PROCEDURE CreateTargetData (StringRep: TEXT; ): TargetDataRef;


(** Deallocates a TargetData.
    * See the destructor llvm::DataLayout::~DataLayout.
    *)

PROCEDURE DisposeTargetData (TD: TargetDataRef; );


(** Adds target library information to a pass manager. This does not take
    * ownership of the target library info.
    * See the method llvm::PassManagerBase::add.
    *)

PROCEDURE AddTargetLibraryInfo
  (TLI: TargetLibraryInfoRef; PM: PassManagerRef; );


(** Converts target data to a target layout string. The string must be disposed
    * with LLVMDisposeMessage.
    * See the constructor llvm::DataLayout::DataLayout.
    *)

PROCEDURE CopyStringRepOfTargetData (TD: TargetDataRef; ): TEXT;


(** Returns the byte order of a target, either LLVMBigEndian or
    * LLVMLittleEndian.
    * See the method llvm::DataLayout::isLittleEndian.
    *)

PROCEDURE ByteOrder (TD: TargetDataRef; ): uint32_t;


(** Returns the pointer size in bytes for a target.
    * See the method llvm::DataLayout::getPointerSize.
    *)

PROCEDURE PointerSize (TD: TargetDataRef; ): uint32_t;


(** Returns the integer type that is the same size as a pointer on a target.
    * See the method llvm::DataLayout::getIntPtrType.
    *)

PROCEDURE IntPtrType (TD: TargetDataRef; ): TypeRef;


(** Returns the integer type that is the same size as a pointer on a target.
    * See the method llvm::DataLayout::getIntPtrType.
    *)

PROCEDURE IntPtrTypeInContext (context: ContextRef; TD: TargetDataRef; ):
  TypeRef;


(** Computes the size of a type in bits for a target.
    * See the method llvm::DataLayout::getTypeSizeInBits.
    *)

PROCEDURE SizeOfTypeInBits (TD: TargetDataRef; Ty: TypeRef; ): uint64_t;


(** Computes the storage size of a type in bytes for a target.
    * See the method llvm::DataLayout::getTypeStoreSize.
    *)

PROCEDURE StoreSizeOfType (TD: TargetDataRef; Ty: TypeRef; ): uint64_t;


(** Computes the ABI size of a type in bytes for a target.
    * See the method llvm::DataLayout::getTypeAllocSize.
    *)

PROCEDURE ABISizeOfType (TD: TargetDataRef; Ty: TypeRef; ): uint64_t;


(** Computes the ABI alignment of a type in bytes for a target.
    * See the method llvm::DataLayout::getTypeABISize.
    *)

PROCEDURE ABIAlignmentOfType (TD: TargetDataRef; Ty: TypeRef; ): uint32_t;


(** Computes the call frame alignment of a type in bytes for a target.
    * See the method llvm::DataLayout::getTypeABISize.
    *)

PROCEDURE CallFrameAlignmentOfType (TD: TargetDataRef; Ty: TypeRef; ):
  uint32_t;


(** Computes the preferred alignment of a type in bytes for a target.
    * See the method llvm::DataLayout::getTypeABISize.
    *)

PROCEDURE PreferredAlignmentOfType (TD: TargetDataRef; Ty: TypeRef; ):
  uint32_t;


(** Computes the preferred alignment of a global variable in bytes for a target.
    * See the method llvm::DataLayout::getPreferredAlignment.
    *)

PROCEDURE PreferredAlignmentOfGlobal
  (TD: TargetDataRef; GlobalVar: ValueRef; ): uint32_t;


(** Computes the structure element that contains the byte offset for a target.
    * See the method llvm::StructLayout::getElementContainingOffset.
    *)

PROCEDURE ElementAtOffset
  (TD: TargetDataRef; StructTy: TypeRef; Offset: uint64_t; ): uint32_t;


(** Computes the byte offset of the indexed struct element for a target.
    * See the method llvm::StructLayout::getElementContainingOffset.
    *)

PROCEDURE OffsetOfElement
  (TD: TargetDataRef; StructTy: TypeRef; Element: uint32_t; ): uint64_t;


END LLVM.
