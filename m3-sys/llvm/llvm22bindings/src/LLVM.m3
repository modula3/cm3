(*******************************************************************************
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.4.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
*******************************************************************************)

UNSAFE MODULE LLVM;


IMPORT LLVMRaw;
IMPORT Ctypes AS C;
IMPORT M3toC;


IMPORT Word;

PROCEDURE Shutdown () =
  BEGIN
    LLVMRaw.Shutdown();
  END Shutdown;

PROCEDURE GetVersion (VAR Major, Minor, Patch: uint32_t; ) =
  BEGIN
    LLVMRaw.GetVersion(Major, Minor, Patch);
  END GetVersion;

PROCEDURE CreateMessage (Message: TEXT; ): TEXT =
  VAR
    result: C.char_star;
    arg1  : C.char_star;
  BEGIN
    arg1 := M3toC.SharedTtoS(Message);
    result := LLVMRaw.CreateMessage(arg1);
    M3toC.FreeSharedS(Message, arg1);
    RETURN M3toC.CopyStoT(result);
  END CreateMessage;

PROCEDURE DisposeMessage (Message: TEXT; ) =
  VAR arg1: C.char_star;
  BEGIN
    arg1 := M3toC.SharedTtoS(Message);
    LLVMRaw.DisposeMessage(arg1);
    M3toC.FreeSharedS(Message, arg1);
  END DisposeMessage;

PROCEDURE ContextCreate (): ContextRef =
  BEGIN
    RETURN LLVMRaw.ContextCreate();
  END ContextCreate;

PROCEDURE GetGlobalContext (): ContextRef =
  BEGIN
    RETURN LLVMRaw.GetGlobalContext();
  END GetGlobalContext;

PROCEDURE ContextSetDiagnosticHandler (context: ContextRef;
                                       Handler: DiagnosticHandler;
                                       DiagnosticContext: ADDRESS; ) =
  VAR arg2: ADDRESS;
  BEGIN
    arg2 := LOOPHOLE(Handler, ADDRESS);
    LLVMRaw.ContextSetDiagnosticHandler(context, arg2, DiagnosticContext);
  END ContextSetDiagnosticHandler;

PROCEDURE ContextGetDiagnosticHandler (context: ContextRef; ):
  DiagnosticHandler =
  VAR ret: ADDRESS;
  BEGIN
    ret := LLVMRaw.ContextGetDiagnosticHandler(context);
    RETURN LOOPHOLE(ret, DiagnosticHandler);
  END ContextGetDiagnosticHandler;

PROCEDURE ContextGetDiagnosticContext (context: ContextRef; ): ADDRESS =
  BEGIN
    RETURN LLVMRaw.ContextGetDiagnosticContext(context);
  END ContextGetDiagnosticContext;

PROCEDURE ContextSetYieldCallback
  (context: ContextRef; Callback: YieldCallback; OpaqueHandle: ADDRESS; ) =
  VAR arg2: ADDRESS;
  BEGIN
    arg2 := LOOPHOLE(Callback, ADDRESS);
    LLVMRaw.ContextSetYieldCallback(context, arg2, OpaqueHandle);
  END ContextSetYieldCallback;

PROCEDURE ContextShouldDiscardValueNames (context: ContextRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.ContextShouldDiscardValueNames(context);
  END ContextShouldDiscardValueNames;

PROCEDURE ContextSetDiscardValueNames
  (context: ContextRef; Discard: BOOLEAN; ) =
  BEGIN
    LLVMRaw.ContextSetDiscardValueNames(context, Discard);
  END ContextSetDiscardValueNames;

PROCEDURE ContextDispose (context: ContextRef; ) =
  BEGIN
    LLVMRaw.ContextDispose(context);
  END ContextDispose;

PROCEDURE GetDiagInfoDescription (DI: DiagnosticInfoRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetDiagInfoDescription(DI);
    RETURN M3toC.CopyStoT(result);
  END GetDiagInfoDescription;

PROCEDURE GetDiagInfoSeverity (DI: DiagnosticInfoRef; ):
  LLVMDiagnosticSeverity =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetDiagInfoSeverity(DI);
    RETURN VAL(ret, LLVMDiagnosticSeverity);
  END GetDiagInfoSeverity;

PROCEDURE GetMDKindIDInContext
  (context: ContextRef; Name: TEXT; SLen: uint32_t; ): uint32_t =
  VAR
    arg2  : C.char_star;
    result: uint32_t;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetMDKindIDInContext(context, arg2, SLen);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END GetMDKindIDInContext;

PROCEDURE GetMDKindID (Name: TEXT; SLen: uint32_t; ): uint32_t =
  VAR
    arg1  : C.char_star;
    result: uint32_t;
  BEGIN
    arg1 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetMDKindID(arg1, SLen);
    M3toC.FreeSharedS(Name, arg1);
    RETURN result;
  END GetMDKindID;

PROCEDURE GetSyncScopeID (context: ContextRef; Name: TEXT; SLen: Word.T; ):
  uint32_t =
  VAR
    arg2  : C.char_star;
    result: uint32_t;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetSyncScopeID(context, arg2, SLen);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END GetSyncScopeID;

PROCEDURE GetEnumAttributeKindForName (Name: TEXT; SLen: Word.T; ):
  uint32_t =
  VAR
    arg1  : C.char_star;
    result: uint32_t;
  BEGIN
    arg1 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetEnumAttributeKindForName(arg1, SLen);
    M3toC.FreeSharedS(Name, arg1);
    RETURN result;
  END GetEnumAttributeKindForName;

PROCEDURE GetLastEnumAttributeKind (): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetLastEnumAttributeKind();
  END GetLastEnumAttributeKind;

PROCEDURE CreateEnumAttribute
  (context: ContextRef; KindID: uint32_t; Val: uint64_t; ): AttributeRef =
  BEGIN
    RETURN LLVMRaw.CreateEnumAttribute(context, KindID, Val);
  END CreateEnumAttribute;

PROCEDURE GetEnumAttributeKind (A: AttributeRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetEnumAttributeKind(A);
  END GetEnumAttributeKind;

PROCEDURE GetEnumAttributeValue (A: AttributeRef; ): uint64_t =
  BEGIN
    RETURN LLVMRaw.GetEnumAttributeValue(A);
  END GetEnumAttributeValue;

PROCEDURE CreateTypeAttribute
  (context: ContextRef; KindID: uint32_t; type_ref: TypeRef; ):
  AttributeRef =
  BEGIN
    RETURN LLVMRaw.CreateTypeAttribute(context, KindID, type_ref);
  END CreateTypeAttribute;

PROCEDURE GetTypeAttributeValue (A: AttributeRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.GetTypeAttributeValue(A);
  END GetTypeAttributeValue;

PROCEDURE CreateConstantRangeAttribute
  (context               : ContextRef;
   KindID, NumBits       : uint32_t;
   LowerWords, UpperWords: REF ARRAY OF uint64_t; ): AttributeRef =
  BEGIN
    RETURN LLVMRaw.CreateConstantRangeAttribute(
             context, KindID, NumBits, LowerWords, UpperWords);
  END CreateConstantRangeAttribute;

PROCEDURE CreateStringAttribute (context: ContextRef;
                                 K      : TEXT;
                                 KLength: uint32_t;
                                 V      : TEXT;
                                 VLength: uint32_t;   ): AttributeRef =
  VAR
    arg2  : C.char_star;
    arg4  : C.char_star;
    result: AttributeRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(K);
    arg4 := M3toC.SharedTtoS(V);
    result :=
      LLVMRaw.CreateStringAttribute(context, arg2, KLength, arg4, VLength);
    M3toC.FreeSharedS(K, arg2);
    M3toC.FreeSharedS(V, arg4);
    RETURN result;
  END CreateStringAttribute;

PROCEDURE GetStringAttributeKind (A: AttributeRef; VAR Length: uint32_t; ):
  TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetStringAttributeKind(A, Length);
    RETURN M3toC.CopyStoT(result);
  END GetStringAttributeKind;

PROCEDURE GetStringAttributeValue
  (A: AttributeRef; VAR Length: uint32_t; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetStringAttributeValue(A, Length);
    RETURN M3toC.CopyStoT(result);
  END GetStringAttributeValue;

PROCEDURE IsEnumAttribute (A: AttributeRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsEnumAttribute(A);
  END IsEnumAttribute;

PROCEDURE IsStringAttribute (A: AttributeRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsStringAttribute(A);
  END IsStringAttribute;

PROCEDURE IsTypeAttribute (A: AttributeRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsTypeAttribute(A);
  END IsTypeAttribute;

PROCEDURE GetTypeByName2 (context: ContextRef; Name: TEXT; ): TypeRef =
  VAR
    arg2  : C.char_star;
    result: TypeRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetTypeByName2(context, arg2);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END GetTypeByName2;

PROCEDURE ModuleCreateWithName (ModuleID: TEXT; ): ModuleRef =
  VAR
    arg1  : C.char_star;
    result: ModuleRef;
  BEGIN
    arg1 := M3toC.SharedTtoS(ModuleID);
    result := LLVMRaw.ModuleCreateWithName(arg1);
    M3toC.FreeSharedS(ModuleID, arg1);
    RETURN result;
  END ModuleCreateWithName;

PROCEDURE ModuleCreateWithNameInContext
  (ModuleID: TEXT; context: ContextRef; ): ModuleRef =
  VAR
    arg1  : C.char_star;
    result: ModuleRef;
  BEGIN
    arg1 := M3toC.SharedTtoS(ModuleID);
    result := LLVMRaw.ModuleCreateWithNameInContext(arg1, context);
    M3toC.FreeSharedS(ModuleID, arg1);
    RETURN result;
  END ModuleCreateWithNameInContext;

PROCEDURE CloneModule (M: ModuleRef; ): ModuleRef =
  BEGIN
    RETURN LLVMRaw.CloneModule(M);
  END CloneModule;

PROCEDURE DisposeModule (M: ModuleRef; ) =
  BEGIN
    LLVMRaw.DisposeModule(M);
  END DisposeModule;

PROCEDURE IsNewDbgInfoFormat (M: ModuleRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsNewDbgInfoFormat(M);
  END IsNewDbgInfoFormat;

PROCEDURE SetIsNewDbgInfoFormat (M: ModuleRef; UseNewFormat: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetIsNewDbgInfoFormat(M, UseNewFormat);
  END SetIsNewDbgInfoFormat;

PROCEDURE GetModuleIdentifier (M: ModuleRef; VAR Len: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetModuleIdentifier(M, Len);
    RETURN M3toC.CopyStoT(result);
  END GetModuleIdentifier;

PROCEDURE SetModuleIdentifier (M: ModuleRef; Ident: TEXT; Len: Word.T; ) =
  VAR arg2: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(Ident);
    LLVMRaw.SetModuleIdentifier(M, arg2, Len);
    M3toC.FreeSharedS(Ident, arg2);
  END SetModuleIdentifier;

PROCEDURE GetSourceFileName (M: ModuleRef; VAR Len: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetSourceFileName(M, Len);
    RETURN M3toC.CopyStoT(result);
  END GetSourceFileName;

PROCEDURE SetSourceFileName (M: ModuleRef; Name: TEXT; Len: Word.T; ) =
  VAR arg2: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    LLVMRaw.SetSourceFileName(M, arg2, Len);
    M3toC.FreeSharedS(Name, arg2);
  END SetSourceFileName;

PROCEDURE GetDataLayoutStr (M: ModuleRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetDataLayoutStr(M);
    RETURN M3toC.CopyStoT(result);
  END GetDataLayoutStr;

PROCEDURE GetDataLayout (M: ModuleRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetDataLayout(M);
    RETURN M3toC.CopyStoT(result);
  END GetDataLayout;

PROCEDURE SetDataLayout (M: ModuleRef; DataLayoutStr: TEXT; ) =
  VAR arg2: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(DataLayoutStr);
    LLVMRaw.SetDataLayout(M, arg2);
    M3toC.FreeSharedS(DataLayoutStr, arg2);
  END SetDataLayout;

PROCEDURE GetTarget (M: ModuleRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetTarget(M);
    RETURN M3toC.CopyStoT(result);
  END GetTarget;

PROCEDURE SetTarget (M: ModuleRef; Triple: TEXT; ) =
  VAR arg2: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(Triple);
    LLVMRaw.SetTarget(M, arg2);
    M3toC.FreeSharedS(Triple, arg2);
  END SetTarget;

PROCEDURE CopyModuleFlagsMetadata (M: ModuleRef; VAR Len: Word.T; ):
  UNTRACED REF ModuleFlagEntry =
  BEGIN
    RETURN LLVMRaw.CopyModuleFlagsMetadata(M, Len);
  END CopyModuleFlagsMetadata;

PROCEDURE DisposeModuleFlagsMetadata
  (Entries: UNTRACED REF ModuleFlagEntry; ) =
  BEGIN
    LLVMRaw.DisposeModuleFlagsMetadata(Entries);
  END DisposeModuleFlagsMetadata;

PROCEDURE ModuleFlagEntriesGetFlagBehavior
  (Entries: UNTRACED REF ModuleFlagEntry; Index: uint32_t; ):
  LLVMModuleFlagBehavior =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.ModuleFlagEntriesGetFlagBehavior(Entries, Index);
    RETURN VAL(ret, LLVMModuleFlagBehavior);
  END ModuleFlagEntriesGetFlagBehavior;

PROCEDURE ModuleFlagEntriesGetKey (Entries: UNTRACED REF ModuleFlagEntry;
                                   Index  : uint32_t;
                                   VAR Len: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.ModuleFlagEntriesGetKey(Entries, Index, Len);
    RETURN M3toC.CopyStoT(result);
  END ModuleFlagEntriesGetKey;

PROCEDURE ModuleFlagEntriesGetMetadata
  (Entries: UNTRACED REF ModuleFlagEntry; Index: uint32_t; ): MetadataRef =
  BEGIN
    RETURN LLVMRaw.ModuleFlagEntriesGetMetadata(Entries, Index);
  END ModuleFlagEntriesGetMetadata;

PROCEDURE GetModuleFlag (M: ModuleRef; Key: TEXT; KeyLen: Word.T; ):
  MetadataRef =
  VAR
    arg2  : C.char_star;
    result: MetadataRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Key);
    result := LLVMRaw.GetModuleFlag(M, arg2, KeyLen);
    M3toC.FreeSharedS(Key, arg2);
    RETURN result;
  END GetModuleFlag;

PROCEDURE AddModuleFlag (M       : ModuleRef;
                         Behavior: LLVMModuleFlagBehavior;
                         Key     : TEXT;
                         KeyLen  : Word.T;
                         Val     : MetadataRef;            ) =
  VAR
    arg2tmp: C.int;
    arg3   : C.char_star;
  BEGIN
    arg2tmp := ORD(Behavior);
    arg3 := M3toC.SharedTtoS(Key);
    LLVMRaw.AddModuleFlag(M, arg2tmp, arg3, KeyLen, Val);
    M3toC.FreeSharedS(Key, arg3);
  END AddModuleFlag;

PROCEDURE DumpModule (M: ModuleRef; ) =
  BEGIN
    LLVMRaw.DumpModule(M);
  END DumpModule;

PROCEDURE PrintModuleToFile
  (M: ModuleRef; Filename: TEXT; VAR ErrorMessage: TEXT; ): BOOLEAN =
  VAR
    arg2  : C.char_star;
    arg3  : C.char_star;
    result: BOOLEAN;
  BEGIN
    arg2 := M3toC.SharedTtoS(Filename);
    arg3 := M3toC.SharedTtoS(ErrorMessage);
    result := LLVMRaw.PrintModuleToFile(M, arg2, arg3);
    M3toC.FreeSharedS(Filename, arg2);
    M3toC.FreeSharedS(ErrorMessage, arg3);
    RETURN result;
  END PrintModuleToFile;

PROCEDURE PrintModuleToString (M: ModuleRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.PrintModuleToString(M);
    RETURN M3toC.CopyStoT(result);
  END PrintModuleToString;

PROCEDURE GetModuleInlineAsm (M: ModuleRef; VAR Len: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetModuleInlineAsm(M, Len);
    RETURN M3toC.CopyStoT(result);
  END GetModuleInlineAsm;

PROCEDURE SetModuleInlineAsm2 (M: ModuleRef; Asm: TEXT; Len: Word.T; ) =
  VAR arg2: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(Asm);
    LLVMRaw.SetModuleInlineAsm2(M, arg2, Len);
    M3toC.FreeSharedS(Asm, arg2);
  END SetModuleInlineAsm2;

PROCEDURE AppendModuleInlineAsm (M: ModuleRef; Asm: TEXT; Len: Word.T; ) =
  VAR arg2: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(Asm);
    LLVMRaw.AppendModuleInlineAsm(M, arg2, Len);
    M3toC.FreeSharedS(Asm, arg2);
  END AppendModuleInlineAsm;

PROCEDURE GetInlineAsm (Ty                          : TypeRef;
                        AsmString                   : TEXT;
                        AsmStringSize               : Word.T;
                        Constraints                 : TEXT;
                        ConstraintsSize             : Word.T;
                        HasSideEffects, IsAlignStack: BOOLEAN;
                        Dialect : LLVMInlineAsmDialect;
                        CanThrow: BOOLEAN;              ): ValueRef =
  VAR
    arg2   : C.char_star;
    arg4   : C.char_star;
    arg8tmp: C.int;
    result : ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(AsmString);
    arg4 := M3toC.SharedTtoS(Constraints);
    arg8tmp := ORD(Dialect);
    result := LLVMRaw.GetInlineAsm(
                Ty, arg2, AsmStringSize, arg4, ConstraintsSize,
                HasSideEffects, IsAlignStack, arg8tmp, CanThrow);
    M3toC.FreeSharedS(AsmString, arg2);
    M3toC.FreeSharedS(Constraints, arg4);
    RETURN result;
  END GetInlineAsm;

PROCEDURE GetInlineAsmAsmString
  (InlineAsmVal: ValueRef; VAR Len: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetInlineAsmAsmString(InlineAsmVal, Len);
    RETURN M3toC.CopyStoT(result);
  END GetInlineAsmAsmString;

PROCEDURE GetInlineAsmConstraintString
  (InlineAsmVal: ValueRef; VAR Len: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetInlineAsmConstraintString(InlineAsmVal, Len);
    RETURN M3toC.CopyStoT(result);
  END GetInlineAsmConstraintString;

PROCEDURE GetInlineAsmDialect (InlineAsmVal: ValueRef; ):
  LLVMInlineAsmDialect =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetInlineAsmDialect(InlineAsmVal);
    RETURN VAL(ret, LLVMInlineAsmDialect);
  END GetInlineAsmDialect;

PROCEDURE GetInlineAsmFunctionType (InlineAsmVal: ValueRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.GetInlineAsmFunctionType(InlineAsmVal);
  END GetInlineAsmFunctionType;

PROCEDURE GetInlineAsmHasSideEffects (InlineAsmVal: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.GetInlineAsmHasSideEffects(InlineAsmVal);
  END GetInlineAsmHasSideEffects;

PROCEDURE GetInlineAsmNeedsAlignedStack (InlineAsmVal: ValueRef; ):
  BOOLEAN =
  BEGIN
    RETURN LLVMRaw.GetInlineAsmNeedsAlignedStack(InlineAsmVal);
  END GetInlineAsmNeedsAlignedStack;

PROCEDURE GetInlineAsmCanUnwind (InlineAsmVal: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.GetInlineAsmCanUnwind(InlineAsmVal);
  END GetInlineAsmCanUnwind;

PROCEDURE GetModuleContext (M: ModuleRef; ): ContextRef =
  BEGIN
    RETURN LLVMRaw.GetModuleContext(M);
  END GetModuleContext;

PROCEDURE GetTypeByName (M: ModuleRef; Name: TEXT; ): TypeRef =
  VAR
    arg2  : C.char_star;
    result: TypeRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetTypeByName(M, arg2);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END GetTypeByName;

PROCEDURE GetFirstNamedMetadata (M: ModuleRef; ): NamedMDNodeRef =
  BEGIN
    RETURN LLVMRaw.GetFirstNamedMetadata(M);
  END GetFirstNamedMetadata;

PROCEDURE GetLastNamedMetadata (M: ModuleRef; ): NamedMDNodeRef =
  BEGIN
    RETURN LLVMRaw.GetLastNamedMetadata(M);
  END GetLastNamedMetadata;

PROCEDURE GetNextNamedMetadata (NamedMDNode: NamedMDNodeRef; ):
  NamedMDNodeRef =
  BEGIN
    RETURN LLVMRaw.GetNextNamedMetadata(NamedMDNode);
  END GetNextNamedMetadata;

PROCEDURE GetPreviousNamedMetadata (NamedMDNode: NamedMDNodeRef; ):
  NamedMDNodeRef =
  BEGIN
    RETURN LLVMRaw.GetPreviousNamedMetadata(NamedMDNode);
  END GetPreviousNamedMetadata;

PROCEDURE GetNamedMetadata (M: ModuleRef; Name: TEXT; NameLen: Word.T; ):
  NamedMDNodeRef =
  VAR
    arg2  : C.char_star;
    result: NamedMDNodeRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetNamedMetadata(M, arg2, NameLen);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END GetNamedMetadata;

PROCEDURE GetOrInsertNamedMetadata
  (M: ModuleRef; Name: TEXT; NameLen: Word.T; ): NamedMDNodeRef =
  VAR
    arg2  : C.char_star;
    result: NamedMDNodeRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetOrInsertNamedMetadata(M, arg2, NameLen);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END GetOrInsertNamedMetadata;

PROCEDURE GetNamedMetadataName
  (NamedMD: NamedMDNodeRef; VAR NameLen: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetNamedMetadataName(NamedMD, NameLen);
    RETURN M3toC.CopyStoT(result);
  END GetNamedMetadataName;

PROCEDURE GetNamedMetadataNumOperands (M: ModuleRef; Name: TEXT; ):
  uint32_t =
  VAR
    arg2  : C.char_star;
    result: uint32_t;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetNamedMetadataNumOperands(M, arg2);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END GetNamedMetadataNumOperands;

PROCEDURE GetNamedMetadataOperands
  (M: ModuleRef; Name: TEXT; Dest: UNTRACED REF ValueRef; ) =
  VAR arg2: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    LLVMRaw.GetNamedMetadataOperands(M, arg2, Dest);
    M3toC.FreeSharedS(Name, arg2);
  END GetNamedMetadataOperands;

PROCEDURE AddNamedMetadataOperand
  (M: ModuleRef; Name: TEXT; Val: ValueRef; ) =
  VAR arg2: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    LLVMRaw.AddNamedMetadataOperand(M, arg2, Val);
    M3toC.FreeSharedS(Name, arg2);
  END AddNamedMetadataOperand;

PROCEDURE GetDebugLocDirectory (Val: ValueRef; VAR Length: uint32_t; ):
  TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetDebugLocDirectory(Val, Length);
    RETURN M3toC.CopyStoT(result);
  END GetDebugLocDirectory;

PROCEDURE GetDebugLocFilename (Val: ValueRef; VAR Length: uint32_t; ):
  TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetDebugLocFilename(Val, Length);
    RETURN M3toC.CopyStoT(result);
  END GetDebugLocFilename;

PROCEDURE GetDebugLocLine (Val: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetDebugLocLine(Val);
  END GetDebugLocLine;

PROCEDURE GetDebugLocColumn (Val: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetDebugLocColumn(Val);
  END GetDebugLocColumn;

PROCEDURE AddFunction (M: ModuleRef; Name: TEXT; FunctionTy: TypeRef; ):
  ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.AddFunction(M, arg2, FunctionTy);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END AddFunction;

PROCEDURE GetNamedFunction (M: ModuleRef; Name: TEXT; ): ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetNamedFunction(M, arg2);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END GetNamedFunction;

PROCEDURE GetNamedFunctionWithLength
  (M: ModuleRef; Name: TEXT; Length: Word.T; ): ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetNamedFunctionWithLength(M, arg2, Length);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END GetNamedFunctionWithLength;

PROCEDURE GetFirstFunction (M: ModuleRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetFirstFunction(M);
  END GetFirstFunction;

PROCEDURE GetLastFunction (M: ModuleRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetLastFunction(M);
  END GetLastFunction;

PROCEDURE GetNextFunction (Fn: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetNextFunction(Fn);
  END GetNextFunction;

PROCEDURE GetPreviousFunction (Fn: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetPreviousFunction(Fn);
  END GetPreviousFunction;

PROCEDURE SetModuleInlineAsm (M: ModuleRef; Asm: TEXT; ) =
  VAR arg2: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(Asm);
    LLVMRaw.SetModuleInlineAsm(M, arg2);
    M3toC.FreeSharedS(Asm, arg2);
  END SetModuleInlineAsm;

PROCEDURE GetTypeKind (Ty: TypeRef; ): TypeKindRef =
  BEGIN
    RETURN LLVMRaw.GetTypeKind(Ty);
  END GetTypeKind;

PROCEDURE TypeIsSized (Ty: TypeRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.TypeIsSized(Ty);
  END TypeIsSized;

PROCEDURE GetTypeContext (Ty: TypeRef; ): ContextRef =
  BEGIN
    RETURN LLVMRaw.GetTypeContext(Ty);
  END GetTypeContext;

PROCEDURE DumpType (Val: TypeRef; ) =
  BEGIN
    LLVMRaw.DumpType(Val);
  END DumpType;

PROCEDURE PrintTypeToString (Val: TypeRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.PrintTypeToString(Val);
    RETURN M3toC.CopyStoT(result);
  END PrintTypeToString;

PROCEDURE Int1TypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.Int1TypeInContext(context);
  END Int1TypeInContext;

PROCEDURE Int8TypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.Int8TypeInContext(context);
  END Int8TypeInContext;

PROCEDURE Int16TypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.Int16TypeInContext(context);
  END Int16TypeInContext;

PROCEDURE Int32TypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.Int32TypeInContext(context);
  END Int32TypeInContext;

PROCEDURE Int64TypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.Int64TypeInContext(context);
  END Int64TypeInContext;

PROCEDURE Int128TypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.Int128TypeInContext(context);
  END Int128TypeInContext;

PROCEDURE IntTypeInContext (context: ContextRef; NumBits: uint32_t; ):
  TypeRef =
  BEGIN
    RETURN LLVMRaw.IntTypeInContext(context, NumBits);
  END IntTypeInContext;

PROCEDURE Int1Type (): TypeRef =
  BEGIN
    RETURN LLVMRaw.Int1Type();
  END Int1Type;

PROCEDURE Int8Type (): TypeRef =
  BEGIN
    RETURN LLVMRaw.Int8Type();
  END Int8Type;

PROCEDURE Int16Type (): TypeRef =
  BEGIN
    RETURN LLVMRaw.Int16Type();
  END Int16Type;

PROCEDURE Int32Type (): TypeRef =
  BEGIN
    RETURN LLVMRaw.Int32Type();
  END Int32Type;

PROCEDURE Int64Type (): TypeRef =
  BEGIN
    RETURN LLVMRaw.Int64Type();
  END Int64Type;

PROCEDURE Int128Type (): TypeRef =
  BEGIN
    RETURN LLVMRaw.Int128Type();
  END Int128Type;

PROCEDURE IntType (NumBits: uint32_t; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.IntType(NumBits);
  END IntType;

PROCEDURE GetIntTypeWidth (IntegerTy: TypeRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetIntTypeWidth(IntegerTy);
  END GetIntTypeWidth;

PROCEDURE HalfTypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.HalfTypeInContext(context);
  END HalfTypeInContext;

PROCEDURE BFloatTypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.BFloatTypeInContext(context);
  END BFloatTypeInContext;

PROCEDURE FloatTypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.FloatTypeInContext(context);
  END FloatTypeInContext;

PROCEDURE DoubleTypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.DoubleTypeInContext(context);
  END DoubleTypeInContext;

PROCEDURE X86FP80TypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.X86FP80TypeInContext(context);
  END X86FP80TypeInContext;

PROCEDURE FP128TypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.FP128TypeInContext(context);
  END FP128TypeInContext;

PROCEDURE PPCFP128TypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.PPCFP128TypeInContext(context);
  END PPCFP128TypeInContext;

PROCEDURE HalfType (): TypeRef =
  BEGIN
    RETURN LLVMRaw.HalfType();
  END HalfType;

PROCEDURE BFloatType (): TypeRef =
  BEGIN
    RETURN LLVMRaw.BFloatType();
  END BFloatType;

PROCEDURE FloatType (): TypeRef =
  BEGIN
    RETURN LLVMRaw.FloatType();
  END FloatType;

PROCEDURE DoubleType (): TypeRef =
  BEGIN
    RETURN LLVMRaw.DoubleType();
  END DoubleType;

PROCEDURE X86FP80Type (): TypeRef =
  BEGIN
    RETURN LLVMRaw.X86FP80Type();
  END X86FP80Type;

PROCEDURE FP128Type (): TypeRef =
  BEGIN
    RETURN LLVMRaw.FP128Type();
  END FP128Type;

PROCEDURE PPCFP128Type (): TypeRef =
  BEGIN
    RETURN LLVMRaw.PPCFP128Type();
  END PPCFP128Type;

PROCEDURE FunctionType (ReturnType: TypeRef;
                        ParamTypes: UNTRACED REF TypeRef;
                        ParamCount: uint32_t;
                        IsVarArg  : BOOLEAN;              ): TypeRef =
  BEGIN
    RETURN
      LLVMRaw.FunctionType(ReturnType, ParamTypes, ParamCount, IsVarArg);
  END FunctionType;

PROCEDURE IsFunctionVarArg (FunctionTy: TypeRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsFunctionVarArg(FunctionTy);
  END IsFunctionVarArg;

PROCEDURE GetReturnType (FunctionTy: TypeRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.GetReturnType(FunctionTy);
  END GetReturnType;

PROCEDURE CountParamTypes (FunctionTy: TypeRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.CountParamTypes(FunctionTy);
  END CountParamTypes;

PROCEDURE GetParamTypes
  (FunctionTy: TypeRef; Dest: UNTRACED REF TypeRef; ) =
  BEGIN
    LLVMRaw.GetParamTypes(FunctionTy, Dest);
  END GetParamTypes;

PROCEDURE StructTypeInContext (context     : ContextRef;
                               ElementTypes: UNTRACED REF TypeRef;
                               ElementCount: uint32_t;
                               Packed      : BOOLEAN;              ):
  TypeRef =
  BEGIN
    RETURN LLVMRaw.StructTypeInContext(
             context, ElementTypes, ElementCount, Packed);
  END StructTypeInContext;

PROCEDURE StructType (ElementTypes: UNTRACED REF TypeRef;
                      ElementCount: uint32_t;
                      Packed      : BOOLEAN;              ): TypeRef =
  BEGIN
    RETURN LLVMRaw.StructType(ElementTypes, ElementCount, Packed);
  END StructType;

PROCEDURE StructCreateNamed (context: ContextRef; Name: TEXT; ): TypeRef =
  VAR
    arg2  : C.char_star;
    result: TypeRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.StructCreateNamed(context, arg2);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END StructCreateNamed;

PROCEDURE GetStructName (Ty: TypeRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetStructName(Ty);
    RETURN M3toC.CopyStoT(result);
  END GetStructName;

PROCEDURE StructSetBody (StructTy    : TypeRef;
                         ElementTypes: UNTRACED REF TypeRef;
                         ElementCount: uint32_t;
                         Packed      : BOOLEAN;              ) =
  BEGIN
    LLVMRaw.StructSetBody(StructTy, ElementTypes, ElementCount, Packed);
  END StructSetBody;

PROCEDURE CountStructElementTypes (StructTy: TypeRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.CountStructElementTypes(StructTy);
  END CountStructElementTypes;

PROCEDURE GetStructElementTypes
  (StructTy: TypeRef; Dest: UNTRACED REF TypeRef; ) =
  BEGIN
    LLVMRaw.GetStructElementTypes(StructTy, Dest);
  END GetStructElementTypes;

PROCEDURE StructGetTypeAtIndex (StructTy: TypeRef; i: uint32_t; ):
  TypeRef =
  BEGIN
    RETURN LLVMRaw.StructGetTypeAtIndex(StructTy, i);
  END StructGetTypeAtIndex;

PROCEDURE IsPackedStruct (StructTy: TypeRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsPackedStruct(StructTy);
  END IsPackedStruct;

PROCEDURE IsOpaqueStruct (StructTy: TypeRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsOpaqueStruct(StructTy);
  END IsOpaqueStruct;

PROCEDURE IsLiteralStruct (StructTy: TypeRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsLiteralStruct(StructTy);
  END IsLiteralStruct;

PROCEDURE GetElementType (Ty: TypeRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.GetElementType(Ty);
  END GetElementType;

PROCEDURE GetSubtypes (Tp: TypeRef; Arr: UNTRACED REF TypeRef; ) =
  BEGIN
    LLVMRaw.GetSubtypes(Tp, Arr);
  END GetSubtypes;

PROCEDURE GetNumContainedTypes (Tp: TypeRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetNumContainedTypes(Tp);
  END GetNumContainedTypes;

PROCEDURE ArrayType (ElementType: TypeRef; ElementCount: uint32_t; ):
  TypeRef =
  BEGIN
    RETURN LLVMRaw.ArrayType(ElementType, ElementCount);
  END ArrayType;

PROCEDURE ArrayType2 (ElementType: TypeRef; ElementCount: uint64_t; ):
  TypeRef =
  BEGIN
    RETURN LLVMRaw.ArrayType2(ElementType, ElementCount);
  END ArrayType2;

PROCEDURE GetArrayLength (ArrayTy: TypeRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetArrayLength(ArrayTy);
  END GetArrayLength;

PROCEDURE GetArrayLength2 (ArrayTy: TypeRef; ): uint64_t =
  BEGIN
    RETURN LLVMRaw.GetArrayLength2(ArrayTy);
  END GetArrayLength2;

PROCEDURE PointerType
  (ElementType: TypeRef; AddressSpace: uint32_t := 0; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.PointerType(ElementType, AddressSpace);
  END PointerType;

PROCEDURE PointerTypeIsOpaque (Ty: TypeRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.PointerTypeIsOpaque(Ty);
  END PointerTypeIsOpaque;

PROCEDURE PointerTypeInContext
  (context: ContextRef; AddressSpace: uint32_t := 0; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.PointerTypeInContext(context, AddressSpace);
  END PointerTypeInContext;

PROCEDURE GetPointerAddressSpace (PointerTy: TypeRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetPointerAddressSpace(PointerTy);
  END GetPointerAddressSpace;

PROCEDURE VectorType (ElementType: TypeRef; ElementCount: uint32_t; ):
  TypeRef =
  BEGIN
    RETURN LLVMRaw.VectorType(ElementType, ElementCount);
  END VectorType;

PROCEDURE ScalableVectorType
  (ElementType: TypeRef; ElementCount: uint32_t; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.ScalableVectorType(ElementType, ElementCount);
  END ScalableVectorType;

PROCEDURE GetVectorSize (VectorTy: TypeRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetVectorSize(VectorTy);
  END GetVectorSize;

PROCEDURE GetConstantPtrAuthPointer (PtrAuth: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetConstantPtrAuthPointer(PtrAuth);
  END GetConstantPtrAuthPointer;

PROCEDURE GetConstantPtrAuthKey (PtrAuth: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetConstantPtrAuthKey(PtrAuth);
  END GetConstantPtrAuthKey;

PROCEDURE GetConstantPtrAuthDiscriminator (PtrAuth: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetConstantPtrAuthDiscriminator(PtrAuth);
  END GetConstantPtrAuthDiscriminator;

PROCEDURE GetConstantPtrAuthAddrDiscriminator (PtrAuth: ValueRef; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.GetConstantPtrAuthAddrDiscriminator(PtrAuth);
  END GetConstantPtrAuthAddrDiscriminator;

PROCEDURE VoidTypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.VoidTypeInContext(context);
  END VoidTypeInContext;

PROCEDURE LabelTypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.LabelTypeInContext(context);
  END LabelTypeInContext;

PROCEDURE X86AMXTypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.X86AMXTypeInContext(context);
  END X86AMXTypeInContext;

PROCEDURE TokenTypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.TokenTypeInContext(context);
  END TokenTypeInContext;

PROCEDURE MetadataTypeInContext (context: ContextRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.MetadataTypeInContext(context);
  END MetadataTypeInContext;

PROCEDURE VoidType (): TypeRef =
  BEGIN
    RETURN LLVMRaw.VoidType();
  END VoidType;

PROCEDURE LabelType (): TypeRef =
  BEGIN
    RETURN LLVMRaw.LabelType();
  END LabelType;

PROCEDURE X86AMXType (): TypeRef =
  BEGIN
    RETURN LLVMRaw.X86AMXType();
  END X86AMXType;

PROCEDURE TargetExtTypeInContext (context       : ContextRef;
                                  Name          : TEXT;
                                  TypeParams    : UNTRACED REF TypeRef;
                                  TypeParamCount: uint32_t;
                                  VAR IntParams    : uint32_t;
                                      IntParamCount: uint32_t; ): TypeRef =
  VAR
    arg2  : C.char_star;
    result: TypeRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.TargetExtTypeInContext(
                context, arg2, TypeParams, TypeParamCount, IntParams,
                IntParamCount);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END TargetExtTypeInContext;

PROCEDURE GetTargetExtTypeName (TargetExtTy: TypeRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetTargetExtTypeName(TargetExtTy);
    RETURN M3toC.CopyStoT(result);
  END GetTargetExtTypeName;

PROCEDURE GetTargetExtTypeNumTypeParams (TargetExtTy: TypeRef; ):
  uint32_t =
  BEGIN
    RETURN LLVMRaw.GetTargetExtTypeNumTypeParams(TargetExtTy);
  END GetTargetExtTypeNumTypeParams;

PROCEDURE GetTargetExtTypeTypeParam
  (TargetExtTy: TypeRef; Idx: uint32_t; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.GetTargetExtTypeTypeParam(TargetExtTy, Idx);
  END GetTargetExtTypeTypeParam;

PROCEDURE GetTargetExtTypeNumIntParams (TargetExtTy: TypeRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetTargetExtTypeNumIntParams(TargetExtTy);
  END GetTargetExtTypeNumIntParams;

PROCEDURE GetTargetExtTypeIntParam (TargetExtTy: TypeRef; Idx: uint32_t; ):
  uint32_t =
  BEGIN
    RETURN LLVMRaw.GetTargetExtTypeIntParam(TargetExtTy, Idx);
  END GetTargetExtTypeIntParam;

PROCEDURE TypeOf (Val: ValueRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.TypeOf(Val);
  END TypeOf;

PROCEDURE GetValueKind (Val: ValueRef; ): LLVMValueKind =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetValueKind(Val);
    RETURN VAL(ret, LLVMValueKind);
  END GetValueKind;

PROCEDURE GetValueName2 (Val: ValueRef; VAR Length: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetValueName2(Val, Length);
    RETURN M3toC.CopyStoT(result);
  END GetValueName2;

PROCEDURE SetValueName2 (Val: ValueRef; Name: TEXT; NameLen: Word.T; ) =
  VAR arg2: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    LLVMRaw.SetValueName2(Val, arg2, NameLen);
    M3toC.FreeSharedS(Name, arg2);
  END SetValueName2;

PROCEDURE DumpValue (Val: ValueRef; ) =
  BEGIN
    LLVMRaw.DumpValue(Val);
  END DumpValue;

PROCEDURE PrintValueToString (Val: ValueRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.PrintValueToString(Val);
    RETURN M3toC.CopyStoT(result);
  END PrintValueToString;

PROCEDURE GetValueContext (Val: ValueRef; ): ContextRef =
  BEGIN
    RETURN LLVMRaw.GetValueContext(Val);
  END GetValueContext;

PROCEDURE PrintDbgRecordToString (Record: DbgRecordRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.PrintDbgRecordToString(Record);
    RETURN M3toC.CopyStoT(result);
  END PrintDbgRecordToString;

PROCEDURE ReplaceAllUsesWith (OldVal, NewVal: ValueRef; ) =
  BEGIN
    LLVMRaw.ReplaceAllUsesWith(OldVal, NewVal);
  END ReplaceAllUsesWith;

PROCEDURE IsConstant (Val: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsConstant(Val);
  END IsConstant;

PROCEDURE IsUndef (Val: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsUndef(Val);
  END IsUndef;

PROCEDURE IsPoison (Val: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsPoison(Val);
  END IsPoison;

PROCEDURE IsAArgument (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAArgument(Val);
  END IsAArgument;

PROCEDURE IsABasicBlock (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsABasicBlock(Val);
  END IsABasicBlock;

PROCEDURE IsAInlineAsm (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAInlineAsm(Val);
  END IsAInlineAsm;

PROCEDURE IsAUser (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAUser(Val);
  END IsAUser;

PROCEDURE IsAConstant (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstant(Val);
  END IsAConstant;

PROCEDURE IsABlockAddress (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsABlockAddress(Val);
  END IsABlockAddress;

PROCEDURE IsAConstantAggregateZero (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstantAggregateZero(Val);
  END IsAConstantAggregateZero;

PROCEDURE IsAConstantArray (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstantArray(Val);
  END IsAConstantArray;

PROCEDURE IsAConstantDataSequential (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstantDataSequential(Val);
  END IsAConstantDataSequential;

PROCEDURE IsAConstantDataArray (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstantDataArray(Val);
  END IsAConstantDataArray;

PROCEDURE IsAConstantDataVector (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstantDataVector(Val);
  END IsAConstantDataVector;

PROCEDURE IsAConstantExpr (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstantExpr(Val);
  END IsAConstantExpr;

PROCEDURE IsAConstantFP (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstantFP(Val);
  END IsAConstantFP;

PROCEDURE IsAConstantInt (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstantInt(Val);
  END IsAConstantInt;

PROCEDURE IsAConstantPointerNull (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstantPointerNull(Val);
  END IsAConstantPointerNull;

PROCEDURE IsAConstantStruct (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstantStruct(Val);
  END IsAConstantStruct;

PROCEDURE IsAConstantTokenNone (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstantTokenNone(Val);
  END IsAConstantTokenNone;

PROCEDURE IsAConstantVector (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstantVector(Val);
  END IsAConstantVector;

PROCEDURE IsAConstantPtrAuth (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAConstantPtrAuth(Val);
  END IsAConstantPtrAuth;

PROCEDURE IsAGlobalValue (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAGlobalValue(Val);
  END IsAGlobalValue;

PROCEDURE IsAGlobalAlias (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAGlobalAlias(Val);
  END IsAGlobalAlias;

PROCEDURE IsAGlobalObject (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAGlobalObject(Val);
  END IsAGlobalObject;

PROCEDURE IsAFunction (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAFunction(Val);
  END IsAFunction;

PROCEDURE IsAGlobalVariable (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAGlobalVariable(Val);
  END IsAGlobalVariable;

PROCEDURE IsAGlobalIFunc (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAGlobalIFunc(Val);
  END IsAGlobalIFunc;

PROCEDURE IsAUndefValue (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAUndefValue(Val);
  END IsAUndefValue;

PROCEDURE IsAPoisonValue (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAPoisonValue(Val);
  END IsAPoisonValue;

PROCEDURE IsAInstruction (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAInstruction(Val);
  END IsAInstruction;

PROCEDURE IsAUnaryOperator (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAUnaryOperator(Val);
  END IsAUnaryOperator;

PROCEDURE IsABinaryOperator (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsABinaryOperator(Val);
  END IsABinaryOperator;

PROCEDURE IsACallInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsACallInst(Val);
  END IsACallInst;

PROCEDURE IsAIntrinsicInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAIntrinsicInst(Val);
  END IsAIntrinsicInst;

PROCEDURE IsADbgInfoIntrinsic (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsADbgInfoIntrinsic(Val);
  END IsADbgInfoIntrinsic;

PROCEDURE IsADbgVariableIntrinsic (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsADbgVariableIntrinsic(Val);
  END IsADbgVariableIntrinsic;

PROCEDURE IsADbgDeclareInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsADbgDeclareInst(Val);
  END IsADbgDeclareInst;

PROCEDURE IsADbgLabelInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsADbgLabelInst(Val);
  END IsADbgLabelInst;

PROCEDURE IsAMemIntrinsic (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAMemIntrinsic(Val);
  END IsAMemIntrinsic;

PROCEDURE IsAMemCpyInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAMemCpyInst(Val);
  END IsAMemCpyInst;

PROCEDURE IsAMemMoveInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAMemMoveInst(Val);
  END IsAMemMoveInst;

PROCEDURE IsAMemSetInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAMemSetInst(Val);
  END IsAMemSetInst;

PROCEDURE IsACmpInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsACmpInst(Val);
  END IsACmpInst;

PROCEDURE IsAFCmpInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAFCmpInst(Val);
  END IsAFCmpInst;

PROCEDURE IsAICmpInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAICmpInst(Val);
  END IsAICmpInst;

PROCEDURE IsAExtractElementInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAExtractElementInst(Val);
  END IsAExtractElementInst;

PROCEDURE IsAGetElementPtrInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAGetElementPtrInst(Val);
  END IsAGetElementPtrInst;

PROCEDURE IsAInsertElementInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAInsertElementInst(Val);
  END IsAInsertElementInst;

PROCEDURE IsAInsertValueInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAInsertValueInst(Val);
  END IsAInsertValueInst;

PROCEDURE IsALandingPadInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsALandingPadInst(Val);
  END IsALandingPadInst;

PROCEDURE IsAPHINode (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAPHINode(Val);
  END IsAPHINode;

PROCEDURE IsASelectInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsASelectInst(Val);
  END IsASelectInst;

PROCEDURE IsAShuffleVectorInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAShuffleVectorInst(Val);
  END IsAShuffleVectorInst;

PROCEDURE IsAStoreInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAStoreInst(Val);
  END IsAStoreInst;

PROCEDURE IsABranchInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsABranchInst(Val);
  END IsABranchInst;

PROCEDURE IsAIndirectBrInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAIndirectBrInst(Val);
  END IsAIndirectBrInst;

PROCEDURE IsAInvokeInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAInvokeInst(Val);
  END IsAInvokeInst;

PROCEDURE IsAReturnInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAReturnInst(Val);
  END IsAReturnInst;

PROCEDURE IsASwitchInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsASwitchInst(Val);
  END IsASwitchInst;

PROCEDURE IsAUnreachableInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAUnreachableInst(Val);
  END IsAUnreachableInst;

PROCEDURE IsAResumeInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAResumeInst(Val);
  END IsAResumeInst;

PROCEDURE IsACleanupReturnInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsACleanupReturnInst(Val);
  END IsACleanupReturnInst;

PROCEDURE IsACatchReturnInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsACatchReturnInst(Val);
  END IsACatchReturnInst;

PROCEDURE IsACatchSwitchInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsACatchSwitchInst(Val);
  END IsACatchSwitchInst;

PROCEDURE IsACallBrInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsACallBrInst(Val);
  END IsACallBrInst;

PROCEDURE IsAFuncletPadInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAFuncletPadInst(Val);
  END IsAFuncletPadInst;

PROCEDURE IsACatchPadInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsACatchPadInst(Val);
  END IsACatchPadInst;

PROCEDURE IsACleanupPadInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsACleanupPadInst(Val);
  END IsACleanupPadInst;

PROCEDURE IsAUnaryInstruction (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAUnaryInstruction(Val);
  END IsAUnaryInstruction;

PROCEDURE IsAAllocaInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAAllocaInst(Val);
  END IsAAllocaInst;

PROCEDURE IsACastInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsACastInst(Val);
  END IsACastInst;

PROCEDURE IsAAddrSpaceCastInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAAddrSpaceCastInst(Val);
  END IsAAddrSpaceCastInst;

PROCEDURE IsABitCastInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsABitCastInst(Val);
  END IsABitCastInst;

PROCEDURE IsAFPExtInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAFPExtInst(Val);
  END IsAFPExtInst;

PROCEDURE IsAFPToSIInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAFPToSIInst(Val);
  END IsAFPToSIInst;

PROCEDURE IsAFPToUIInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAFPToUIInst(Val);
  END IsAFPToUIInst;

PROCEDURE IsAFPTruncInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAFPTruncInst(Val);
  END IsAFPTruncInst;

PROCEDURE IsAIntToPtrInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAIntToPtrInst(Val);
  END IsAIntToPtrInst;

PROCEDURE IsAPtrToIntInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAPtrToIntInst(Val);
  END IsAPtrToIntInst;

PROCEDURE IsASExtInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsASExtInst(Val);
  END IsASExtInst;

PROCEDURE IsASIToFPInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsASIToFPInst(Val);
  END IsASIToFPInst;

PROCEDURE IsATruncInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsATruncInst(Val);
  END IsATruncInst;

PROCEDURE IsAUIToFPInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAUIToFPInst(Val);
  END IsAUIToFPInst;

PROCEDURE IsAZExtInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAZExtInst(Val);
  END IsAZExtInst;

PROCEDURE IsAExtractValueInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAExtractValueInst(Val);
  END IsAExtractValueInst;

PROCEDURE IsALoadInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsALoadInst(Val);
  END IsALoadInst;

PROCEDURE IsAVAArgInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAVAArgInst(Val);
  END IsAVAArgInst;

PROCEDURE IsAFreezeInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAFreezeInst(Val);
  END IsAFreezeInst;

PROCEDURE IsAAtomicCmpXchgInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAAtomicCmpXchgInst(Val);
  END IsAAtomicCmpXchgInst;

PROCEDURE IsAAtomicRMWInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAAtomicRMWInst(Val);
  END IsAAtomicRMWInst;

PROCEDURE IsAFenceInst (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAFenceInst(Val);
  END IsAFenceInst;

PROCEDURE IsAMDNode (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAMDNode(Val);
  END IsAMDNode;

PROCEDURE IsAValueAsMetadata (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAValueAsMetadata(Val);
  END IsAValueAsMetadata;

PROCEDURE IsAMDString (Val: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsAMDString(Val);
  END IsAMDString;

PROCEDURE GetValueName (Val: ValueRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetValueName(Val);
    RETURN M3toC.CopyStoT(result);
  END GetValueName;

PROCEDURE SetValueName (Val: ValueRef; Name: TEXT; ) =
  VAR arg2: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    LLVMRaw.SetValueName(Val, arg2);
    M3toC.FreeSharedS(Name, arg2);
  END SetValueName;

PROCEDURE GetFirstUse (Val: ValueRef; ): UseRef =
  BEGIN
    RETURN LLVMRaw.GetFirstUse(Val);
  END GetFirstUse;

PROCEDURE GetNextUse (U: UseRef; ): UseRef =
  BEGIN
    RETURN LLVMRaw.GetNextUse(U);
  END GetNextUse;

PROCEDURE GetUser (U: UseRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetUser(U);
  END GetUser;

PROCEDURE GetUsedValue (U: UseRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetUsedValue(U);
  END GetUsedValue;

PROCEDURE GetOperand (Val: ValueRef; Index: uint32_t; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetOperand(Val, Index);
  END GetOperand;

PROCEDURE GetOperandUse (Val: ValueRef; Index: uint32_t; ): UseRef =
  BEGIN
    RETURN LLVMRaw.GetOperandUse(Val, Index);
  END GetOperandUse;

PROCEDURE SetOperand (User: ValueRef; Index: uint32_t; Val: ValueRef; ) =
  BEGIN
    LLVMRaw.SetOperand(User, Index, Val);
  END SetOperand;

PROCEDURE GetNumOperands (Val: ValueRef; ): INTEGER =
  BEGIN
    RETURN LLVMRaw.GetNumOperands(Val);
  END GetNumOperands;

PROCEDURE ConstNull (Ty: TypeRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstNull(Ty);
  END ConstNull;

PROCEDURE ConstAllOnes (Ty: TypeRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstAllOnes(Ty);
  END ConstAllOnes;

PROCEDURE GetUndef (Ty: TypeRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetUndef(Ty);
  END GetUndef;

PROCEDURE GetPoison (Ty: TypeRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetPoison(Ty);
  END GetPoison;

PROCEDURE IsNull (Val: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsNull(Val);
  END IsNull;

PROCEDURE ConstPointerNull (Ty: TypeRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstPointerNull(Ty);
  END ConstPointerNull;

PROCEDURE ConstInt (IntTy: TypeRef; N: uint64_t; SignExtend: BOOLEAN; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstInt(IntTy, N, SignExtend);
  END ConstInt;

PROCEDURE ConstIntOfArbitraryPrecision
  (IntTy: TypeRef; NumWords: uint32_t; Words: REF ARRAY OF uint64_t; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstIntOfArbitraryPrecision(IntTy, NumWords, Words);
  END ConstIntOfArbitraryPrecision;

PROCEDURE ConstIntOfString (IntTy: TypeRef; Text: TEXT; Radix: uint8_t; ):
  ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Text);
    result := LLVMRaw.ConstIntOfString(IntTy, arg2, Radix);
    M3toC.FreeSharedS(Text, arg2);
    RETURN result;
  END ConstIntOfString;

PROCEDURE ConstIntOfStringAndSize
  (IntTy: TypeRef; Text: TEXT; SLen: uint32_t; Radix: uint8_t; ):
  ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Text);
    result := LLVMRaw.ConstIntOfStringAndSize(IntTy, arg2, SLen, Radix);
    M3toC.FreeSharedS(Text, arg2);
    RETURN result;
  END ConstIntOfStringAndSize;

PROCEDURE ConstReal (RealTy: TypeRef; N: LONGREAL; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstReal(RealTy, N);
  END ConstReal;

PROCEDURE ConstRealOfString (RealTy: TypeRef; Text: TEXT; ): ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Text);
    result := LLVMRaw.ConstRealOfString(RealTy, arg2);
    M3toC.FreeSharedS(Text, arg2);
    RETURN result;
  END ConstRealOfString;

PROCEDURE ConstRealOfStringAndSize
  (RealTy: TypeRef; Text: TEXT; SLen: uint32_t; ): ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Text);
    result := LLVMRaw.ConstRealOfStringAndSize(RealTy, arg2, SLen);
    M3toC.FreeSharedS(Text, arg2);
    RETURN result;
  END ConstRealOfStringAndSize;

PROCEDURE ConstIntGetZExtValue (ConstantVal: ValueRef; ): uint64_t =
  BEGIN
    RETURN LLVMRaw.ConstIntGetZExtValue(ConstantVal);
  END ConstIntGetZExtValue;

PROCEDURE ConstIntGetSExtValue (ConstantVal: ValueRef; ): int64_t =
  BEGIN
    RETURN LLVMRaw.ConstIntGetSExtValue(ConstantVal);
  END ConstIntGetSExtValue;

PROCEDURE ConstRealGetDouble
  (ConstantVal: ValueRef; VAR losesInfo: BOOLEAN; ): LONGREAL =
  BEGIN
    RETURN LLVMRaw.ConstRealGetDouble(ConstantVal, losesInfo);
  END ConstRealGetDouble;

PROCEDURE ConstStringInContext (context          : ContextRef;
                                Str              : TEXT;
                                Length           : uint32_t;
                                DontNullTerminate: BOOLEAN;    ):
  ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Str);
    result := LLVMRaw.ConstStringInContext(
                context, arg2, Length, DontNullTerminate);
    M3toC.FreeSharedS(Str, arg2);
    RETURN result;
  END ConstStringInContext;

PROCEDURE ConstStringInContext2 (context          : ContextRef;
                                 Str              : TEXT;
                                 Length           : Word.T;
                                 DontNullTerminate: BOOLEAN;    ):
  ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Str);
    result := LLVMRaw.ConstStringInContext2(
                context, arg2, Length, DontNullTerminate);
    M3toC.FreeSharedS(Str, arg2);
    RETURN result;
  END ConstStringInContext2;

PROCEDURE ConstString
  (Str: TEXT; Length: uint32_t; DontNullTerminate: BOOLEAN; ): ValueRef =
  VAR
    arg1  : C.char_star;
    result: ValueRef;
  BEGIN
    arg1 := M3toC.SharedTtoS(Str);
    result := LLVMRaw.ConstString(arg1, Length, DontNullTerminate);
    M3toC.FreeSharedS(Str, arg1);
    RETURN result;
  END ConstString;

PROCEDURE IsConstantString (c: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsConstantString(c);
  END IsConstantString;

PROCEDURE GetAsString (c: ValueRef; VAR Length: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetAsString(c, Length);
    RETURN M3toC.CopyStoT(result);
  END GetAsString;

PROCEDURE GetRawDataValues (c: ValueRef; VAR SizeInBytes: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetRawDataValues(c, SizeInBytes);
    RETURN M3toC.CopyStoT(result);
  END GetRawDataValues;

PROCEDURE ConstStructInContext (context     : ContextRef;
                                ConstantVals: UNTRACED REF ValueRef;
                                Count       : uint32_t;
                                Packed      : BOOLEAN;               ):
  ValueRef =
  BEGIN
    RETURN
      LLVMRaw.ConstStructInContext(context, ConstantVals, Count, Packed);
  END ConstStructInContext;

PROCEDURE ConstStruct (ConstantVals: UNTRACED REF ValueRef;
                       Count       : uint32_t;
                       Packed      : BOOLEAN;               ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstStruct(ConstantVals, Count, Packed);
  END ConstStruct;

PROCEDURE ConstArray (ElementTy   : TypeRef;
                      ConstantVals: UNTRACED REF ValueRef;
                      Length      : uint32_t;              ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstArray(ElementTy, ConstantVals, Length);
  END ConstArray;

PROCEDURE ConstArray2 (ElementTy   : TypeRef;
                       ConstantVals: UNTRACED REF ValueRef;
                       Length      : uint64_t;              ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstArray2(ElementTy, ConstantVals, Length);
  END ConstArray2;

PROCEDURE ConstDataArray
  (ElementTy: TypeRef; Data: TEXT; SizeInBytes: Word.T; ): ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Data);
    result := LLVMRaw.ConstDataArray(ElementTy, arg2, SizeInBytes);
    M3toC.FreeSharedS(Data, arg2);
    RETURN result;
  END ConstDataArray;

PROCEDURE ConstNamedStruct (StructTy    : TypeRef;
                            ConstantVals: UNTRACED REF ValueRef;
                            Count       : uint32_t;              ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstNamedStruct(StructTy, ConstantVals, Count);
  END ConstNamedStruct;

PROCEDURE GetAggregateElement (context: ValueRef; Idx: uint32_t; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.GetAggregateElement(context, Idx);
  END GetAggregateElement;

PROCEDURE ConstVector
  (ScalarConstantVals: UNTRACED REF ValueRef; Size: uint32_t; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstVector(ScalarConstantVals, Size);
  END ConstVector;

PROCEDURE ConstantPtrAuth (Ptr, Key, Disc, AddrDisc: ValueRef; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstantPtrAuth(Ptr, Key, Disc, AddrDisc);
  END ConstantPtrAuth;

PROCEDURE GetConstOpcode (ConstantVal: ValueRef; ): LLVMOpcode =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetConstOpcode(ConstantVal);
    RETURN VAL(ret, LLVMOpcode);
  END GetConstOpcode;

PROCEDURE AlignOf (Ty: TypeRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.AlignOf(Ty);
  END AlignOf;

PROCEDURE SizeOf (Ty: TypeRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.SizeOf(Ty);
  END SizeOf;

PROCEDURE ConstNeg (ConstantVal: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstNeg(ConstantVal);
  END ConstNeg;

PROCEDURE ConstNSWNeg (ConstantVal: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstNSWNeg(ConstantVal);
  END ConstNSWNeg;

PROCEDURE ConstNot (ConstantVal: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstNot(ConstantVal);
  END ConstNot;

PROCEDURE ConstAdd (LHSConstant, RHSConstant: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstAdd(LHSConstant, RHSConstant);
  END ConstAdd;

PROCEDURE ConstNSWAdd (LHSConstant, RHSConstant: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstNSWAdd(LHSConstant, RHSConstant);
  END ConstNSWAdd;

PROCEDURE ConstNUWAdd (LHSConstant, RHSConstant: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstNUWAdd(LHSConstant, RHSConstant);
  END ConstNUWAdd;

PROCEDURE ConstSub (LHSConstant, RHSConstant: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstSub(LHSConstant, RHSConstant);
  END ConstSub;

PROCEDURE ConstNSWSub (LHSConstant, RHSConstant: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstNSWSub(LHSConstant, RHSConstant);
  END ConstNSWSub;

PROCEDURE ConstNUWSub (LHSConstant, RHSConstant: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstNUWSub(LHSConstant, RHSConstant);
  END ConstNUWSub;

PROCEDURE ConstXor (LHSConstant, RHSConstant: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstXor(LHSConstant, RHSConstant);
  END ConstXor;

PROCEDURE ConstGEP2 (Ty             : TypeRef;
                     ConstantVal    : ValueRef;
                     ConstantIndices: UNTRACED REF ValueRef;
                     NumIndices     : uint32_t;              ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstGEP2(Ty, ConstantVal, ConstantIndices, NumIndices);
  END ConstGEP2;

PROCEDURE ConstInBoundsGEP2 (Ty             : TypeRef;
                             ConstantVal    : ValueRef;
                             ConstantIndices: UNTRACED REF ValueRef;
                             NumIndices     : uint32_t;              ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstInBoundsGEP2(
             Ty, ConstantVal, ConstantIndices, NumIndices);
  END ConstInBoundsGEP2;

PROCEDURE ConstGEPWithNoWrapFlags (Ty             : TypeRef;
                                   ConstantVal    : ValueRef;
                                   ConstantIndices: UNTRACED REF ValueRef;
                                   NumIndices, NoWrapFlags: uint32_t; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstGEPWithNoWrapFlags(
             Ty, ConstantVal, ConstantIndices, NumIndices, NoWrapFlags);
  END ConstGEPWithNoWrapFlags;

PROCEDURE ConstTrunc (ConstantVal: ValueRef; ToType: TypeRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstTrunc(ConstantVal, ToType);
  END ConstTrunc;

PROCEDURE ConstPtrToInt (ConstantVal: ValueRef; ToType: TypeRef; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstPtrToInt(ConstantVal, ToType);
  END ConstPtrToInt;

PROCEDURE ConstIntToPtr (ConstantVal: ValueRef; ToType: TypeRef; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstIntToPtr(ConstantVal, ToType);
  END ConstIntToPtr;

PROCEDURE ConstBitCast (ConstantVal: ValueRef; ToType: TypeRef; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstBitCast(ConstantVal, ToType);
  END ConstBitCast;

PROCEDURE ConstAddrSpaceCast (ConstantVal: ValueRef; ToType: TypeRef; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstAddrSpaceCast(ConstantVal, ToType);
  END ConstAddrSpaceCast;

PROCEDURE ConstTruncOrBitCast (ConstantVal: ValueRef; ToType: TypeRef; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstTruncOrBitCast(ConstantVal, ToType);
  END ConstTruncOrBitCast;

PROCEDURE ConstPointerCast (ConstantVal: ValueRef; ToType: TypeRef; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstPointerCast(ConstantVal, ToType);
  END ConstPointerCast;

PROCEDURE ConstExtractElement (VectorConstant, IndexConstant: ValueRef; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstExtractElement(VectorConstant, IndexConstant);
  END ConstExtractElement;

PROCEDURE ConstInsertElement
  (VectorConstant, ElementValueConstant, IndexConstant: ValueRef; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstInsertElement(
             VectorConstant, ElementValueConstant, IndexConstant);
  END ConstInsertElement;

PROCEDURE ConstShuffleVector
  (VectorAConstant, VectorBConstant, MaskConstant: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.ConstShuffleVector(
             VectorAConstant, VectorBConstant, MaskConstant);
  END ConstShuffleVector;

PROCEDURE BlockAddress (F: ValueRef; BB: BasicBlockRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BlockAddress(F, BB);
  END BlockAddress;

PROCEDURE GetBlockAddressFunction (BlockAddr: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetBlockAddressFunction(BlockAddr);
  END GetBlockAddressFunction;

PROCEDURE GetBlockAddressBasicBlock (BlockAddr: ValueRef; ):
  BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetBlockAddressBasicBlock(BlockAddr);
  END GetBlockAddressBasicBlock;

PROCEDURE ConstInlineAsm (Ty                          : TypeRef;
                          AsmString, Constraints      : TEXT;
                          HasSideEffects, IsAlignStack: BOOLEAN; ):
  ValueRef =
  VAR
    arg2  : C.char_star;
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(AsmString);
    arg3 := M3toC.SharedTtoS(Constraints);
    result :=
      LLVMRaw.ConstInlineAsm(Ty, arg2, arg3, HasSideEffects, IsAlignStack);
    M3toC.FreeSharedS(AsmString, arg2);
    M3toC.FreeSharedS(Constraints, arg3);
    RETURN result;
  END ConstInlineAsm;

PROCEDURE GetGlobalParent (Global: ValueRef; ): ModuleRef =
  BEGIN
    RETURN LLVMRaw.GetGlobalParent(Global);
  END GetGlobalParent;

PROCEDURE IsDeclaration (Global: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsDeclaration(Global);
  END IsDeclaration;

PROCEDURE GetLinkage (Global: ValueRef; ): LLVMLinkage =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetLinkage(Global);
    RETURN VAL(ret, LLVMLinkage);
  END GetLinkage;

PROCEDURE SetLinkage (Global: ValueRef; Linkage: LLVMLinkage; ) =
  VAR arg2tmp: C.int;
  BEGIN
    arg2tmp := ORD(Linkage);
    LLVMRaw.SetLinkage(Global, arg2tmp);
  END SetLinkage;

PROCEDURE GetSection (Global: ValueRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetSection(Global);
    RETURN M3toC.CopyStoT(result);
  END GetSection;

PROCEDURE SetSection (Global: ValueRef; Section: TEXT; ) =
  VAR arg2: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(Section);
    LLVMRaw.SetSection(Global, arg2);
    M3toC.FreeSharedS(Section, arg2);
  END SetSection;

PROCEDURE GetVisibility (Global: ValueRef; ): LLVMVisibility =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetVisibility(Global);
    RETURN VAL(ret, LLVMVisibility);
  END GetVisibility;

PROCEDURE SetVisibility (Global: ValueRef; Viz: LLVMVisibility; ) =
  VAR arg2tmp: C.int;
  BEGIN
    arg2tmp := ORD(Viz);
    LLVMRaw.SetVisibility(Global, arg2tmp);
  END SetVisibility;

PROCEDURE GetDLLStorageClass (Global: ValueRef; ): LLVMDLLStorageClass =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetDLLStorageClass(Global);
    RETURN VAL(ret, LLVMDLLStorageClass);
  END GetDLLStorageClass;

PROCEDURE SetDLLStorageClass
  (Global: ValueRef; Class: LLVMDLLStorageClass; ) =
  VAR arg2tmp: C.int;
  BEGIN
    arg2tmp := ORD(Class);
    LLVMRaw.SetDLLStorageClass(Global, arg2tmp);
  END SetDLLStorageClass;

PROCEDURE GetUnnamedAddress (Global: ValueRef; ): LLVMUnnamedAddr =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetUnnamedAddress(Global);
    RETURN VAL(ret, LLVMUnnamedAddr);
  END GetUnnamedAddress;

PROCEDURE SetUnnamedAddress
  (Global: ValueRef; UnnamedAddr: LLVMUnnamedAddr; ) =
  VAR arg2tmp: C.int;
  BEGIN
    arg2tmp := ORD(UnnamedAddr);
    LLVMRaw.SetUnnamedAddress(Global, arg2tmp);
  END SetUnnamedAddress;

PROCEDURE GlobalGetValueType (Global: ValueRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.GlobalGetValueType(Global);
  END GlobalGetValueType;

PROCEDURE HasUnnamedAddr (Global: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.HasUnnamedAddr(Global);
  END HasUnnamedAddr;

PROCEDURE SetUnnamedAddr (Global: ValueRef; HasUnnamedAddr: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetUnnamedAddr(Global, HasUnnamedAddr);
  END SetUnnamedAddr;

PROCEDURE GetAlignment (V: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetAlignment(V);
  END GetAlignment;

PROCEDURE SetAlignment (V: ValueRef; Bytes: uint32_t; ) =
  BEGIN
    LLVMRaw.SetAlignment(V, Bytes);
  END SetAlignment;

PROCEDURE GlobalSetMetadata
  (Global: ValueRef; Kind: uint32_t; MD: MetadataRef; ) =
  BEGIN
    LLVMRaw.GlobalSetMetadata(Global, Kind, MD);
  END GlobalSetMetadata;

PROCEDURE GlobalAddMetadata
  (Global: ValueRef; Kind: uint32_t; MD: MetadataRef; ) =
  BEGIN
    LLVMRaw.GlobalAddMetadata(Global, Kind, MD);
  END GlobalAddMetadata;

PROCEDURE GlobalEraseMetadata (Global: ValueRef; Kind: uint32_t; ) =
  BEGIN
    LLVMRaw.GlobalEraseMetadata(Global, Kind);
  END GlobalEraseMetadata;

PROCEDURE GlobalClearMetadata (Global: ValueRef; ) =
  BEGIN
    LLVMRaw.GlobalClearMetadata(Global);
  END GlobalClearMetadata;

PROCEDURE GlobalAddDebugInfo (Global: ValueRef; GVE: MetadataRef; ) =
  BEGIN
    LLVMRaw.GlobalAddDebugInfo(Global, GVE);
  END GlobalAddDebugInfo;

PROCEDURE GlobalCopyAllMetadata
  (Value: ValueRef; VAR NumEntries: Word.T; ):
  UNTRACED REF ValueMetadataEntryRef =
  BEGIN
    RETURN LLVMRaw.GlobalCopyAllMetadata(Value, NumEntries);
  END GlobalCopyAllMetadata;

PROCEDURE DisposeValueMetadataEntries
  (Entries: UNTRACED REF ValueMetadataEntryRef; ) =
  BEGIN
    LLVMRaw.DisposeValueMetadataEntries(Entries);
  END DisposeValueMetadataEntries;

PROCEDURE ValueMetadataEntriesGetKind
  (Entries: UNTRACED REF ValueMetadataEntryRef; Index: uint32_t; ):
  uint32_t =
  BEGIN
    RETURN LLVMRaw.ValueMetadataEntriesGetKind(Entries, Index);
  END ValueMetadataEntriesGetKind;

PROCEDURE ValueMetadataEntriesGetMetadata
  (Entries: UNTRACED REF ValueMetadataEntryRef; Index: uint32_t; ):
  MetadataRef =
  BEGIN
    RETURN LLVMRaw.ValueMetadataEntriesGetMetadata(Entries, Index);
  END ValueMetadataEntriesGetMetadata;

PROCEDURE AddGlobal (M: ModuleRef; Ty: TypeRef; Name: TEXT; ): ValueRef =
  VAR
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.AddGlobal(M, Ty, arg3);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END AddGlobal;

PROCEDURE AddGlobalInAddressSpace
  (M: ModuleRef; Ty: TypeRef; Name: TEXT; AddressSpace: uint32_t := 0; ):
  ValueRef =
  VAR
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.AddGlobalInAddressSpace(M, Ty, arg3, AddressSpace);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END AddGlobalInAddressSpace;

PROCEDURE GetNamedGlobal (M: ModuleRef; Name: TEXT; ): ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetNamedGlobal(M, arg2);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END GetNamedGlobal;

PROCEDURE GetNamedGlobalWithLength
  (M: ModuleRef; Name: TEXT; Length: Word.T; ): ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetNamedGlobalWithLength(M, arg2, Length);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END GetNamedGlobalWithLength;

PROCEDURE GetFirstGlobal (M: ModuleRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetFirstGlobal(M);
  END GetFirstGlobal;

PROCEDURE GetLastGlobal (M: ModuleRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetLastGlobal(M);
  END GetLastGlobal;

PROCEDURE GetNextGlobal (GlobalVar: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetNextGlobal(GlobalVar);
  END GetNextGlobal;

PROCEDURE GetPreviousGlobal (GlobalVar: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetPreviousGlobal(GlobalVar);
  END GetPreviousGlobal;

PROCEDURE DeleteGlobal (GlobalVar: ValueRef; ) =
  BEGIN
    LLVMRaw.DeleteGlobal(GlobalVar);
  END DeleteGlobal;

PROCEDURE GetInitializer (GlobalVar: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetInitializer(GlobalVar);
  END GetInitializer;

PROCEDURE SetInitializer (GlobalVar, ConstantVal: ValueRef; ) =
  BEGIN
    LLVMRaw.SetInitializer(GlobalVar, ConstantVal);
  END SetInitializer;

PROCEDURE IsThreadLocal (GlobalVar: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsThreadLocal(GlobalVar);
  END IsThreadLocal;

PROCEDURE SetThreadLocal (GlobalVar: ValueRef; IsThreadLocal: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetThreadLocal(GlobalVar, IsThreadLocal);
  END SetThreadLocal;

PROCEDURE IsGlobalConstant (GlobalVar: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsGlobalConstant(GlobalVar);
  END IsGlobalConstant;

PROCEDURE SetGlobalConstant (GlobalVar: ValueRef; IsConstant: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetGlobalConstant(GlobalVar, IsConstant);
  END SetGlobalConstant;

PROCEDURE GetThreadLocalMode (GlobalVar: ValueRef; ): LLVMThreadLocalMode =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetThreadLocalMode(GlobalVar);
    RETURN VAL(ret, LLVMThreadLocalMode);
  END GetThreadLocalMode;

PROCEDURE SetThreadLocalMode
  (GlobalVar: ValueRef; Mode: LLVMThreadLocalMode; ) =
  VAR arg2tmp: C.int;
  BEGIN
    arg2tmp := ORD(Mode);
    LLVMRaw.SetThreadLocalMode(GlobalVar, arg2tmp);
  END SetThreadLocalMode;

PROCEDURE IsExternallyInitialized (GlobalVar: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsExternallyInitialized(GlobalVar);
  END IsExternallyInitialized;

PROCEDURE SetExternallyInitialized
  (GlobalVar: ValueRef; IsExtInit: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetExternallyInitialized(GlobalVar, IsExtInit);
  END SetExternallyInitialized;

PROCEDURE AddAlias2 (M        : ModuleRef;
                     ValueTy  : TypeRef;
                     AddrSpace: uint32_t;
                     Aliasee  : ValueRef;
                     Name     : TEXT;      ): ValueRef =
  VAR
    arg5  : C.char_star;
    result: ValueRef;
  BEGIN
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.AddAlias2(M, ValueTy, AddrSpace, Aliasee, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END AddAlias2;

PROCEDURE GetNamedGlobalAlias
  (M: ModuleRef; Name: TEXT; NameLen: Word.T; ): ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetNamedGlobalAlias(M, arg2, NameLen);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END GetNamedGlobalAlias;

PROCEDURE GetFirstGlobalAlias (M: ModuleRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetFirstGlobalAlias(M);
  END GetFirstGlobalAlias;

PROCEDURE GetLastGlobalAlias (M: ModuleRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetLastGlobalAlias(M);
  END GetLastGlobalAlias;

PROCEDURE GetNextGlobalAlias (GA: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetNextGlobalAlias(GA);
  END GetNextGlobalAlias;

PROCEDURE GetPreviousGlobalAlias (GA: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetPreviousGlobalAlias(GA);
  END GetPreviousGlobalAlias;

PROCEDURE AliasGetAliasee (Alias: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.AliasGetAliasee(Alias);
  END AliasGetAliasee;

PROCEDURE AliasSetAliasee (Alias, Aliasee: ValueRef; ) =
  BEGIN
    LLVMRaw.AliasSetAliasee(Alias, Aliasee);
  END AliasSetAliasee;

PROCEDURE DeleteFunction (Fn: ValueRef; ) =
  BEGIN
    LLVMRaw.DeleteFunction(Fn);
  END DeleteFunction;

PROCEDURE HasPersonalityFn (Fn: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.HasPersonalityFn(Fn);
  END HasPersonalityFn;

PROCEDURE GetPersonalityFn (Fn: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetPersonalityFn(Fn);
  END GetPersonalityFn;

PROCEDURE SetPersonalityFn (Fn, PersonalityFn: ValueRef; ) =
  BEGIN
    LLVMRaw.SetPersonalityFn(Fn, PersonalityFn);
  END SetPersonalityFn;

PROCEDURE LookupIntrinsicID (Name: TEXT; NameLen: Word.T; ): uint32_t =
  VAR
    arg1  : C.char_star;
    result: uint32_t;
  BEGIN
    arg1 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.LookupIntrinsicID(arg1, NameLen);
    M3toC.FreeSharedS(Name, arg1);
    RETURN result;
  END LookupIntrinsicID;

PROCEDURE GetIntrinsicID (Fn: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetIntrinsicID(Fn);
  END GetIntrinsicID;

PROCEDURE GetIntrinsicDeclaration (Mod       : ModuleRef;
                                   ID        : uint32_t;
                                   ParamTypes: UNTRACED REF TypeRef;
                                   ParamCount: Word.T;               ):
  ValueRef =
  BEGIN
    RETURN
      LLVMRaw.GetIntrinsicDeclaration(Mod, ID, ParamTypes, ParamCount);
  END GetIntrinsicDeclaration;

PROCEDURE IntrinsicGetType (Ctx       : ContextRef;
                            ID        : uint32_t;
                            ParamTypes: UNTRACED REF TypeRef;
                            ParamCount: Word.T;               ): TypeRef =
  BEGIN
    RETURN LLVMRaw.IntrinsicGetType(Ctx, ID, ParamTypes, ParamCount);
  END IntrinsicGetType;

PROCEDURE IntrinsicGetName (ID: uint32_t; VAR NameLength: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.IntrinsicGetName(ID, NameLength);
    RETURN M3toC.CopyStoT(result);
  END IntrinsicGetName;

PROCEDURE IntrinsicCopyOverloadedName (ID        : uint32_t;
                                       ParamTypes: UNTRACED REF TypeRef;
                                       ParamCount: Word.T;
                                       VAR NameLength: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.IntrinsicCopyOverloadedName(
                ID, ParamTypes, ParamCount, NameLength);
    RETURN M3toC.CopyStoT(result);
  END IntrinsicCopyOverloadedName;

PROCEDURE IntrinsicCopyOverloadedName2 (Mod       : ModuleRef;
                                        ID        : uint32_t;
                                        ParamTypes: UNTRACED REF TypeRef;
                                        ParamCount: Word.T;
                                        VAR NameLength: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.IntrinsicCopyOverloadedName2(
                Mod, ID, ParamTypes, ParamCount, NameLength);
    RETURN M3toC.CopyStoT(result);
  END IntrinsicCopyOverloadedName2;

PROCEDURE IntrinsicIsOverloaded (ID: uint32_t; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IntrinsicIsOverloaded(ID);
  END IntrinsicIsOverloaded;

PROCEDURE GetFunctionCallConv (Fn: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetFunctionCallConv(Fn);
  END GetFunctionCallConv;

PROCEDURE SetFunctionCallConv (Fn: ValueRef; CC: uint32_t; ) =
  BEGIN
    LLVMRaw.SetFunctionCallConv(Fn, CC);
  END SetFunctionCallConv;

PROCEDURE GetGC (Fn: ValueRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetGC(Fn);
    RETURN M3toC.CopyStoT(result);
  END GetGC;

PROCEDURE SetGC (Fn: ValueRef; Name: TEXT; ) =
  VAR arg2: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    LLVMRaw.SetGC(Fn, arg2);
    M3toC.FreeSharedS(Name, arg2);
  END SetGC;

PROCEDURE GetPrefixData (Fn: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetPrefixData(Fn);
  END GetPrefixData;

PROCEDURE HasPrefixData (Fn: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.HasPrefixData(Fn);
  END HasPrefixData;

PROCEDURE SetPrefixData (Fn, prefixData: ValueRef; ) =
  BEGIN
    LLVMRaw.SetPrefixData(Fn, prefixData);
  END SetPrefixData;

PROCEDURE GetPrologueData (Fn: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetPrologueData(Fn);
  END GetPrologueData;

PROCEDURE HasPrologueData (Fn: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.HasPrologueData(Fn);
  END HasPrologueData;

PROCEDURE SetPrologueData (Fn, prologueData: ValueRef; ) =
  BEGIN
    LLVMRaw.SetPrologueData(Fn, prologueData);
  END SetPrologueData;

PROCEDURE AddAttributeAtIndex
  (F: ValueRef; Idx: AttributeIndex; A: AttributeRef; ) =
  BEGIN
    LLVMRaw.AddAttributeAtIndex(F, Idx, A);
  END AddAttributeAtIndex;

PROCEDURE GetAttributeCountAtIndex (F: ValueRef; Idx: AttributeIndex; ):
  uint32_t =
  BEGIN
    RETURN LLVMRaw.GetAttributeCountAtIndex(F, Idx);
  END GetAttributeCountAtIndex;

PROCEDURE GetAttributesAtIndex
  (F: ValueRef; Idx: AttributeIndex; Attrs: UNTRACED REF AttributeRef; ) =
  BEGIN
    LLVMRaw.GetAttributesAtIndex(F, Idx, Attrs);
  END GetAttributesAtIndex;

PROCEDURE GetEnumAttributeAtIndex
  (F: ValueRef; Idx: AttributeIndex; KindID: uint32_t; ): AttributeRef =
  BEGIN
    RETURN LLVMRaw.GetEnumAttributeAtIndex(F, Idx, KindID);
  END GetEnumAttributeAtIndex;

PROCEDURE GetStringAttributeAtIndex
  (F: ValueRef; Idx: AttributeIndex; K: TEXT; KLen: uint32_t; ):
  AttributeRef =
  VAR
    arg3  : C.char_star;
    result: AttributeRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(K);
    result := LLVMRaw.GetStringAttributeAtIndex(F, Idx, arg3, KLen);
    M3toC.FreeSharedS(K, arg3);
    RETURN result;
  END GetStringAttributeAtIndex;

PROCEDURE RemoveEnumAttributeAtIndex
  (F: ValueRef; Idx: AttributeIndex; KindID: uint32_t; ) =
  BEGIN
    LLVMRaw.RemoveEnumAttributeAtIndex(F, Idx, KindID);
  END RemoveEnumAttributeAtIndex;

PROCEDURE RemoveStringAttributeAtIndex
  (F: ValueRef; Idx: AttributeIndex; K: TEXT; KLen: uint32_t; ) =
  VAR arg3: C.char_star;
  BEGIN
    arg3 := M3toC.SharedTtoS(K);
    LLVMRaw.RemoveStringAttributeAtIndex(F, Idx, arg3, KLen);
    M3toC.FreeSharedS(K, arg3);
  END RemoveStringAttributeAtIndex;

PROCEDURE AddTargetDependentFunctionAttr (Fn: ValueRef; A, V: TEXT; ) =
  VAR
    arg2: C.char_star;
    arg3: C.char_star;
  BEGIN
    arg2 := M3toC.SharedTtoS(A);
    arg3 := M3toC.SharedTtoS(V);
    LLVMRaw.AddTargetDependentFunctionAttr(Fn, arg2, arg3);
    M3toC.FreeSharedS(A, arg2);
    M3toC.FreeSharedS(V, arg3);
  END AddTargetDependentFunctionAttr;

PROCEDURE CountParams (Fn: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.CountParams(Fn);
  END CountParams;

PROCEDURE GetParams (Fn: ValueRef; Params: UNTRACED REF ValueRef; ) =
  BEGIN
    LLVMRaw.GetParams(Fn, Params);
  END GetParams;

PROCEDURE GetParam (Fn: ValueRef; Index: uint32_t; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetParam(Fn, Index);
  END GetParam;

PROCEDURE GetParamParent (Inst: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetParamParent(Inst);
  END GetParamParent;

PROCEDURE GetFirstParam (Fn: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetFirstParam(Fn);
  END GetFirstParam;

PROCEDURE GetLastParam (Fn: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetLastParam(Fn);
  END GetLastParam;

PROCEDURE GetNextParam (Arg: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetNextParam(Arg);
  END GetNextParam;

PROCEDURE GetPreviousParam (Arg: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetPreviousParam(Arg);
  END GetPreviousParam;

PROCEDURE SetParamAlignment (Arg: ValueRef; Align: uint32_t; ) =
  BEGIN
    LLVMRaw.SetParamAlignment(Arg, Align);
  END SetParamAlignment;

PROCEDURE AddGlobalIFunc (M        : ModuleRef;
                          Name     : TEXT;
                          NameLen  : Word.T;
                          Ty       : TypeRef;
                          AddrSpace: uint32_t;
                          Resolver : ValueRef;  ): ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result :=
      LLVMRaw.AddGlobalIFunc(M, arg2, NameLen, Ty, AddrSpace, Resolver);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END AddGlobalIFunc;

PROCEDURE GetNamedGlobalIFunc
  (M: ModuleRef; Name: TEXT; NameLen: Word.T; ): ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.GetNamedGlobalIFunc(M, arg2, NameLen);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END GetNamedGlobalIFunc;

PROCEDURE GetFirstGlobalIFunc (M: ModuleRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetFirstGlobalIFunc(M);
  END GetFirstGlobalIFunc;

PROCEDURE GetLastGlobalIFunc (M: ModuleRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetLastGlobalIFunc(M);
  END GetLastGlobalIFunc;

PROCEDURE GetNextGlobalIFunc (IFunc: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetNextGlobalIFunc(IFunc);
  END GetNextGlobalIFunc;

PROCEDURE GetPreviousGlobalIFunc (IFunc: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetPreviousGlobalIFunc(IFunc);
  END GetPreviousGlobalIFunc;

PROCEDURE GetGlobalIFuncResolver (IFunc: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetGlobalIFuncResolver(IFunc);
  END GetGlobalIFuncResolver;

PROCEDURE SetGlobalIFuncResolver (IFunc, Resolver: ValueRef; ) =
  BEGIN
    LLVMRaw.SetGlobalIFuncResolver(IFunc, Resolver);
  END SetGlobalIFuncResolver;

PROCEDURE EraseGlobalIFunc (IFunc: ValueRef; ) =
  BEGIN
    LLVMRaw.EraseGlobalIFunc(IFunc);
  END EraseGlobalIFunc;

PROCEDURE RemoveGlobalIFunc (IFunc: ValueRef; ) =
  BEGIN
    LLVMRaw.RemoveGlobalIFunc(IFunc);
  END RemoveGlobalIFunc;

PROCEDURE MDStringInContext2
  (context: ContextRef; Str: TEXT; SLen: Word.T; ): MetadataRef =
  VAR
    arg2  : C.char_star;
    result: MetadataRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Str);
    result := LLVMRaw.MDStringInContext2(context, arg2, SLen);
    M3toC.FreeSharedS(Str, arg2);
    RETURN result;
  END MDStringInContext2;

PROCEDURE MDNodeInContext2
  (context: ContextRef; MDs: UNTRACED REF MetadataRef; Count: Word.T; ):
  MetadataRef =
  BEGIN
    RETURN LLVMRaw.MDNodeInContext2(context, MDs, Count);
  END MDNodeInContext2;

PROCEDURE MetadataAsValue (context: ContextRef; MD: MetadataRef; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.MetadataAsValue(context, MD);
  END MetadataAsValue;

PROCEDURE ValueAsMetadata (Val: ValueRef; ): MetadataRef =
  BEGIN
    RETURN LLVMRaw.ValueAsMetadata(Val);
  END ValueAsMetadata;

PROCEDURE GetMDString (V: ValueRef; VAR Length: uint32_t; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetMDString(V, Length);
    RETURN M3toC.CopyStoT(result);
  END GetMDString;

PROCEDURE GetMDNodeNumOperands (V: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetMDNodeNumOperands(V);
  END GetMDNodeNumOperands;

PROCEDURE GetMDNodeOperands (V: ValueRef; Dest: UNTRACED REF ValueRef; ) =
  BEGIN
    LLVMRaw.GetMDNodeOperands(V, Dest);
  END GetMDNodeOperands;

PROCEDURE ReplaceMDNodeOperandWith
  (V: ValueRef; Index: uint32_t; Replacement: MetadataRef; ) =
  BEGIN
    LLVMRaw.ReplaceMDNodeOperandWith(V, Index, Replacement);
  END ReplaceMDNodeOperandWith;

PROCEDURE MDStringInContext
  (context: ContextRef; Str: TEXT; SLen: uint32_t; ): ValueRef =
  VAR
    arg2  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Str);
    result := LLVMRaw.MDStringInContext(context, arg2, SLen);
    M3toC.FreeSharedS(Str, arg2);
    RETURN result;
  END MDStringInContext;

PROCEDURE MDString (Str: TEXT; SLen: uint32_t; ): ValueRef =
  VAR
    arg1  : C.char_star;
    result: ValueRef;
  BEGIN
    arg1 := M3toC.SharedTtoS(Str);
    result := LLVMRaw.MDString(arg1, SLen);
    M3toC.FreeSharedS(Str, arg1);
    RETURN result;
  END MDString;

PROCEDURE MDNodeInContext
  (context: ContextRef; Vals: UNTRACED REF ValueRef; Count: uint32_t; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.MDNodeInContext(context, Vals, Count);
  END MDNodeInContext;

PROCEDURE MDNode (Vals: UNTRACED REF ValueRef; Count: uint32_t; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.MDNode(Vals, Count);
  END MDNode;

PROCEDURE CreateOperandBundle (Tag    : TEXT;
                               TagLen : Word.T;
                               Args   : UNTRACED REF ValueRef;
                               NumArgs: uint32_t;              ):
  OperandBundleRef =
  VAR
    arg1  : C.char_star;
    result: OperandBundleRef;
  BEGIN
    arg1 := M3toC.SharedTtoS(Tag);
    result := LLVMRaw.CreateOperandBundle(arg1, TagLen, Args, NumArgs);
    M3toC.FreeSharedS(Tag, arg1);
    RETURN result;
  END CreateOperandBundle;

PROCEDURE DisposeOperandBundle (Bundle: OperandBundleRef; ) =
  BEGIN
    LLVMRaw.DisposeOperandBundle(Bundle);
  END DisposeOperandBundle;

PROCEDURE GetOperandBundleTag
  (Bundle: OperandBundleRef; VAR Len: Word.T; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetOperandBundleTag(Bundle, Len);
    RETURN M3toC.CopyStoT(result);
  END GetOperandBundleTag;

PROCEDURE GetNumOperandBundleArgs (Bundle: OperandBundleRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetNumOperandBundleArgs(Bundle);
  END GetNumOperandBundleArgs;

PROCEDURE GetOperandBundleArgAtIndex
  (Bundle: OperandBundleRef; Index: uint32_t; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetOperandBundleArgAtIndex(Bundle, Index);
  END GetOperandBundleArgAtIndex;

PROCEDURE BasicBlockAsValue (BB: BasicBlockRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BasicBlockAsValue(BB);
  END BasicBlockAsValue;

PROCEDURE ValueIsBasicBlock (Val: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.ValueIsBasicBlock(Val);
  END ValueIsBasicBlock;

PROCEDURE ValueAsBasicBlock (Val: ValueRef; ): BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.ValueAsBasicBlock(Val);
  END ValueAsBasicBlock;

PROCEDURE GetBasicBlockName (BB: BasicBlockRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetBasicBlockName(BB);
    RETURN M3toC.CopyStoT(result);
  END GetBasicBlockName;

PROCEDURE GetBasicBlockParent (BB: BasicBlockRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetBasicBlockParent(BB);
  END GetBasicBlockParent;

PROCEDURE GetBasicBlockTerminator (BB: BasicBlockRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetBasicBlockTerminator(BB);
  END GetBasicBlockTerminator;

PROCEDURE CountBasicBlocks (Fn: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.CountBasicBlocks(Fn);
  END CountBasicBlocks;

PROCEDURE GetBasicBlocks
  (Fn: ValueRef; BasicBlocks: UNTRACED REF BasicBlockRef; ) =
  BEGIN
    LLVMRaw.GetBasicBlocks(Fn, BasicBlocks);
  END GetBasicBlocks;

PROCEDURE GetFirstBasicBlock (Fn: ValueRef; ): BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetFirstBasicBlock(Fn);
  END GetFirstBasicBlock;

PROCEDURE GetLastBasicBlock (Fn: ValueRef; ): BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetLastBasicBlock(Fn);
  END GetLastBasicBlock;

PROCEDURE GetNextBasicBlock (BB: BasicBlockRef; ): BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetNextBasicBlock(BB);
  END GetNextBasicBlock;

PROCEDURE GetPreviousBasicBlock (BB: BasicBlockRef; ): BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetPreviousBasicBlock(BB);
  END GetPreviousBasicBlock;

PROCEDURE GetEntryBasicBlock (Fn: ValueRef; ): BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetEntryBasicBlock(Fn);
  END GetEntryBasicBlock;

PROCEDURE InsertExistingBasicBlockAfterInsertBlock
  (Builder: BuilderRef; BB: BasicBlockRef; ) =
  BEGIN
    LLVMRaw.InsertExistingBasicBlockAfterInsertBlock(Builder, BB);
  END InsertExistingBasicBlockAfterInsertBlock;

PROCEDURE AppendExistingBasicBlock (Fn: ValueRef; BB: BasicBlockRef; ) =
  BEGIN
    LLVMRaw.AppendExistingBasicBlock(Fn, BB);
  END AppendExistingBasicBlock;

PROCEDURE CreateBasicBlockInContext (context: ContextRef; Name: TEXT; ):
  BasicBlockRef =
  VAR
    arg2  : C.char_star;
    result: BasicBlockRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.CreateBasicBlockInContext(context, arg2);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END CreateBasicBlockInContext;

PROCEDURE AppendBasicBlockInContext
  (context: ContextRef; Fn: ValueRef; Name: TEXT; ): BasicBlockRef =
  VAR
    arg3  : C.char_star;
    result: BasicBlockRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.AppendBasicBlockInContext(context, Fn, arg3);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END AppendBasicBlockInContext;

PROCEDURE AppendBasicBlock (Fn: ValueRef; Name: TEXT; ): BasicBlockRef =
  VAR
    arg2  : C.char_star;
    result: BasicBlockRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.AppendBasicBlock(Fn, arg2);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END AppendBasicBlock;

PROCEDURE InsertBasicBlockInContext
  (context: ContextRef; BB: BasicBlockRef; Name: TEXT; ): BasicBlockRef =
  VAR
    arg3  : C.char_star;
    result: BasicBlockRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.InsertBasicBlockInContext(context, BB, arg3);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END InsertBasicBlockInContext;

PROCEDURE InsertBasicBlock (InsertBeforeBB: BasicBlockRef; Name: TEXT; ):
  BasicBlockRef =
  VAR
    arg2  : C.char_star;
    result: BasicBlockRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.InsertBasicBlock(InsertBeforeBB, arg2);
    M3toC.FreeSharedS(Name, arg2);
    RETURN result;
  END InsertBasicBlock;

PROCEDURE DeleteBasicBlock (BB: BasicBlockRef; ) =
  BEGIN
    LLVMRaw.DeleteBasicBlock(BB);
  END DeleteBasicBlock;

PROCEDURE RemoveBasicBlockFromParent (BB: BasicBlockRef; ) =
  BEGIN
    LLVMRaw.RemoveBasicBlockFromParent(BB);
  END RemoveBasicBlockFromParent;

PROCEDURE MoveBasicBlockBefore (BB, MovePos: BasicBlockRef; ) =
  BEGIN
    LLVMRaw.MoveBasicBlockBefore(BB, MovePos);
  END MoveBasicBlockBefore;

PROCEDURE MoveBasicBlockAfter (BB, MovePos: BasicBlockRef; ) =
  BEGIN
    LLVMRaw.MoveBasicBlockAfter(BB, MovePos);
  END MoveBasicBlockAfter;

PROCEDURE GetFirstInstruction (BB: BasicBlockRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetFirstInstruction(BB);
  END GetFirstInstruction;

PROCEDURE GetLastInstruction (BB: BasicBlockRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetLastInstruction(BB);
  END GetLastInstruction;

PROCEDURE HasMetadata (Val: ValueRef; ): INTEGER =
  BEGIN
    RETURN LLVMRaw.HasMetadata(Val);
  END HasMetadata;

PROCEDURE GetMetadata (Val: ValueRef; KindID: uint32_t; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetMetadata(Val, KindID);
  END GetMetadata;

PROCEDURE SetMetadata (Val: ValueRef; KindID: uint32_t; Node: ValueRef; ) =
  BEGIN
    LLVMRaw.SetMetadata(Val, KindID, Node);
  END SetMetadata;

PROCEDURE InstructionGetAllMetadataOtherThanDebugLoc
  (Instr: ValueRef; VAR NumEntries: Word.T; ):
  UNTRACED REF ValueMetadataEntryRef =
  BEGIN
    RETURN LLVMRaw.InstructionGetAllMetadataOtherThanDebugLoc(
             Instr, NumEntries);
  END InstructionGetAllMetadataOtherThanDebugLoc;

PROCEDURE GetInstructionParent (Inst: ValueRef; ): BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetInstructionParent(Inst);
  END GetInstructionParent;

PROCEDURE GetNextInstruction (Inst: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetNextInstruction(Inst);
  END GetNextInstruction;

PROCEDURE GetPreviousInstruction (Inst: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetPreviousInstruction(Inst);
  END GetPreviousInstruction;

PROCEDURE InstructionRemoveFromParent (Inst: ValueRef; ) =
  BEGIN
    LLVMRaw.InstructionRemoveFromParent(Inst);
  END InstructionRemoveFromParent;

PROCEDURE InstructionEraseFromParent (Inst: ValueRef; ) =
  BEGIN
    LLVMRaw.InstructionEraseFromParent(Inst);
  END InstructionEraseFromParent;

PROCEDURE DeleteInstruction (Inst: ValueRef; ) =
  BEGIN
    LLVMRaw.DeleteInstruction(Inst);
  END DeleteInstruction;

PROCEDURE GetInstructionOpcode (Inst: ValueRef; ): LLVMOpcode =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetInstructionOpcode(Inst);
    RETURN VAL(ret, LLVMOpcode);
  END GetInstructionOpcode;

PROCEDURE GetICmpPredicate (Inst: ValueRef; ): LLVMIntPredicate =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetICmpPredicate(Inst);
    RETURN VAL(ret, LLVMIntPredicate);
  END GetICmpPredicate;

PROCEDURE GetICmpSameSign (Inst: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.GetICmpSameSign(Inst);
  END GetICmpSameSign;

PROCEDURE SetICmpSameSign (Inst: ValueRef; SameSign: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetICmpSameSign(Inst, SameSign);
  END SetICmpSameSign;

PROCEDURE GetFCmpPredicate (Inst: ValueRef; ): LLVMRealPredicate =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetFCmpPredicate(Inst);
    RETURN VAL(ret, LLVMRealPredicate);
  END GetFCmpPredicate;

PROCEDURE InstructionClone (Inst: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.InstructionClone(Inst);
  END InstructionClone;

PROCEDURE IsATerminatorInst (Inst: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.IsATerminatorInst(Inst);
  END IsATerminatorInst;

PROCEDURE GetFirstDbgRecord (Inst: ValueRef; ): DbgRecordRef =
  BEGIN
    RETURN LLVMRaw.GetFirstDbgRecord(Inst);
  END GetFirstDbgRecord;

PROCEDURE GetLastDbgRecord (Inst: ValueRef; ): DbgRecordRef =
  BEGIN
    RETURN LLVMRaw.GetLastDbgRecord(Inst);
  END GetLastDbgRecord;

PROCEDURE GetNextDbgRecord (DbgRecord: DbgRecordRef; ): DbgRecordRef =
  BEGIN
    RETURN LLVMRaw.GetNextDbgRecord(DbgRecord);
  END GetNextDbgRecord;

PROCEDURE GetPreviousDbgRecord (DbgRecord: DbgRecordRef; ): DbgRecordRef =
  BEGIN
    RETURN LLVMRaw.GetPreviousDbgRecord(DbgRecord);
  END GetPreviousDbgRecord;

PROCEDURE GetNumArgOperands (Instr: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetNumArgOperands(Instr);
  END GetNumArgOperands;

PROCEDURE SetInstructionCallConv (Instr: ValueRef; CC: uint32_t; ) =
  BEGIN
    LLVMRaw.SetInstructionCallConv(Instr, CC);
  END SetInstructionCallConv;

PROCEDURE GetInstructionCallConv (Instr: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetInstructionCallConv(Instr);
  END GetInstructionCallConv;

PROCEDURE SetInstrParamAlignment
  (Instr: ValueRef; Idx: AttributeIndex; Align: uint32_t; ) =
  BEGIN
    LLVMRaw.SetInstrParamAlignment(Instr, Idx, Align);
  END SetInstrParamAlignment;

PROCEDURE AddCallSiteAttribute
  (context: ValueRef; Idx: AttributeIndex; A: AttributeRef; ) =
  BEGIN
    LLVMRaw.AddCallSiteAttribute(context, Idx, A);
  END AddCallSiteAttribute;

PROCEDURE GetCallSiteAttributeCount
  (context: ValueRef; Idx: AttributeIndex; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetCallSiteAttributeCount(context, Idx);
  END GetCallSiteAttributeCount;

PROCEDURE GetCallSiteAttributes (context: ValueRef;
                                 Idx    : AttributeIndex;
                                 Attrs  : UNTRACED REF AttributeRef; ) =
  BEGIN
    LLVMRaw.GetCallSiteAttributes(context, Idx, Attrs);
  END GetCallSiteAttributes;

PROCEDURE GetCallSiteEnumAttribute
  (context: ValueRef; Idx: AttributeIndex; KindID: uint32_t; ):
  AttributeRef =
  BEGIN
    RETURN LLVMRaw.GetCallSiteEnumAttribute(context, Idx, KindID);
  END GetCallSiteEnumAttribute;

PROCEDURE GetCallSiteStringAttribute
  (context: ValueRef; Idx: AttributeIndex; K: TEXT; KLen: uint32_t; ):
  AttributeRef =
  VAR
    arg3  : C.char_star;
    result: AttributeRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(K);
    result := LLVMRaw.GetCallSiteStringAttribute(context, Idx, arg3, KLen);
    M3toC.FreeSharedS(K, arg3);
    RETURN result;
  END GetCallSiteStringAttribute;

PROCEDURE RemoveCallSiteEnumAttribute
  (context: ValueRef; Idx: AttributeIndex; KindID: uint32_t; ) =
  BEGIN
    LLVMRaw.RemoveCallSiteEnumAttribute(context, Idx, KindID);
  END RemoveCallSiteEnumAttribute;

PROCEDURE RemoveCallSiteStringAttribute
  (context: ValueRef; Idx: AttributeIndex; K: TEXT; KLen: uint32_t; ) =
  VAR arg3: C.char_star;
  BEGIN
    arg3 := M3toC.SharedTtoS(K);
    LLVMRaw.RemoveCallSiteStringAttribute(context, Idx, arg3, KLen);
    M3toC.FreeSharedS(K, arg3);
  END RemoveCallSiteStringAttribute;

PROCEDURE GetCalledFunctionType (context: ValueRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.GetCalledFunctionType(context);
  END GetCalledFunctionType;

PROCEDURE GetCalledValue (Instr: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetCalledValue(Instr);
  END GetCalledValue;

PROCEDURE GetNumOperandBundles (context: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetNumOperandBundles(context);
  END GetNumOperandBundles;

PROCEDURE GetOperandBundleAtIndex (context: ValueRef; Index: uint32_t; ):
  OperandBundleRef =
  BEGIN
    RETURN LLVMRaw.GetOperandBundleAtIndex(context, Index);
  END GetOperandBundleAtIndex;

PROCEDURE IsTailCall (CallInst: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsTailCall(CallInst);
  END IsTailCall;

PROCEDURE SetTailCall (CallInst: ValueRef; IsTailCall: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetTailCall(CallInst, IsTailCall);
  END SetTailCall;

PROCEDURE GetTailCallKind (CallInst: ValueRef; ): LLVMTailCallKind =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetTailCallKind(CallInst);
    RETURN VAL(ret, LLVMTailCallKind);
  END GetTailCallKind;

PROCEDURE SetTailCallKind (CallInst: ValueRef; kind: LLVMTailCallKind; ) =
  VAR arg2tmp: C.int;
  BEGIN
    arg2tmp := ORD(kind);
    LLVMRaw.SetTailCallKind(CallInst, arg2tmp);
  END SetTailCallKind;

PROCEDURE GetNormalDest (InvokeInst: ValueRef; ): BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetNormalDest(InvokeInst);
  END GetNormalDest;

PROCEDURE GetUnwindDest (InvokeInst: ValueRef; ): BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetUnwindDest(InvokeInst);
  END GetUnwindDest;

PROCEDURE SetNormalDest (InvokeInst: ValueRef; B: BasicBlockRef; ) =
  BEGIN
    LLVMRaw.SetNormalDest(InvokeInst, B);
  END SetNormalDest;

PROCEDURE SetUnwindDest (InvokeInst: ValueRef; B: BasicBlockRef; ) =
  BEGIN
    LLVMRaw.SetUnwindDest(InvokeInst, B);
  END SetUnwindDest;

PROCEDURE GetCallBrDefaultDest (CallBr: ValueRef; ): BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetCallBrDefaultDest(CallBr);
  END GetCallBrDefaultDest;

PROCEDURE GetCallBrNumIndirectDests (CallBr: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetCallBrNumIndirectDests(CallBr);
  END GetCallBrNumIndirectDests;

PROCEDURE GetCallBrIndirectDest (CallBr: ValueRef; Idx: uint32_t; ):
  BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetCallBrIndirectDest(CallBr, Idx);
  END GetCallBrIndirectDest;

PROCEDURE GetNumSuccessors (Term: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetNumSuccessors(Term);
  END GetNumSuccessors;

PROCEDURE GetSuccessor (Term: ValueRef; i: uint32_t; ): BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetSuccessor(Term, i);
  END GetSuccessor;

PROCEDURE SetSuccessor
  (Term: ValueRef; i: uint32_t; block: BasicBlockRef; ) =
  BEGIN
    LLVMRaw.SetSuccessor(Term, i, block);
  END SetSuccessor;

PROCEDURE IsConditional (Branch: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsConditional(Branch);
  END IsConditional;

PROCEDURE GetCondition (Branch: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetCondition(Branch);
  END GetCondition;

PROCEDURE SetCondition (Branch, Cond: ValueRef; ) =
  BEGIN
    LLVMRaw.SetCondition(Branch, Cond);
  END SetCondition;

PROCEDURE GetSwitchDefaultDest (SwitchInstr: ValueRef; ): BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetSwitchDefaultDest(SwitchInstr);
  END GetSwitchDefaultDest;

PROCEDURE GetAllocatedType (Alloca: ValueRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.GetAllocatedType(Alloca);
  END GetAllocatedType;

PROCEDURE IsInBounds (GEP: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsInBounds(GEP);
  END IsInBounds;

PROCEDURE SetIsInBounds (GEP: ValueRef; InBounds: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetIsInBounds(GEP, InBounds);
  END SetIsInBounds;

PROCEDURE GetGEPSourceElementType (GEP: ValueRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.GetGEPSourceElementType(GEP);
  END GetGEPSourceElementType;

PROCEDURE GEPGetNoWrapFlags (GEP: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GEPGetNoWrapFlags(GEP);
  END GEPGetNoWrapFlags;

PROCEDURE GEPSetNoWrapFlags (GEP: ValueRef; NoWrapFlags: uint32_t; ) =
  BEGIN
    LLVMRaw.GEPSetNoWrapFlags(GEP, NoWrapFlags);
  END GEPSetNoWrapFlags;

PROCEDURE AddIncoming (PhiNode       : ValueRef;
                       IncomingValues: UNTRACED REF ValueRef;
                       IncomingBlocks: UNTRACED REF BasicBlockRef;
                       Count         : uint32_t;                   ) =
  BEGIN
    LLVMRaw.AddIncoming(PhiNode, IncomingValues, IncomingBlocks, Count);
  END AddIncoming;

PROCEDURE CountIncoming (PhiNode: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.CountIncoming(PhiNode);
  END CountIncoming;

PROCEDURE GetIncomingValue (PhiNode: ValueRef; Index: uint32_t; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.GetIncomingValue(PhiNode, Index);
  END GetIncomingValue;

PROCEDURE GetIncomingBlock (PhiNode: ValueRef; Index: uint32_t; ):
  BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetIncomingBlock(PhiNode, Index);
  END GetIncomingBlock;

PROCEDURE GetNumIndices (Inst: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetNumIndices(Inst);
  END GetNumIndices;

PROCEDURE GetIndices (Inst: ValueRef; ): UNTRACED REF uint32_t =
  BEGIN
    RETURN LLVMRaw.GetIndices(Inst);
  END GetIndices;

PROCEDURE CreateBuilderInContext (context: ContextRef; ): BuilderRef =
  BEGIN
    RETURN LLVMRaw.CreateBuilderInContext(context);
  END CreateBuilderInContext;

PROCEDURE CreateBuilder (): BuilderRef =
  BEGIN
    RETURN LLVMRaw.CreateBuilder();
  END CreateBuilder;

PROCEDURE PositionBuilder
  (Builder: BuilderRef; Block: BasicBlockRef; Instr: ValueRef; ) =
  BEGIN
    LLVMRaw.PositionBuilder(Builder, Block, Instr);
  END PositionBuilder;

PROCEDURE PositionBuilderBeforeDbgRecords
  (Builder: BuilderRef; Block: BasicBlockRef; Inst: ValueRef; ) =
  BEGIN
    LLVMRaw.PositionBuilderBeforeDbgRecords(Builder, Block, Inst);
  END PositionBuilderBeforeDbgRecords;

PROCEDURE PositionBuilderBefore (Builder: BuilderRef; Instr: ValueRef; ) =
  BEGIN
    LLVMRaw.PositionBuilderBefore(Builder, Instr);
  END PositionBuilderBefore;

PROCEDURE PositionBuilderBeforeInstrAndDbgRecords
  (Builder: BuilderRef; Instr: ValueRef; ) =
  BEGIN
    LLVMRaw.PositionBuilderBeforeInstrAndDbgRecords(Builder, Instr);
  END PositionBuilderBeforeInstrAndDbgRecords;

PROCEDURE PositionBuilderAtEnd
  (Builder: BuilderRef; Block: BasicBlockRef; ) =
  BEGIN
    LLVMRaw.PositionBuilderAtEnd(Builder, Block);
  END PositionBuilderAtEnd;

PROCEDURE GetInsertBlock (Builder: BuilderRef; ): BasicBlockRef =
  BEGIN
    RETURN LLVMRaw.GetInsertBlock(Builder);
  END GetInsertBlock;

PROCEDURE ClearInsertionPosition (Builder: BuilderRef; ) =
  BEGIN
    LLVMRaw.ClearInsertionPosition(Builder);
  END ClearInsertionPosition;

PROCEDURE InsertIntoBuilder (Builder: BuilderRef; Instr: ValueRef; ) =
  BEGIN
    LLVMRaw.InsertIntoBuilder(Builder, Instr);
  END InsertIntoBuilder;

PROCEDURE InsertIntoBuilderWithName
  (Builder: BuilderRef; Instr: ValueRef; Name: TEXT; ) =
  VAR arg3: C.char_star;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    LLVMRaw.InsertIntoBuilderWithName(Builder, Instr, arg3);
    M3toC.FreeSharedS(Name, arg3);
  END InsertIntoBuilderWithName;

PROCEDURE DisposeBuilder (Builder: BuilderRef; ) =
  BEGIN
    LLVMRaw.DisposeBuilder(Builder);
  END DisposeBuilder;

PROCEDURE GetCurrentDebugLocation2 (Builder: BuilderRef; ): MetadataRef =
  BEGIN
    RETURN LLVMRaw.GetCurrentDebugLocation2(Builder);
  END GetCurrentDebugLocation2;

PROCEDURE SetCurrentDebugLocation2
  (Builder: BuilderRef; Loc: MetadataRef; ) =
  BEGIN
    LLVMRaw.SetCurrentDebugLocation2(Builder, Loc);
  END SetCurrentDebugLocation2;

PROCEDURE SetInstDebugLocation (Builder: BuilderRef; Inst: ValueRef; ) =
  BEGIN
    LLVMRaw.SetInstDebugLocation(Builder, Inst);
  END SetInstDebugLocation;

PROCEDURE AddMetadataToInst (Builder: BuilderRef; Inst: ValueRef; ) =
  BEGIN
    LLVMRaw.AddMetadataToInst(Builder, Inst);
  END AddMetadataToInst;

PROCEDURE BuilderGetDefaultFPMathTag (Builder: BuilderRef; ): MetadataRef =
  BEGIN
    RETURN LLVMRaw.BuilderGetDefaultFPMathTag(Builder);
  END BuilderGetDefaultFPMathTag;

PROCEDURE BuilderSetDefaultFPMathTag
  (Builder: BuilderRef; FPMathTag: MetadataRef; ) =
  BEGIN
    LLVMRaw.BuilderSetDefaultFPMathTag(Builder, FPMathTag);
  END BuilderSetDefaultFPMathTag;

PROCEDURE GetBuilderContext (Builder: BuilderRef; ): ContextRef =
  BEGIN
    RETURN LLVMRaw.GetBuilderContext(Builder);
  END GetBuilderContext;

PROCEDURE SetCurrentDebugLocation (Builder: BuilderRef; L: ValueRef; ) =
  BEGIN
    LLVMRaw.SetCurrentDebugLocation(Builder, L);
  END SetCurrentDebugLocation;

PROCEDURE GetCurrentDebugLocation (Builder: BuilderRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetCurrentDebugLocation(Builder);
  END GetCurrentDebugLocation;

PROCEDURE BuildRetVoid (arg1: BuilderRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildRetVoid(arg1);
  END BuildRetVoid;

PROCEDURE BuildRet (arg1: BuilderRef; V: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildRet(arg1, V);
  END BuildRet;

PROCEDURE BuildAggregateRet
  (arg1: BuilderRef; RetVals: UNTRACED REF ValueRef; N: uint32_t; ):
  ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildAggregateRet(arg1, RetVals, N);
  END BuildAggregateRet;

PROCEDURE BuildBr (arg1: BuilderRef; Dest: BasicBlockRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildBr(arg1, Dest);
  END BuildBr;

PROCEDURE BuildCondBr
  (arg1: BuilderRef; If: ValueRef; Then, Else: BasicBlockRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildCondBr(arg1, If, Then, Else);
  END BuildCondBr;

PROCEDURE BuildSwitch (arg1    : BuilderRef;
                       V       : ValueRef;
                       Else    : BasicBlockRef;
                       NumCases: uint32_t;      ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildSwitch(arg1, V, Else, NumCases);
  END BuildSwitch;

PROCEDURE BuildIndirectBr
  (B: BuilderRef; Addr: ValueRef; NumDests: uint32_t; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildIndirectBr(B, Addr, NumDests);
  END BuildIndirectBr;

PROCEDURE BuildCallBr (B               : BuilderRef;
                       Ty              : TypeRef;
                       Fn              : ValueRef;
                       DefaultDest     : BasicBlockRef;
                       IndirectDests   : UNTRACED REF BasicBlockRef;
                       NumIndirectDests: uint32_t;
                       Args            : UNTRACED REF ValueRef;
                       NumArgs         : uint32_t;
                       Bundles         : UNTRACED REF OperandBundleRef;
                       NumBundles      : uint32_t;
                       Name            : TEXT;                          ):
  ValueRef =
  VAR
    arg11 : C.char_star;
    result: ValueRef;
  BEGIN
    arg11 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildCallBr(
                B, Ty, Fn, DefaultDest, IndirectDests, NumIndirectDests,
                Args, NumArgs, Bundles, NumBundles, arg11);
    M3toC.FreeSharedS(Name, arg11);
    RETURN result;
  END BuildCallBr;

PROCEDURE BuildInvoke2 (arg1       : BuilderRef;
                        Ty         : TypeRef;
                        Fn         : ValueRef;
                        Args       : UNTRACED REF ValueRef;
                        NumArgs    : uint32_t;
                        Then, Catch: BasicBlockRef;
                        Name       : TEXT;                  ): ValueRef =
  VAR
    arg8  : C.char_star;
    result: ValueRef;
  BEGIN
    arg8 := M3toC.SharedTtoS(Name);
    result :=
      LLVMRaw.BuildInvoke2(arg1, Ty, Fn, Args, NumArgs, Then, Catch, arg8);
    M3toC.FreeSharedS(Name, arg8);
    RETURN result;
  END BuildInvoke2;

PROCEDURE BuildInvokeWithOperandBundles
  (arg1       : BuilderRef;
   Ty         : TypeRef;
   Fn         : ValueRef;
   Args       : UNTRACED REF ValueRef;
   NumArgs    : uint32_t;
   Then, Catch: BasicBlockRef;
   Bundles    : UNTRACED REF OperandBundleRef;
   NumBundles : uint32_t;
   Name       : TEXT;                          ): ValueRef =
  VAR
    arg10 : C.char_star;
    result: ValueRef;
  BEGIN
    arg10 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildInvokeWithOperandBundles(
                arg1, Ty, Fn, Args, NumArgs, Then, Catch, Bundles,
                NumBundles, arg10);
    M3toC.FreeSharedS(Name, arg10);
    RETURN result;
  END BuildInvokeWithOperandBundles;

PROCEDURE BuildUnreachable (arg1: BuilderRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildUnreachable(arg1);
  END BuildUnreachable;

PROCEDURE BuildResume (B: BuilderRef; Exn: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildResume(B, Exn);
  END BuildResume;

PROCEDURE BuildLandingPad (B         : BuilderRef;
                           Ty        : TypeRef;
                           PersFn    : ValueRef;
                           NumClauses: uint32_t;
                           Name      : TEXT;       ): ValueRef =
  VAR
    arg5  : C.char_star;
    result: ValueRef;
  BEGIN
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildLandingPad(B, Ty, PersFn, NumClauses, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildLandingPad;

PROCEDURE BuildCleanupRet
  (B: BuilderRef; CatchPad: ValueRef; BB: BasicBlockRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildCleanupRet(B, CatchPad, BB);
  END BuildCleanupRet;

PROCEDURE BuildCatchRet
  (B: BuilderRef; CatchPad: ValueRef; BB: BasicBlockRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildCatchRet(B, CatchPad, BB);
  END BuildCatchRet;

PROCEDURE BuildCatchPad (B        : BuilderRef;
                         ParentPad: ValueRef;
                         Args     : UNTRACED REF ValueRef;
                         NumArgs  : uint32_t;
                         Name     : TEXT;                  ): ValueRef =
  VAR
    arg5  : C.char_star;
    result: ValueRef;
  BEGIN
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildCatchPad(B, ParentPad, Args, NumArgs, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildCatchPad;

PROCEDURE BuildCleanupPad (B        : BuilderRef;
                           ParentPad: ValueRef;
                           Args     : UNTRACED REF ValueRef;
                           NumArgs  : uint32_t;
                           Name     : TEXT;                  ): ValueRef =
  VAR
    arg5  : C.char_star;
    result: ValueRef;
  BEGIN
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildCleanupPad(B, ParentPad, Args, NumArgs, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildCleanupPad;

PROCEDURE BuildCatchSwitch (B          : BuilderRef;
                            ParentPad  : ValueRef;
                            UnwindBB   : BasicBlockRef;
                            NumHandlers: uint32_t;
                            Name       : TEXT;          ): ValueRef =
  VAR
    arg5  : C.char_star;
    result: ValueRef;
  BEGIN
    arg5 := M3toC.SharedTtoS(Name);
    result :=
      LLVMRaw.BuildCatchSwitch(B, ParentPad, UnwindBB, NumHandlers, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildCatchSwitch;

PROCEDURE AddCase (Switch, OnVal: ValueRef; Dest: BasicBlockRef; ) =
  BEGIN
    LLVMRaw.AddCase(Switch, OnVal, Dest);
  END AddCase;

PROCEDURE AddDestination (IndirectBr: ValueRef; Dest: BasicBlockRef; ) =
  BEGIN
    LLVMRaw.AddDestination(IndirectBr, Dest);
  END AddDestination;

PROCEDURE GetNumClauses (LandingPad: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetNumClauses(LandingPad);
  END GetNumClauses;

PROCEDURE GetClause (LandingPad: ValueRef; Idx: uint32_t; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetClause(LandingPad, Idx);
  END GetClause;

PROCEDURE AddClause (LandingPad, ClauseVal: ValueRef; ) =
  BEGIN
    LLVMRaw.AddClause(LandingPad, ClauseVal);
  END AddClause;

PROCEDURE IsCleanup (LandingPad: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsCleanup(LandingPad);
  END IsCleanup;

PROCEDURE SetCleanup (LandingPad: ValueRef; Val: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetCleanup(LandingPad, Val);
  END SetCleanup;

PROCEDURE AddHandler (CatchSwitch: ValueRef; Dest: BasicBlockRef; ) =
  BEGIN
    LLVMRaw.AddHandler(CatchSwitch, Dest);
  END AddHandler;

PROCEDURE GetNumHandlers (CatchSwitch: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetNumHandlers(CatchSwitch);
  END GetNumHandlers;

PROCEDURE GetHandlers
  (CatchSwitch: ValueRef; Handlers: UNTRACED REF BasicBlockRef; ) =
  BEGIN
    LLVMRaw.GetHandlers(CatchSwitch, Handlers);
  END GetHandlers;

PROCEDURE GetArgOperand (Funclet: ValueRef; i: uint32_t; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetArgOperand(Funclet, i);
  END GetArgOperand;

PROCEDURE SetArgOperand
  (Funclet: ValueRef; i: uint32_t; value: ValueRef; ) =
  BEGIN
    LLVMRaw.SetArgOperand(Funclet, i, value);
  END SetArgOperand;

PROCEDURE GetParentCatchSwitch (CatchPad: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.GetParentCatchSwitch(CatchPad);
  END GetParentCatchSwitch;

PROCEDURE SetParentCatchSwitch (CatchPad, CatchSwitch: ValueRef; ) =
  BEGIN
    LLVMRaw.SetParentCatchSwitch(CatchPad, CatchSwitch);
  END SetParentCatchSwitch;

PROCEDURE BuildAdd (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildAdd(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildAdd;

PROCEDURE BuildNSWAdd (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildNSWAdd(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildNSWAdd;

PROCEDURE BuildNUWAdd (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildNUWAdd(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildNUWAdd;

PROCEDURE BuildFAdd (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFAdd(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildFAdd;

PROCEDURE BuildSub (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildSub(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildSub;

PROCEDURE BuildNSWSub (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildNSWSub(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildNSWSub;

PROCEDURE BuildNUWSub (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildNUWSub(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildNUWSub;

PROCEDURE BuildFSub (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFSub(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildFSub;

PROCEDURE BuildMul (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildMul(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildMul;

PROCEDURE BuildNSWMul (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildNSWMul(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildNSWMul;

PROCEDURE BuildNUWMul (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildNUWMul(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildNUWMul;

PROCEDURE BuildFMul (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFMul(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildFMul;

PROCEDURE BuildUDiv (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildUDiv(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildUDiv;

PROCEDURE BuildExactUDiv
  (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ): ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildExactUDiv(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildExactUDiv;

PROCEDURE BuildSDiv (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildSDiv(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildSDiv;

PROCEDURE BuildExactSDiv
  (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ): ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildExactSDiv(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildExactSDiv;

PROCEDURE BuildFDiv (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFDiv(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildFDiv;

PROCEDURE BuildURem (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildURem(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildURem;

PROCEDURE BuildSRem (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildSRem(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildSRem;

PROCEDURE BuildFRem (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFRem(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildFRem;

PROCEDURE BuildShl (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildShl(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildShl;

PROCEDURE BuildLShr (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildLShr(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildLShr;

PROCEDURE BuildAShr (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildAShr(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildAShr;

PROCEDURE BuildAnd (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildAnd(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildAnd;

PROCEDURE BuildOr (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildOr(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildOr;

PROCEDURE BuildXor (arg1: BuilderRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildXor(arg1, LHS, RHS, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildXor;

PROCEDURE BuildBinOp
  (B: BuilderRef; Op: LLVMOpcode; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg2tmp: C.int;
    arg5   : C.char_star;
    result : ValueRef;
  BEGIN
    arg2tmp := ORD(Op);
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildBinOp(B, arg2tmp, LHS, RHS, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildBinOp;

PROCEDURE BuildNeg (arg1: BuilderRef; V: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildNeg(arg1, V, arg3);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END BuildNeg;

PROCEDURE BuildNSWNeg (B: BuilderRef; V: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildNSWNeg(B, V, arg3);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END BuildNSWNeg;

PROCEDURE BuildFNeg (arg1: BuilderRef; V: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFNeg(arg1, V, arg3);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END BuildFNeg;

PROCEDURE BuildNot (arg1: BuilderRef; V: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildNot(arg1, V, arg3);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END BuildNot;

PROCEDURE GetNUW (ArithInst: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.GetNUW(ArithInst);
  END GetNUW;

PROCEDURE SetNUW (ArithInst: ValueRef; HasNUW: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetNUW(ArithInst, HasNUW);
  END SetNUW;

PROCEDURE GetNSW (ArithInst: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.GetNSW(ArithInst);
  END GetNSW;

PROCEDURE SetNSW (ArithInst: ValueRef; HasNSW: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetNSW(ArithInst, HasNSW);
  END SetNSW;

PROCEDURE GetExact (DivOrShrInst: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.GetExact(DivOrShrInst);
  END GetExact;

PROCEDURE SetExact (DivOrShrInst: ValueRef; IsExact: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetExact(DivOrShrInst, IsExact);
  END SetExact;

PROCEDURE GetNNeg (NonNegInst: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.GetNNeg(NonNegInst);
  END GetNNeg;

PROCEDURE SetNNeg (NonNegInst: ValueRef; IsNonNeg: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetNNeg(NonNegInst, IsNonNeg);
  END SetNNeg;

PROCEDURE GetFastMathFlags (FPMathInst: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetFastMathFlags(FPMathInst);
  END GetFastMathFlags;

PROCEDURE SetFastMathFlags (FPMathInst: ValueRef; FMF: uint32_t; ) =
  BEGIN
    LLVMRaw.SetFastMathFlags(FPMathInst, FMF);
  END SetFastMathFlags;

PROCEDURE CanValueUseFastMathFlags (Inst: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.CanValueUseFastMathFlags(Inst);
  END CanValueUseFastMathFlags;

PROCEDURE GetIsDisjoint (Inst: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.GetIsDisjoint(Inst);
  END GetIsDisjoint;

PROCEDURE SetIsDisjoint (Inst: ValueRef; IsDisjoint: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetIsDisjoint(Inst, IsDisjoint);
  END SetIsDisjoint;

PROCEDURE BuildMalloc (arg1: BuilderRef; Ty: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildMalloc(arg1, Ty, arg3);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END BuildMalloc;

PROCEDURE BuildArrayMalloc
  (arg1: BuilderRef; Ty: TypeRef; Val: ValueRef; Name: TEXT; ): ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildArrayMalloc(arg1, Ty, Val, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildArrayMalloc;

PROCEDURE BuildMemSet
  (B: BuilderRef; Ptr, Val, Len: ValueRef; Align: uint32_t; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildMemSet(B, Ptr, Val, Len, Align);
  END BuildMemSet;

PROCEDURE BuildMemCpy (B       : BuilderRef;
                       Dst     : ValueRef;
                       DstAlign: uint32_t;
                       Src     : ValueRef;
                       SrcAlign: uint32_t;
                       Size    : ValueRef;   ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildMemCpy(B, Dst, DstAlign, Src, SrcAlign, Size);
  END BuildMemCpy;

PROCEDURE BuildMemMove (B       : BuilderRef;
                        Dst     : ValueRef;
                        DstAlign: uint32_t;
                        Src     : ValueRef;
                        SrcAlign: uint32_t;
                        Size    : ValueRef;   ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildMemMove(B, Dst, DstAlign, Src, SrcAlign, Size);
  END BuildMemMove;

PROCEDURE BuildAlloca (arg1: BuilderRef; Ty: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildAlloca(arg1, Ty, arg3);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END BuildAlloca;

PROCEDURE BuildArrayAlloca
  (arg1: BuilderRef; Ty: TypeRef; Val: ValueRef; Name: TEXT; ): ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildArrayAlloca(arg1, Ty, Val, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildArrayAlloca;

PROCEDURE BuildFree (arg1: BuilderRef; PointerVal: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildFree(arg1, PointerVal);
  END BuildFree;

PROCEDURE BuildLoad2
  (arg1: BuilderRef; Ty: TypeRef; PointerVal: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildLoad2(arg1, Ty, PointerVal, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildLoad2;

PROCEDURE BuildStore (arg1: BuilderRef; Val, Ptr: ValueRef; ): ValueRef =
  BEGIN
    RETURN LLVMRaw.BuildStore(arg1, Val, Ptr);
  END BuildStore;

PROCEDURE BuildGEP2 (B         : BuilderRef;
                     Ty        : TypeRef;
                     Pointer   : ValueRef;
                     Indices   : UNTRACED REF ValueRef;
                     NumIndices: uint32_t;
                     Name      : TEXT;                  ): ValueRef =
  VAR
    arg6  : C.char_star;
    result: ValueRef;
  BEGIN
    arg6 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildGEP2(B, Ty, Pointer, Indices, NumIndices, arg6);
    M3toC.FreeSharedS(Name, arg6);
    RETURN result;
  END BuildGEP2;

PROCEDURE BuildInBoundsGEP2 (B         : BuilderRef;
                             Ty        : TypeRef;
                             Pointer   : ValueRef;
                             Indices   : UNTRACED REF ValueRef;
                             NumIndices: uint32_t;
                             Name      : TEXT;                  ):
  ValueRef =
  VAR
    arg6  : C.char_star;
    result: ValueRef;
  BEGIN
    arg6 := M3toC.SharedTtoS(Name);
    result :=
      LLVMRaw.BuildInBoundsGEP2(B, Ty, Pointer, Indices, NumIndices, arg6);
    M3toC.FreeSharedS(Name, arg6);
    RETURN result;
  END BuildInBoundsGEP2;

PROCEDURE BuildGEPWithNoWrapFlags (B          : BuilderRef;
                                   Ty         : TypeRef;
                                   Pointer    : ValueRef;
                                   Indices    : UNTRACED REF ValueRef;
                                   NumIndices : uint32_t;
                                   Name       : TEXT;
                                   NoWrapFlags: uint32_t;              ):
  ValueRef =
  VAR
    arg6  : C.char_star;
    result: ValueRef;
  BEGIN
    arg6 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildGEPWithNoWrapFlags(
                B, Ty, Pointer, Indices, NumIndices, arg6, NoWrapFlags);
    M3toC.FreeSharedS(Name, arg6);
    RETURN result;
  END BuildGEPWithNoWrapFlags;

PROCEDURE BuildStructGEP2 (B      : BuilderRef;
                           Ty     : TypeRef;
                           Pointer: ValueRef;
                           Idx    : uint32_t;
                           Name   : TEXT;       ): ValueRef =
  VAR
    arg5  : C.char_star;
    result: ValueRef;
  BEGIN
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildStructGEP2(B, Ty, Pointer, Idx, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildStructGEP2;

PROCEDURE BuildGlobalString (B: BuilderRef; Str, Name: TEXT; ): ValueRef =
  VAR
    arg2  : C.char_star;
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Str);
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildGlobalString(B, arg2, arg3);
    M3toC.FreeSharedS(Str, arg2);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END BuildGlobalString;

PROCEDURE BuildGlobalStringPtr (B: BuilderRef; Str, Name: TEXT; ):
  ValueRef =
  VAR
    arg2  : C.char_star;
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg2 := M3toC.SharedTtoS(Str);
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildGlobalStringPtr(B, arg2, arg3);
    M3toC.FreeSharedS(Str, arg2);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END BuildGlobalStringPtr;

PROCEDURE GetVolatile (MemoryAccessInst: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.GetVolatile(MemoryAccessInst);
  END GetVolatile;

PROCEDURE SetVolatile (MemoryAccessInst: ValueRef; IsVolatile: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetVolatile(MemoryAccessInst, IsVolatile);
  END SetVolatile;

PROCEDURE GetWeak (CmpXchgInst: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.GetWeak(CmpXchgInst);
  END GetWeak;

PROCEDURE SetWeak (CmpXchgInst: ValueRef; IsWeak: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetWeak(CmpXchgInst, IsWeak);
  END SetWeak;

PROCEDURE GetOrdering (MemoryAccessInst: ValueRef; ): LLVMAtomicOrdering =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetOrdering(MemoryAccessInst);
    RETURN VAL(ret, LLVMAtomicOrdering);
  END GetOrdering;

PROCEDURE SetOrdering
  (MemoryAccessInst: ValueRef; Ordering: LLVMAtomicOrdering; ) =
  VAR arg2tmp: C.int;
  BEGIN
    arg2tmp := ORD(Ordering);
    LLVMRaw.SetOrdering(MemoryAccessInst, arg2tmp);
  END SetOrdering;

PROCEDURE GetAtomicRMWBinOp (AtomicRMWInst: ValueRef; ):
  LLVMAtomicRMWBinOp =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetAtomicRMWBinOp(AtomicRMWInst);
    RETURN VAL(ret, LLVMAtomicRMWBinOp);
  END GetAtomicRMWBinOp;

PROCEDURE SetAtomicRMWBinOp
  (AtomicRMWInst: ValueRef; BinOp: LLVMAtomicRMWBinOp; ) =
  VAR arg2tmp: C.int;
  BEGIN
    arg2tmp := ORD(BinOp);
    LLVMRaw.SetAtomicRMWBinOp(AtomicRMWInst, arg2tmp);
  END SetAtomicRMWBinOp;

PROCEDURE BuildTrunc
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildTrunc(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildTrunc;

PROCEDURE BuildZExt
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildZExt(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildZExt;

PROCEDURE BuildSExt
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildSExt(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildSExt;

PROCEDURE BuildFPToUI
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFPToUI(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildFPToUI;

PROCEDURE BuildFPToSI
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFPToSI(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildFPToSI;

PROCEDURE BuildUIToFP
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildUIToFP(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildUIToFP;

PROCEDURE BuildSIToFP
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildSIToFP(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildSIToFP;

PROCEDURE BuildFPTrunc
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFPTrunc(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildFPTrunc;

PROCEDURE BuildFPExt
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFPExt(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildFPExt;

PROCEDURE BuildPtrToInt
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildPtrToInt(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildPtrToInt;

PROCEDURE BuildIntToPtr
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildIntToPtr(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildIntToPtr;

PROCEDURE BuildBitCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildBitCast(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildBitCast;

PROCEDURE BuildAddrSpaceCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildAddrSpaceCast(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildAddrSpaceCast;

PROCEDURE BuildZExtOrBitCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildZExtOrBitCast(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildZExtOrBitCast;

PROCEDURE BuildSExtOrBitCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildSExtOrBitCast(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildSExtOrBitCast;

PROCEDURE BuildTruncOrBitCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildTruncOrBitCast(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildTruncOrBitCast;

PROCEDURE BuildCast (B     : BuilderRef;
                     Op    : LLVMOpcode;
                     Val   : ValueRef;
                     DestTy: TypeRef;
                     Name  : TEXT;       ): ValueRef =
  VAR
    arg2tmp: C.int;
    arg5   : C.char_star;
    result : ValueRef;
  BEGIN
    arg2tmp := ORD(Op);
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildCast(B, arg2tmp, Val, DestTy, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildCast;

PROCEDURE BuildPointerCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildPointerCast(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildPointerCast;

PROCEDURE BuildIntCast2 (arg1    : BuilderRef;
                         Val     : ValueRef;
                         DestTy  : TypeRef;
                         IsSigned: BOOLEAN;
                         Name    : TEXT;       ): ValueRef =
  VAR
    arg5  : C.char_star;
    result: ValueRef;
  BEGIN
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildIntCast2(arg1, Val, DestTy, IsSigned, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildIntCast2;

PROCEDURE BuildFPCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFPCast(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildFPCast;

PROCEDURE BuildIntCast
  (arg1: BuilderRef; Val: ValueRef; DestTy: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildIntCast(arg1, Val, DestTy, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildIntCast;

PROCEDURE GetCastOpcode (Src         : ValueRef;
                         SrcIsSigned : BOOLEAN;
                         DestTy      : TypeRef;
                         DestIsSigned: BOOLEAN;  ): LLVMOpcode =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetCastOpcode(Src, SrcIsSigned, DestTy, DestIsSigned);
    RETURN VAL(ret, LLVMOpcode);
  END GetCastOpcode;

PROCEDURE BuildICmp (arg1    : BuilderRef;
                     Op      : LLVMIntPredicate;
                     LHS, RHS: ValueRef;
                     Name    : TEXT;             ): ValueRef =
  VAR
    arg2tmp: C.int;
    arg5   : C.char_star;
    result : ValueRef;
  BEGIN
    arg2tmp := ORD(Op);
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildICmp(arg1, arg2tmp, LHS, RHS, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildICmp;

PROCEDURE BuildFCmp (arg1    : BuilderRef;
                     Op      : LLVMRealPredicate;
                     LHS, RHS: ValueRef;
                     Name    : TEXT;              ): ValueRef =
  VAR
    arg2tmp: C.int;
    arg5   : C.char_star;
    result : ValueRef;
  BEGIN
    arg2tmp := ORD(Op);
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFCmp(arg1, arg2tmp, LHS, RHS, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildFCmp;

PROCEDURE BuildPhi (arg1: BuilderRef; Ty: TypeRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildPhi(arg1, Ty, arg3);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END BuildPhi;

PROCEDURE BuildCall2 (arg1   : BuilderRef;
                      arg2   : TypeRef;
                      Fn     : ValueRef;
                      Args   : UNTRACED REF ValueRef;
                      NumArgs: uint32_t;
                      Name   : TEXT;                  ): ValueRef =
  VAR
    arg6  : C.char_star;
    result: ValueRef;
  BEGIN
    arg6 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildCall2(arg1, arg2, Fn, Args, NumArgs, arg6);
    M3toC.FreeSharedS(Name, arg6);
    RETURN result;
  END BuildCall2;

PROCEDURE BuildCallWithOperandBundles
  (arg1      : BuilderRef;
   arg2      : TypeRef;
   Fn        : ValueRef;
   Args      : UNTRACED REF ValueRef;
   NumArgs   : uint32_t;
   Bundles   : UNTRACED REF OperandBundleRef;
   NumBundles: uint32_t;
   Name      : TEXT;                          ): ValueRef =
  VAR
    arg8  : C.char_star;
    result: ValueRef;
  BEGIN
    arg8 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildCallWithOperandBundles(
                arg1, arg2, Fn, Args, NumArgs, Bundles, NumBundles, arg8);
    M3toC.FreeSharedS(Name, arg8);
    RETURN result;
  END BuildCallWithOperandBundles;

PROCEDURE BuildSelect
  (arg1: BuilderRef; If, Then, Else: ValueRef; Name: TEXT; ): ValueRef =
  VAR
    arg5  : C.char_star;
    result: ValueRef;
  BEGIN
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildSelect(arg1, If, Then, Else, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildSelect;

PROCEDURE BuildVAArg
  (arg1: BuilderRef; List: ValueRef; Ty: TypeRef; Name: TEXT; ): ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildVAArg(arg1, List, Ty, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildVAArg;

PROCEDURE BuildExtractElement
  (arg1: BuilderRef; VecVal, Index: ValueRef; Name: TEXT; ): ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildExtractElement(arg1, VecVal, Index, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildExtractElement;

PROCEDURE BuildInsertElement
  (arg1: BuilderRef; VecVal, EltVal, Index: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg5  : C.char_star;
    result: ValueRef;
  BEGIN
    arg5 := M3toC.SharedTtoS(Name);
    result :=
      LLVMRaw.BuildInsertElement(arg1, VecVal, EltVal, Index, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildInsertElement;

PROCEDURE BuildShuffleVector
  (arg1: BuilderRef; V1, V2, Mask: ValueRef; Name: TEXT; ): ValueRef =
  VAR
    arg5  : C.char_star;
    result: ValueRef;
  BEGIN
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildShuffleVector(arg1, V1, V2, Mask, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildShuffleVector;

PROCEDURE BuildExtractValue
  (arg1: BuilderRef; AggVal: ValueRef; Index: uint32_t; Name: TEXT; ):
  ValueRef =
  VAR
    arg4  : C.char_star;
    result: ValueRef;
  BEGIN
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildExtractValue(arg1, AggVal, Index, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildExtractValue;

PROCEDURE BuildInsertValue (arg1          : BuilderRef;
                            AggVal, EltVal: ValueRef;
                            Index         : uint32_t;
                            Name          : TEXT;       ): ValueRef =
  VAR
    arg5  : C.char_star;
    result: ValueRef;
  BEGIN
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildInsertValue(arg1, AggVal, EltVal, Index, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildInsertValue;

PROCEDURE BuildFreeze (arg1: BuilderRef; Val: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFreeze(arg1, Val, arg3);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END BuildFreeze;

PROCEDURE BuildIsNull (arg1: BuilderRef; Val: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildIsNull(arg1, Val, arg3);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END BuildIsNull;

PROCEDURE BuildIsNotNull (arg1: BuilderRef; Val: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg3  : C.char_star;
    result: ValueRef;
  BEGIN
    arg3 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildIsNotNull(arg1, Val, arg3);
    M3toC.FreeSharedS(Name, arg3);
    RETURN result;
  END BuildIsNotNull;

PROCEDURE BuildPtrDiff2
  (arg1: BuilderRef; ElemTy: TypeRef; LHS, RHS: ValueRef; Name: TEXT; ):
  ValueRef =
  VAR
    arg5  : C.char_star;
    result: ValueRef;
  BEGIN
    arg5 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildPtrDiff2(arg1, ElemTy, LHS, RHS, arg5);
    M3toC.FreeSharedS(Name, arg5);
    RETURN result;
  END BuildPtrDiff2;

PROCEDURE BuildFence (B           : BuilderRef;
                      ordering    : LLVMAtomicOrdering;
                      singleThread: BOOLEAN;
                      Name        : TEXT;               ): ValueRef =
  VAR
    arg2tmp: C.int;
    arg4   : C.char_star;
    result : ValueRef;
  BEGIN
    arg2tmp := ORD(ordering);
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFence(B, arg2tmp, singleThread, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildFence;

PROCEDURE BuildFenceSyncScope (B       : BuilderRef;
                               ordering: LLVMAtomicOrdering;
                               SSID    : uint32_t;
                               Name    : TEXT;               ): ValueRef =
  VAR
    arg2tmp: C.int;
    arg4   : C.char_star;
    result : ValueRef;
  BEGIN
    arg2tmp := ORD(ordering);
    arg4 := M3toC.SharedTtoS(Name);
    result := LLVMRaw.BuildFenceSyncScope(B, arg2tmp, SSID, arg4);
    M3toC.FreeSharedS(Name, arg4);
    RETURN result;
  END BuildFenceSyncScope;

PROCEDURE BuildAtomicRMW (B           : BuilderRef;
                          op          : LLVMAtomicRMWBinOp;
                          PTR, Val    : ValueRef;
                          ordering    : LLVMAtomicOrdering;
                          singleThread: BOOLEAN;            ): ValueRef =
  VAR
    arg2tmp: C.int;
    arg5tmp: C.int;
  BEGIN
    arg2tmp := ORD(op);
    arg5tmp := ORD(ordering);
    RETURN
      LLVMRaw.BuildAtomicRMW(B, arg2tmp, PTR, Val, arg5tmp, singleThread);
  END BuildAtomicRMW;

PROCEDURE BuildAtomicRMWSyncScope (B       : BuilderRef;
                                   op      : LLVMAtomicRMWBinOp;
                                   PTR, Val: ValueRef;
                                   ordering: LLVMAtomicOrdering;
                                   SSID    : uint32_t;           ):
  ValueRef =
  VAR
    arg2tmp: C.int;
    arg5tmp: C.int;
  BEGIN
    arg2tmp := ORD(op);
    arg5tmp := ORD(ordering);
    RETURN
      LLVMRaw.BuildAtomicRMWSyncScope(B, arg2tmp, PTR, Val, arg5tmp, SSID);
  END BuildAtomicRMWSyncScope;

PROCEDURE BuildAtomicCmpXchg
  (B                               : BuilderRef;
   Ptr, Cmp, New                   : ValueRef;
   SuccessOrdering, FailureOrdering: LLVMAtomicOrdering;
   SingleThread                    : BOOLEAN;            ): ValueRef =
  VAR
    arg5tmp: C.int;
    arg6tmp: C.int;
  BEGIN
    arg5tmp := ORD(SuccessOrdering);
    arg6tmp := ORD(FailureOrdering);
    RETURN LLVMRaw.BuildAtomicCmpXchg(
             B, Ptr, Cmp, New, arg5tmp, arg6tmp, SingleThread);
  END BuildAtomicCmpXchg;

PROCEDURE BuildAtomicCmpXchgSyncScope
  (B                               : BuilderRef;
   Ptr, Cmp, New                   : ValueRef;
   SuccessOrdering, FailureOrdering: LLVMAtomicOrdering;
   SSID                            : uint32_t;           ): ValueRef =
  VAR
    arg5tmp: C.int;
    arg6tmp: C.int;
  BEGIN
    arg5tmp := ORD(SuccessOrdering);
    arg6tmp := ORD(FailureOrdering);
    RETURN LLVMRaw.BuildAtomicCmpXchgSyncScope(
             B, Ptr, Cmp, New, arg5tmp, arg6tmp, SSID);
  END BuildAtomicCmpXchgSyncScope;

PROCEDURE GetNumMaskElements (ShuffleVectorInst: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetNumMaskElements(ShuffleVectorInst);
  END GetNumMaskElements;

PROCEDURE GetUndefMaskElem (): INTEGER =
  BEGIN
    RETURN LLVMRaw.GetUndefMaskElem();
  END GetUndefMaskElem;

PROCEDURE GetMaskValue (ShuffleVectorInst: ValueRef; Elt: uint32_t; ):
  INTEGER =
  BEGIN
    RETURN LLVMRaw.GetMaskValue(ShuffleVectorInst, Elt);
  END GetMaskValue;

PROCEDURE IsAtomicSingleThread (AtomicInst: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsAtomicSingleThread(AtomicInst);
  END IsAtomicSingleThread;

PROCEDURE SetAtomicSingleThread
  (AtomicInst: ValueRef; SingleThread: BOOLEAN; ) =
  BEGIN
    LLVMRaw.SetAtomicSingleThread(AtomicInst, SingleThread);
  END SetAtomicSingleThread;

PROCEDURE IsAtomic (Inst: ValueRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsAtomic(Inst);
  END IsAtomic;

PROCEDURE GetAtomicSyncScopeID (AtomicInst: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.GetAtomicSyncScopeID(AtomicInst);
  END GetAtomicSyncScopeID;

PROCEDURE SetAtomicSyncScopeID (AtomicInst: ValueRef; SSID: uint32_t; ) =
  BEGIN
    LLVMRaw.SetAtomicSyncScopeID(AtomicInst, SSID);
  END SetAtomicSyncScopeID;

PROCEDURE GetCmpXchgSuccessOrdering (CmpXchgInst: ValueRef; ):
  LLVMAtomicOrdering =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetCmpXchgSuccessOrdering(CmpXchgInst);
    RETURN VAL(ret, LLVMAtomicOrdering);
  END GetCmpXchgSuccessOrdering;

PROCEDURE SetCmpXchgSuccessOrdering
  (CmpXchgInst: ValueRef; Ordering: LLVMAtomicOrdering; ) =
  VAR arg2tmp: C.int;
  BEGIN
    arg2tmp := ORD(Ordering);
    LLVMRaw.SetCmpXchgSuccessOrdering(CmpXchgInst, arg2tmp);
  END SetCmpXchgSuccessOrdering;

PROCEDURE GetCmpXchgFailureOrdering (CmpXchgInst: ValueRef; ):
  LLVMAtomicOrdering =
  VAR ret: C.int;
  BEGIN
    ret := LLVMRaw.GetCmpXchgFailureOrdering(CmpXchgInst);
    RETURN VAL(ret, LLVMAtomicOrdering);
  END GetCmpXchgFailureOrdering;

PROCEDURE SetCmpXchgFailureOrdering
  (CmpXchgInst: ValueRef; Ordering: LLVMAtomicOrdering; ) =
  VAR arg2tmp: C.int;
  BEGIN
    arg2tmp := ORD(Ordering);
    LLVMRaw.SetCmpXchgFailureOrdering(CmpXchgInst, arg2tmp);
  END SetCmpXchgFailureOrdering;

PROCEDURE CreateModuleProviderForExistingModule (M: ModuleRef; ):
  ModuleProviderRef =
  BEGIN
    RETURN LLVMRaw.CreateModuleProviderForExistingModule(M);
  END CreateModuleProviderForExistingModule;

PROCEDURE DisposeModuleProvider (M: ModuleProviderRef; ) =
  BEGIN
    LLVMRaw.DisposeModuleProvider(M);
  END DisposeModuleProvider;

PROCEDURE CreateMemoryBufferWithContentsOfFile
  (    Path      : TEXT;
       OutMemBuf : UNTRACED REF MemoryBufferRef;
   VAR OutMessage: TEXT;                         ): BOOLEAN =
  VAR
    arg1  : C.char_star;
    arg3  : C.char_star;
    result: BOOLEAN;
  BEGIN
    arg1 := M3toC.SharedTtoS(Path);
    arg3 := M3toC.SharedTtoS(OutMessage);
    result :=
      LLVMRaw.CreateMemoryBufferWithContentsOfFile(arg1, OutMemBuf, arg3);
    M3toC.FreeSharedS(Path, arg1);
    M3toC.FreeSharedS(OutMessage, arg3);
    RETURN result;
  END CreateMemoryBufferWithContentsOfFile;

PROCEDURE CreateMemoryBufferWithSTDIN
  (OutMemBuf: UNTRACED REF MemoryBufferRef; VAR OutMessage: TEXT; ):
  BOOLEAN =
  VAR
    arg2  : C.char_star;
    result: BOOLEAN;
  BEGIN
    arg2 := M3toC.SharedTtoS(OutMessage);
    result := LLVMRaw.CreateMemoryBufferWithSTDIN(OutMemBuf, arg2);
    M3toC.FreeSharedS(OutMessage, arg2);
    RETURN result;
  END CreateMemoryBufferWithSTDIN;

PROCEDURE CreateMemoryBufferWithMemoryRange
  (InputData             : TEXT;
   InputDataLength       : Word.T;
   BufferName            : TEXT;
   RequiresNullTerminator: BOOLEAN; ): MemoryBufferRef =
  VAR
    arg1  : C.char_star;
    arg3  : C.char_star;
    result: MemoryBufferRef;
  BEGIN
    arg1 := M3toC.SharedTtoS(InputData);
    arg3 := M3toC.SharedTtoS(BufferName);
    result := LLVMRaw.CreateMemoryBufferWithMemoryRange(
                arg1, InputDataLength, arg3, RequiresNullTerminator);
    M3toC.FreeSharedS(InputData, arg1);
    M3toC.FreeSharedS(BufferName, arg3);
    RETURN result;
  END CreateMemoryBufferWithMemoryRange;

PROCEDURE CreateMemoryBufferWithMemoryRangeCopy
  (InputData: TEXT; InputDataLength: Word.T; BufferName: TEXT; ):
  MemoryBufferRef =
  VAR
    arg1  : C.char_star;
    arg3  : C.char_star;
    result: MemoryBufferRef;
  BEGIN
    arg1 := M3toC.SharedTtoS(InputData);
    arg3 := M3toC.SharedTtoS(BufferName);
    result := LLVMRaw.CreateMemoryBufferWithMemoryRangeCopy(
                arg1, InputDataLength, arg3);
    M3toC.FreeSharedS(InputData, arg1);
    M3toC.FreeSharedS(BufferName, arg3);
    RETURN result;
  END CreateMemoryBufferWithMemoryRangeCopy;

PROCEDURE GetBufferStart (MemBuf: MemoryBufferRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.GetBufferStart(MemBuf);
    RETURN M3toC.CopyStoT(result);
  END GetBufferStart;

PROCEDURE GetBufferSize (MemBuf: MemoryBufferRef; ): Word.T =
  BEGIN
    RETURN LLVMRaw.GetBufferSize(MemBuf);
  END GetBufferSize;

PROCEDURE DisposeMemoryBuffer (MemBuf: MemoryBufferRef; ) =
  BEGIN
    LLVMRaw.DisposeMemoryBuffer(MemBuf);
  END DisposeMemoryBuffer;

PROCEDURE CreatePassManager (): PassManagerRef =
  BEGIN
    RETURN LLVMRaw.CreatePassManager();
  END CreatePassManager;

PROCEDURE CreateFunctionPassManagerForModule (M: ModuleRef; ):
  PassManagerRef =
  BEGIN
    RETURN LLVMRaw.CreateFunctionPassManagerForModule(M);
  END CreateFunctionPassManagerForModule;

PROCEDURE CreateFunctionPassManager (MP: ModuleProviderRef; ):
  PassManagerRef =
  BEGIN
    RETURN LLVMRaw.CreateFunctionPassManager(MP);
  END CreateFunctionPassManager;

PROCEDURE RunPassManager (PM: PassManagerRef; M: ModuleRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.RunPassManager(PM, M);
  END RunPassManager;

PROCEDURE InitializeFunctionPassManager (FPM: PassManagerRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.InitializeFunctionPassManager(FPM);
  END InitializeFunctionPassManager;

PROCEDURE RunFunctionPassManager (FPM: PassManagerRef; F: ValueRef; ):
  BOOLEAN =
  BEGIN
    RETURN LLVMRaw.RunFunctionPassManager(FPM, F);
  END RunFunctionPassManager;

PROCEDURE FinalizeFunctionPassManager (FPM: PassManagerRef; ): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.FinalizeFunctionPassManager(FPM);
  END FinalizeFunctionPassManager;

PROCEDURE DisposePassManager (PM: PassManagerRef; ) =
  BEGIN
    LLVMRaw.DisposePassManager(PM);
  END DisposePassManager;

PROCEDURE StartMultithreaded (): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.StartMultithreaded();
  END StartMultithreaded;

PROCEDURE StopMultithreaded () =
  BEGIN
    LLVMRaw.StopMultithreaded();
  END StopMultithreaded;

PROCEDURE IsMultithreaded (): BOOLEAN =
  BEGIN
    RETURN LLVMRaw.IsMultithreaded();
  END IsMultithreaded;

PROCEDURE WriteBitcodeToFile (M: ModuleRef; Path: TEXT; ): INTEGER =
  VAR
    arg2  : C.char_star;
    result: INTEGER;
  BEGIN
    arg2 := M3toC.SharedTtoS(Path);
    result := LLVMRaw.WriteBitcodeToFile(M, arg2);
    M3toC.FreeSharedS(Path, arg2);
    RETURN result;
  END WriteBitcodeToFile;

PROCEDURE WriteBitcodeToFD
  (M: ModuleRef; FD, ShouldClose, Unbuffered: INTEGER; ): INTEGER =
  BEGIN
    RETURN LLVMRaw.WriteBitcodeToFD(M, FD, ShouldClose, Unbuffered);
  END WriteBitcodeToFD;

PROCEDURE WriteBitcodeToFileHandle (M: ModuleRef; Handle: INTEGER; ):
  INTEGER =
  BEGIN
    RETURN LLVMRaw.WriteBitcodeToFileHandle(M, Handle);
  END WriteBitcodeToFileHandle;

PROCEDURE WriteBitcodeToMemoryBuffer (M: ModuleRef; ): MemoryBufferRef =
  BEGIN
    RETURN LLVMRaw.WriteBitcodeToMemoryBuffer(M);
  END WriteBitcodeToMemoryBuffer;

PROCEDURE GetModuleDataLayout (M: ModuleRef; ): TargetDataRef =
  BEGIN
    RETURN LLVMRaw.GetModuleDataLayout(M);
  END GetModuleDataLayout;

PROCEDURE SetModuleDataLayout (M: ModuleRef; DL: TargetDataRef; ) =
  BEGIN
    LLVMRaw.SetModuleDataLayout(M, DL);
  END SetModuleDataLayout;

PROCEDURE CreateTargetData (StringRep: TEXT; ): TargetDataRef =
  VAR
    arg1  : C.char_star;
    result: TargetDataRef;
  BEGIN
    arg1 := M3toC.SharedTtoS(StringRep);
    result := LLVMRaw.CreateTargetData(arg1);
    M3toC.FreeSharedS(StringRep, arg1);
    RETURN result;
  END CreateTargetData;

PROCEDURE DisposeTargetData (TD: TargetDataRef; ) =
  BEGIN
    LLVMRaw.DisposeTargetData(TD);
  END DisposeTargetData;

PROCEDURE AddTargetLibraryInfo
  (TLI: TargetLibraryInfoRef; PM: PassManagerRef; ) =
  BEGIN
    LLVMRaw.AddTargetLibraryInfo(TLI, PM);
  END AddTargetLibraryInfo;

PROCEDURE CopyStringRepOfTargetData (TD: TargetDataRef; ): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := LLVMRaw.CopyStringRepOfTargetData(TD);
    RETURN M3toC.CopyStoT(result);
  END CopyStringRepOfTargetData;

PROCEDURE ByteOrder (TD: TargetDataRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.ByteOrder(TD);
  END ByteOrder;

PROCEDURE PointerSize (TD: TargetDataRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.PointerSize(TD);
  END PointerSize;

PROCEDURE IntPtrType (TD: TargetDataRef; ): TypeRef =
  BEGIN
    RETURN LLVMRaw.IntPtrType(TD);
  END IntPtrType;

PROCEDURE IntPtrTypeInContext (context: ContextRef; TD: TargetDataRef; ):
  TypeRef =
  BEGIN
    RETURN LLVMRaw.IntPtrTypeInContext(context, TD);
  END IntPtrTypeInContext;

PROCEDURE SizeOfTypeInBits (TD: TargetDataRef; Ty: TypeRef; ): uint64_t =
  BEGIN
    RETURN LLVMRaw.SizeOfTypeInBits(TD, Ty);
  END SizeOfTypeInBits;

PROCEDURE StoreSizeOfType (TD: TargetDataRef; Ty: TypeRef; ): uint64_t =
  BEGIN
    RETURN LLVMRaw.StoreSizeOfType(TD, Ty);
  END StoreSizeOfType;

PROCEDURE ABISizeOfType (TD: TargetDataRef; Ty: TypeRef; ): uint64_t =
  BEGIN
    RETURN LLVMRaw.ABISizeOfType(TD, Ty);
  END ABISizeOfType;

PROCEDURE ABIAlignmentOfType (TD: TargetDataRef; Ty: TypeRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.ABIAlignmentOfType(TD, Ty);
  END ABIAlignmentOfType;

PROCEDURE CallFrameAlignmentOfType (TD: TargetDataRef; Ty: TypeRef; ):
  uint32_t =
  BEGIN
    RETURN LLVMRaw.CallFrameAlignmentOfType(TD, Ty);
  END CallFrameAlignmentOfType;

PROCEDURE PreferredAlignmentOfType (TD: TargetDataRef; Ty: TypeRef; ):
  uint32_t =
  BEGIN
    RETURN LLVMRaw.PreferredAlignmentOfType(TD, Ty);
  END PreferredAlignmentOfType;

PROCEDURE PreferredAlignmentOfGlobal
  (TD: TargetDataRef; GlobalVar: ValueRef; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.PreferredAlignmentOfGlobal(TD, GlobalVar);
  END PreferredAlignmentOfGlobal;

PROCEDURE ElementAtOffset
  (TD: TargetDataRef; StructTy: TypeRef; Offset: uint64_t; ): uint32_t =
  BEGIN
    RETURN LLVMRaw.ElementAtOffset(TD, StructTy, Offset);
  END ElementAtOffset;

PROCEDURE OffsetOfElement
  (TD: TargetDataRef; StructTy: TypeRef; Element: uint32_t; ): uint64_t =
  BEGIN
    RETURN LLVMRaw.OffsetOfElement(TD, StructTy, Element);
  END OffsetOfElement;


BEGIN
END LLVM.
