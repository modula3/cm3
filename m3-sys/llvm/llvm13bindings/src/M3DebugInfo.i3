(*******************************************************************************
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
*******************************************************************************)

INTERFACE M3DebugInfo;



IMPORT LLVMTypes;
FROM LLVMTypes IMPORT MetadataRef, int64_t, uint64_t, uint32_t, unsigned;
FROM LLVM IMPORT ModuleRef, BuilderRef, ContextRef, ValueRef, BasicBlockRef;
(* check this CONST DITypeEmpty : DIType = NIL; *)

TYPE uint = unsigned;



CONST                            (* Enum LLVMDIFlags *)
  DIFlagZero                = 0;
  DIFlagPrivate             = 1;
  DIFlagProtected           = 2;
  DIFlagPublic              = 3;
  DIFlagFwdDecl             = 4;
  DIFlagAppleBlock          = 8;
  DIFlagReservedBit4        = 16;
  DIFlagVirtual             = 32;
  DIFlagArtificial          = 64;
  DIFlagExplicit            = 128;
  DIFlagPrototyped          = 256;
  DIFlagObjcClassComplete   = 512;
  DIFlagObjectPointer       = 1024;
  DIFlagVector              = 2048;
  DIFlagStaticMember        = 4096;
  DIFlagLValueReference     = 8192;
  DIFlagRValueReference     = 16384;
  DIFlagReserved            = 32768;
  DIFlagSingleInheritance   = 65536;
  DIFlagMultipleInheritance = 131072;
  DIFlagVirtualInheritance  = 196608;
  DIFlagIntroducedVirtual   = 262144;
  DIFlagBitField            = 524288;
  DIFlagNoReturn            = 1048576;
  DIFlagTypePassByValue     = 4194304;
  DIFlagTypePassByReference = 8388608;
  DIFlagEnumClass           = 16777216;
  DIFlagFixedEnum           = 0;
  DIFlagThunk               = 33554432;
  DIFlagNonTrivial          = 67108864;
  DIFlagBigEndian           = 134217728;
  DIFlagLittleEndian        = 268435456;
  DIFlagIndirectVirtualBase = 36;
  DIFlagAccessibility       = 0;
  DIFlagPtrToMemberRep      = 0;

TYPE                             (* Enum LLVMDIFlags *)
  LLVMDIFlags = [0 .. 268435456];


TYPE
  LLVMDWARFSourceLanguage =
    {DWARFSourceLanguageC89, DWARFSourceLanguageC,
     DWARFSourceLanguageAda83, DWARFSourceLanguageCPlusPlus,
     DWARFSourceLanguageCobol74, DWARFSourceLanguageCobol85,
     DWARFSourceLanguageFortran77, DWARFSourceLanguageFortran90,
     DWARFSourceLanguagePascal83, DWARFSourceLanguageModula2,
     DWARFSourceLanguageJava, DWARFSourceLanguageC99,
     DWARFSourceLanguageAda95, DWARFSourceLanguageFortran95,
     DWARFSourceLanguagePLI, DWARFSourceLanguageObjC,
     DWARFSourceLanguageObjCPlusPlus, DWARFSourceLanguageUPC,
     DWARFSourceLanguageD, DWARFSourceLanguagePython,
     DWARFSourceLanguageOpenCL, DWARFSourceLanguageGo,
     DWARFSourceLanguageModula3, DWARFSourceLanguageHaskell,
     DWARFSourceLanguageCPlusPlus03, DWARFSourceLanguageCPlusPlus11,
     DWARFSourceLanguageOCaml, DWARFSourceLanguageRust,
     DWARFSourceLanguageC11, DWARFSourceLanguageSwift,
     DWARFSourceLanguageJulia, DWARFSourceLanguageDylan,
     DWARFSourceLanguageCPlusPlus14, DWARFSourceLanguageFortran03,
     DWARFSourceLanguageFortran08, DWARFSourceLanguageRenderScript,
     DWARFSourceLanguageBLISS, DWARFSourceLanguageMipsAssembler,
     DWARFSourceLanguageGOOGLERenderScript,
     DWARFSourceLanguageBORLANDDelphi};


TYPE
  LLVMDWARFEmissionKind =
    {DWARFEmissionNone, DWARFEmissionFull, DWARFEmissionLineTablesOnly};


TYPE
  Enum1 =
    {MDStringMetadataKind, ConstantAsMetadataMetadataKind,
     LocalAsMetadataMetadataKind, DistinctMDOperandPlaceholderMetadataKind,
     MDTupleMetadataKind, DILocationMetadataKind, DIExpressionMetadataKind,
     DIGlobalVariableExpressionMetadataKind, GenericDINodeMetadataKind,
     DISubrangeMetadataKind, DIEnumeratorMetadataKind,
     DIBasicTypeMetadataKind, DIDerivedTypeMetadataKind,
     DICompositeTypeMetadataKind, DISubroutineTypeMetadataKind,
     DIFileMetadataKind, DICompileUnitMetadataKind,
     DISubprogramMetadataKind, DILexicalBlockMetadataKind,
     DILexicalBlockFileMetadataKind, DINamespaceMetadataKind,
     DIModuleMetadataKind, DITemplateTypeParameterMetadataKind,
     DITemplateValueParameterMetadataKind, DIGlobalVariableMetadataKind,
     DILocalVariableMetadataKind, DILabelMetadataKind,
     DIObjCPropertyMetadataKind, DIImportedEntityMetadataKind,
     DIMacroMetadataKind, DIMacroFileMetadataKind,
     DICommonBlockMetadataKind, DIStringTypeMetadataKind,
     DIGenericSubrangeMetadataKind, DISubrangeTypeMetadataKind,
     DIArgListMetadataKind};


TYPE
  LLVMDWARFMacinfoRecordType =
    {XXXX_0, DWARFMacinfoRecordTypeDefine, DWARFMacinfoRecordTypeMacro,
     DWARFMacinfoRecordTypeStartFile, DWARFMacinfoRecordTypeEndFile,
     XXXX_5, XXXX_6, XXXX_7, XXXX_8, XXXX_9, XXXX_10, XXXX_11, XXXX_12,
     XXXX_13, XXXX_14, XXXX_15, XXXX_16, XXXX_17, XXXX_18, XXXX_19,
     XXXX_20, XXXX_21, XXXX_22, XXXX_23, XXXX_24, XXXX_25, XXXX_26,
     XXXX_27, XXXX_28, XXXX_29, XXXX_30, XXXX_31, XXXX_32, XXXX_33,
     XXXX_34, XXXX_35, XXXX_36, XXXX_37, XXXX_38, XXXX_39, XXXX_40,
     XXXX_41, XXXX_42, XXXX_43, XXXX_44, XXXX_45, XXXX_46, XXXX_47,
     XXXX_48, XXXX_49, XXXX_50, XXXX_51, XXXX_52, XXXX_53, XXXX_54,
     XXXX_55, XXXX_56, XXXX_57, XXXX_58, XXXX_59, XXXX_60, XXXX_61,
     XXXX_62, XXXX_63, XXXX_64, XXXX_65, XXXX_66, XXXX_67, XXXX_68,
     XXXX_69, XXXX_70, XXXX_71, XXXX_72, XXXX_73, XXXX_74, XXXX_75,
     XXXX_76, XXXX_77, XXXX_78, XXXX_79, XXXX_80, XXXX_81, XXXX_82,
     XXXX_83, XXXX_84, XXXX_85, XXXX_86, XXXX_87, XXXX_88, XXXX_89,
     XXXX_90, XXXX_91, XXXX_92, XXXX_93, XXXX_94, XXXX_95, XXXX_96,
     XXXX_97, XXXX_98, XXXX_99, XXXX_100, XXXX_101, XXXX_102, XXXX_103,
     XXXX_104, XXXX_105, XXXX_106, XXXX_107, XXXX_108, XXXX_109, XXXX_110,
     XXXX_111, XXXX_112, XXXX_113, XXXX_114, XXXX_115, XXXX_116, XXXX_117,
     XXXX_118, XXXX_119, XXXX_120, XXXX_121, XXXX_122, XXXX_123, XXXX_124,
     XXXX_125, XXXX_126, XXXX_127, XXXX_128, XXXX_129, XXXX_130, XXXX_131,
     XXXX_132, XXXX_133, XXXX_134, XXXX_135, XXXX_136, XXXX_137, XXXX_138,
     XXXX_139, XXXX_140, XXXX_141, XXXX_142, XXXX_143, XXXX_144, XXXX_145,
     XXXX_146, XXXX_147, XXXX_148, XXXX_149, XXXX_150, XXXX_151, XXXX_152,
     XXXX_153, XXXX_154, XXXX_155, XXXX_156, XXXX_157, XXXX_158, XXXX_159,
     XXXX_160, XXXX_161, XXXX_162, XXXX_163, XXXX_164, XXXX_165, XXXX_166,
     XXXX_167, XXXX_168, XXXX_169, XXXX_170, XXXX_171, XXXX_172, XXXX_173,
     XXXX_174, XXXX_175, XXXX_176, XXXX_177, XXXX_178, XXXX_179, XXXX_180,
     XXXX_181, XXXX_182, XXXX_183, XXXX_184, XXXX_185, XXXX_186, XXXX_187,
     XXXX_188, XXXX_189, XXXX_190, XXXX_191, XXXX_192, XXXX_193, XXXX_194,
     XXXX_195, XXXX_196, XXXX_197, XXXX_198, XXXX_199, XXXX_200, XXXX_201,
     XXXX_202, XXXX_203, XXXX_204, XXXX_205, XXXX_206, XXXX_207, XXXX_208,
     XXXX_209, XXXX_210, XXXX_211, XXXX_212, XXXX_213, XXXX_214, XXXX_215,
     XXXX_216, XXXX_217, XXXX_218, XXXX_219, XXXX_220, XXXX_221, XXXX_222,
     XXXX_223, XXXX_224, XXXX_225, XXXX_226, XXXX_227, XXXX_228, XXXX_229,
     XXXX_230, XXXX_231, XXXX_232, XXXX_233, XXXX_234, XXXX_235, XXXX_236,
     XXXX_237, XXXX_238, XXXX_239, XXXX_240, XXXX_241, XXXX_242, XXXX_243,
     XXXX_244, XXXX_245, XXXX_246, XXXX_247, XXXX_248, XXXX_249, XXXX_250,
     XXXX_251, XXXX_252, XXXX_253, XXXX_254,
     DWARFMacinfoRecordTypeVendorExt};


(**
 * The current debug metadata version number.
 *)

PROCEDURE LLVMDebugMetadataVersion (): CARDINAL;


(**
 * The version of debug metadata that's present in the provided <code>Module</code>.
 *)

PROCEDURE LLVMGetModuleDebugMetadataVersion (Module: ModuleRef; ):
  CARDINAL;


(**
 * Strip debug info in the module if it exists.<br>
 * To do this, we remove all calls to the debugger intrinsics and any named<br>
 * metadata for debugging. We also remove debug locations for instructions.<br>
 * Return true if module is modified.
 *)

PROCEDURE LLVMStripModuleDebugInfo (Module: ModuleRef; ): BOOLEAN;


(**
 * Construct a builder for a module, and do not allow for unresolved nodes<br>
 * attached to the module.
 *)

PROCEDURE LLVMCreateDIBuilderDisallowUnresolved (M: ModuleRef; ):
  BuilderRef;


(**
 * Construct a builder for a module and collect unresolved nodes attached<br>
 * to the module in order to resolve cycles during a call to<br>
 * <code>LLVMDIBuilderFinalize</code>.
 *)

PROCEDURE LLVMCreateDIBuilder (M: ModuleRef; ): BuilderRef;


(**
 * Deallocates the <code>DIBuilder</code> and everything it owns.<br>
 * Note: You must call <code>LLVMDIBuilderFinalize</code> before this
 *)

PROCEDURE LLVMDisposeDIBuilder (Builder: BuilderRef; );


(**
 * Construct any deferred debug info descriptors.
 *)

PROCEDURE Finalize (Builder: BuilderRef; );


(**
 * A CompileUnit provides an anchor for all debugging<br>
 * information generated during this instance of compilation.<br>
 * @param Lang          Source programming language, eg.<br>
 *                      <code>LLVMDWARFSourceLanguageC99</code><br>
 * @param FileRef       File info.<br>
 * @param Producer      Identify the producer of debugging information<br>
 *                      and code.  Usually this is a compiler<br>
 *                      version string.<br>
 * @param ProducerLen   The length of the C string passed to <code>Producer</code>.<br>
 * @param isOptimized   A boolean flag which indicates whether optimization<br>
 *                      is enabled or not.<br>
 * @param Flags         This string lists command line options. This<br>
 *                      string is directly embedded in debug info<br>
 *                      output which may be used by a tool<br>
 *                      analyzing generated debugging information.<br>
 * @param FlagsLen      The length of the C string passed to <code>Flags</code>.<br>
 * @param RuntimeVer    This indicates runtime version for languages like<br>
 *                      Objective-C.<br>
 * @param SplitName     The name of the file that we'll split debug info<br>
 *                      out into.<br>
 * @param SplitNameLen  The length of the C string passed to <code>SplitName</code>.<br>
 * @param Kind          The kind of debug information to generate.<br>
 * @param DWOId         The DWOId if this is a split skeleton compile unit.<br>
 * @param SplitDebugInlining    Whether to emit inline debug info.<br>
 * @param DebugInfoForProfiling Whether to emit extra debug info for<br>
 *                              profile collection.<br>
 * @param SysRoot         The Clang system root (value of -isysroot).<br>
 * @param SysRootLen      The length of the C string passed to <code>SysRoot</code>.<br>
 * @param SDK           The SDK. On Darwin, the last component of the sysroot.<br>
 * @param SDKLen        The length of the C string passed to <code>SDK</code>.
 *)

PROCEDURE CreateCompileUnit
  (Builder                                  : BuilderRef;
   Lang                                     : LLVMDWARFSourceLanguage;
   FileRef                                  : MetadataRef;
   Producer                                 : TEXT;
   ProducerLen                              : uint32_t;
   isOptimized                              : BOOLEAN;
   Flags                                    : TEXT;
   FlagsLen                                 : uint32_t;
   RuntimeVer                               : uint;
   SplitName                                : TEXT;
   SplitNameLen                             : uint32_t;
   Kind                                     : LLVMDWARFEmissionKind;
   DWOId                                    : uint;
   SplitDebugInlining, DebugInfoForProfiling: BOOLEAN;
   SysRoot                                  : TEXT;
   SysRootLen                               : uint32_t;
   SDK                                      : TEXT;
   SDKLen                                   : uint32_t;                ):
  MetadataRef;


(**
 * Create a file descriptor to hold debugging information for a file.<br>
 * @param Builder      The <code>DIBuilder</code>.<br>
 * @param Filename     File name.<br>
 * @param FilenameLen  The length of the C string passed to <code>Filename</code>.<br>
 * @param Directory    Directory.<br>
 * @param DirectoryLen The length of the C string passed to <code>Directory</code>.
 *)

PROCEDURE CreateFile (Builder     : BuilderRef;
                      Filename    : TEXT;
                      FilenameLen : uint32_t;
                      Directory   : TEXT;
                      DirectoryLen: uint32_t;   ): MetadataRef;


(**
 * Creates a new descriptor for a module with the specified parent scope.<br>
 * @param Builder         The <code>DIBuilder</code>.<br>
 * @param ParentScope     The parent scope containing this module declaration.<br>
 * @param Name            Module name.<br>
 * @param NameLen         The length of the C string passed to <code>Name</code>.<br>
 * @param ConfigMacros    A space-separated shell-quoted list of -D macro<br>
 *                           definitions as they would appear on a command line.<br>
 * @param ConfigMacrosLen The length of the C string passed to <code>ConfigMacros</code>.<br>
 * @param IncludePath     The path to the module map file.<br>
 * @param IncludePathLen  The length of the C string passed to <code>IncludePath</code>.<br>
 * @param APINotesFile    The path to an API notes file for the module.<br>
 * @param APINotesFileLen The length of the C string passed to <code>APINotestFile</code>.
 *)

PROCEDURE CreateModule (Builder        : BuilderRef;
                        ParentScope    : MetadataRef;
                        Name           : TEXT;
                        NameLen        : uint32_t;
                        ConfigMacros   : TEXT;
                        ConfigMacrosLen: uint32_t;
                        IncludePath    : TEXT;
                        IncludePathLen : uint32_t;
                        APINotesFile   : TEXT;
                        APINotesFileLen: uint32_t;    ): MetadataRef;


(**
 * Creates a new descriptor for a namespace with the specified parent scope.<br>
 * @param Builder          The <code>DIBuilder</code>.<br>
 * @param ParentScope      The parent scope containing this module declaration.<br>
 * @param Name             NameSpace name.<br>
 * @param NameLen          The length of the C string passed to <code>Name</code>.<br>
 * @param ExportSymbols    Whether or not the namespace exports symbols, e.g.<br>
 *                         this is true of C++ inline namespaces.
 *)

PROCEDURE CreateNameSpace (Builder      : BuilderRef;
                           ParentScope  : MetadataRef;
                           Name         : TEXT;
                           NameLen      : uint32_t;
                           ExportSymbols: BOOLEAN;     ): MetadataRef;


(**
 * Create a new descriptor for the specified subprogram.<br>
 * @param Builder         The <code>DIBuilder</code>.<br>
 * @param Scope           Function scope.<br>
 * @param Name            Function name.<br>
 * @param NameLen         Length of enumeration name.<br>
 * @param LinkageName     Mangled function name.<br>
 * @param LinkageNameLen  Length of linkage name.<br>
 * @param File            File where this variable is defined.<br>
 * @param LineNo          Line number.<br>
 * @param Ty              Function type.<br>
 * @param IsLocalToUnit   True if this function is not externally visible.<br>
 * @param IsDefinition    True if this is a function definition.<br>
 * @param ScopeLine       Set to the beginning of the scope this starts<br>
 * @param Flags           E.g.: <code>LLVMDIFlagLValueReference</code>. These flags are<br>
 *                        used to emit dwarf attributes.<br>
 * @param IsOptimized     True if optimization is ON.
 *)

PROCEDURE CreateFunction (Builder                    : BuilderRef;
                          Scope                      : MetadataRef;
                          Name                       : TEXT;
                          NameLen                    : uint32_t;
                          LinkageName                : TEXT;
                          LinkageNameLen             : uint32_t;
                          File                       : MetadataRef;
                          LineNo                     : uint;
                          Ty                         : MetadataRef;
                          IsLocalToUnit, IsDefinition: BOOLEAN;
                          ScopeLine                  : uint;
                          Flags                      : LLVMDIFlags;
                          IsOptimized                : BOOLEAN;     ):
  MetadataRef;


(**
 * Create a descriptor for a lexical block with the specified parent context.<br>
 * @param Builder      The <code>DIBuilder</code>.<br>
 * @param Scope        Parent lexical block.<br>
 * @param File         Source file.<br>
 * @param Line         The line in the source file.<br>
 * @param Column       The column in the source file.
 *)

PROCEDURE CreateLexicalBlock
  (Builder: BuilderRef; Scope, File: MetadataRef; Line, Column: uint; ):
  MetadataRef;


(**
 * Create a descriptor for a lexical block with a new file attached.<br>
 * @param Builder        The <code>DIBuilder</code>.<br>
 * @param Scope          Lexical block.<br>
 * @param File           Source file.<br>
 * @param Discriminator  DWARF path discriminator value.
 *)

PROCEDURE CreateLexicalBlockFile
  (Builder: BuilderRef; Scope, File: MetadataRef; Discriminator: uint; ):
  MetadataRef;


(**
 * Create a descriptor for an imported namespace. Suitable for e.g. C++<br>
 * using declarations.<br>
 * @param Builder    The <code>DIBuilder</code>.<br>
 * @param Scope      The scope this module is imported into<br>
 * @param File       File where the declaration is located.<br>
 * @param Line       Line number of the declaration.
 *)

PROCEDURE CreateImportedModuleFromNamespace
  (Builder: BuilderRef; Scope, NS, File: MetadataRef; Line: uint; ):
  MetadataRef;


(**
 * Create a descriptor for an imported module that aliases another<br>
 * imported entity descriptor.<br>
 * @param Builder        The <code>DIBuilder</code>.<br>
 * @param Scope          The scope this module is imported into<br>
 * @param ImportedEntity Previous imported entity to alias.<br>
 * @param File           File where the declaration is located.<br>
 * @param Line           Line number of the declaration.
 *)

PROCEDURE CreateImportedModuleFromAlias
  (Builder                    : BuilderRef;
   Scope, ImportedEntity, File: MetadataRef;
   Line                       : uint;        ): MetadataRef;


(**
 * Create a descriptor for an imported module.<br>
 * @param Builder    The <code>DIBuilder</code>.<br>
 * @param Scope      The scope this module is imported into<br>
 * @param M          The module being imported here<br>
 * @param File       File where the declaration is located.<br>
 * @param Line       Line number of the declaration.
 *)

PROCEDURE CreateImportedModuleFromModule
  (Builder: BuilderRef; Scope, M, File: MetadataRef; Line: uint; ):
  MetadataRef;


(**
 * Create a descriptor for an imported function, type, or variable.  Suitable<br>
 * for e.g. FORTRAN-style USE declarations.<br>
 * @param Builder    The DIBuilder.<br>
 * @param Scope      The scope this module is imported into.<br>
 * @param Decl       The declaration (or definition) of a function, type,<br>
 *                      or variable.<br>
 * @param File       File where the declaration is located.<br>
 * @param Line       Line number of the declaration.<br>
 * @param Name       A name that uniquely identifies this imported declaration.<br>
 * @param NameLen    The length of the C string passed to <code>Name</code>.
 *)

PROCEDURE CreateImportedDeclaration (Builder          : BuilderRef;
                                     Scope, Decl, File: MetadataRef;
                                     Line             : uint;
                                     Name             : TEXT;
                                     NameLen          : uint32_t;    ):
  MetadataRef;


(**
 * Creates a new DebugLocation that describes a source location.<br>
 * @param Line The line in the source file.<br>
 * @param Column The column in the source file.<br>
 * @param Scope The scope in which the location resides.<br>
 * @param InlinedAt The scope where this location was inlined, if at all.<br>
 *                  (optional).<br>
 * Note: If the item to which this location is attached cannot be<br>
 *       attributed to a source line, pass 0 for the line and column.
 *)

PROCEDURE CreateDebugLocation
  (Ctx: ContextRef; Line, Column: uint; Scope, InlinedAt: MetadataRef; ):
  MetadataRef;


(**
 * Get the line number of this debug location.<br>
 * @param Location     The debug location.<br>
 * <br>
 * @see DILocation#getLine()
 *)

PROCEDURE LLVMDILocationGetLine (Location: MetadataRef; ): CARDINAL;


(**
 * Get the column number of this debug location.<br>
 * @param Location     The debug location.<br>
 * <br>
 * @see DILocation#getColumn()
 *)

PROCEDURE LLVMDILocationGetColumn (Location: MetadataRef; ): CARDINAL;


(**
 * Get the local scope associated with this debug location.<br>
 * @param Location     The debug location.<br>
 * <br>
 * @see DILocation#getScope()
 *)

PROCEDURE LLVMDILocationGetScope (Location: MetadataRef; ): MetadataRef;


(**
 * Get the "inline at" location associated with this debug location.<br>
 * @param Location     The debug location.<br>
 * <br>
 * @see DILocation#getInlinedAt()
 *)

PROCEDURE LLVMDILocationGetInlinedAt (Location: MetadataRef; ):
  MetadataRef;


(**
 * Get the metadata of the file associated with a given scope.<br>
 * @param Scope     The scope object.<br>
 * <br>
 * @see DIScope#getFile()
 *)

PROCEDURE LLVMDIScopeGetFile (Scope: MetadataRef; ): MetadataRef;


(**
 * Get the directory of a given file.<br>
 * @param File     The file object.<br>
 * @param Len      The length of the returned string.<br>
 * <br>
 * @see DIFile#getDirectory()
 *)

PROCEDURE LLVMDIFileGetDirectory (File: MetadataRef; VAR Len: uint32_t; ):
  TEXT;


(**
 * Get the name of a given file.<br>
 * @param File     The file object.<br>
 * @param Len      The length of the returned string.<br>
 * <br>
 * @see DIFile#getFilename()
 *)

PROCEDURE LLVMDIFileGetFilename (File: MetadataRef; VAR Len: uint32_t; ):
  TEXT;


(**
 * Get the source of a given file.<br>
 * @param File     The file object.<br>
 * @param Len      The length of the returned string.<br>
 * <br>
 * @see DIFile#getSource()
 *)

PROCEDURE LLVMDIFileGetSource (File: MetadataRef; VAR Len: uint32_t; ):
  TEXT;


(**
 * Create a type array.<br>
 * @param Builder        The DIBuilder.<br>
 * @param Data           The type elements.<br>
 * @param NumElements    Number of type elements.
 *)

PROCEDURE GetOrCreateTypeArray (Builder    : BuilderRef;
                                Data       : UNTRACED REF MetadataRef;
                                NumElements: uint32_t;                 ):
  MetadataRef;


(**
 * Create subroutine type.<br>
 * @param Builder        The DIBuilder.<br>
 * @param File            The file in which the subroutine resides.<br>
 * @param ParameterTypes  An array of subroutine parameter types. This<br>
 *                        includes return type at 0th index.<br>
 * @param NumParameterTypes The number of parameter types in <code>ParameterTypes</code><br>
 * @param Flags           E.g.: <code>LLVMDIFlagLValueReference</code>.<br>
 *                        These flags are used to emit dwarf attributes.
 *)

PROCEDURE CreateSubroutineType (Builder       : BuilderRef;
                                File          : MetadataRef;
                                ParameterTypes: UNTRACED REF MetadataRef;
                                NumParameterTypes: uint;
                                Flags            : LLVMDIFlags; ):
  MetadataRef;


(**
 * Create debugging information entry for a macro.<br>
 * @param Builder         The DIBuilder.<br>
 * @param ParentMacroFile Macro parent (could be NULL).<br>
 * @param Line            Source line number where the macro is defined.<br>
 * @param RecordType      DW_MACINFO_define or DW_MACINFO_undef.<br>
 * @param Name            Macro name.<br>
 * @param NameLen         Macro name length.<br>
 * @param Value           Macro value.<br>
 * @param ValueLen        Macro value length.
 *)

PROCEDURE CreateMacro (Builder        : BuilderRef;
                       ParentMacroFile: MetadataRef;
                       Line           : uint;
                       RecordType     : LLVMDWARFMacinfoRecordType;
                       Name           : TEXT;
                       NameLen        : uint32_t;
                       Value          : TEXT;
                       ValueLen       : uint32_t;                   ):
  MetadataRef;


(**
 * Create debugging information temporary entry for a macro file.<br>
 * List of macro node direct children will be calculated by DIBuilder,<br>
 * using the <code>ParentMacroFile</code> relationship.<br>
 * @param Builder         The DIBuilder.<br>
 * @param ParentMacroFile Macro parent (could be NULL).<br>
 * @param Line            Source line number where the macro file is included.<br>
 * @param File            File descriptor containing the name of the macro file.
 *)

PROCEDURE CreateTempMacroFile (Builder        : BuilderRef;
                               ParentMacroFile: MetadataRef;
                               Line           : uint;
                               File           : MetadataRef; ):
  MetadataRef;


(**
 * Create debugging information entry for an enumerator.<br>
 * @param Builder        The DIBuilder.<br>
 * @param Name           Enumerator name.<br>
 * @param NameLen        Length of enumerator name.<br>
 * @param Value          Enumerator value.<br>
 * @param IsUnsigned     True if the value is unsigned.
 *)

PROCEDURE CreateEnumerator (Builder   : BuilderRef;
                            Name      : TEXT;
                            NameLen   : uint32_t;
                            Value     : int64_t;
                            IsUnsigned: BOOLEAN;    ): MetadataRef;


(**
 * Create debugging information entry for an enumeration.<br>
 * @param Builder        The DIBuilder.<br>
 * @param Scope          Scope in which this enumeration is defined.<br>
 * @param Name           Enumeration name.<br>
 * @param NameLen        Length of enumeration name.<br>
 * @param File           File where this member is defined.<br>
 * @param LineNumber     Line number.<br>
 * @param SizeInBits     Member size.<br>
 * @param AlignInBits    Member alignment.<br>
 * @param Elements       Enumeration elements.<br>
 * @param NumElements    Number of enumeration elements.<br>
 * @param ClassTy        Underlying type of a C++11/ObjC fixed enum.
 *)

PROCEDURE CreateEnumerationType (Builder    : BuilderRef;
                                 Scope      : MetadataRef;
                                 Name       : TEXT;
                                 NameLen    : uint32_t;
                                 File       : MetadataRef;
                                 LineNumber : uint;
                                 SizeInBits : uint64_t;
                                 AlignInBits: uint32_t;
                                 Elements   : UNTRACED REF MetadataRef;
                                 NumElements: uint;
                                 ClassTy    : MetadataRef;              ):
  MetadataRef;


(**
 * Create debugging information entry for a set.<br>
 * @param Builder        The DIBuilder.<br>
 * @param Scope          The scope this module is imported into.<br>
 * @param Name           A name that uniquely identifies this set.<br>
 * @param NameLen        The length of the C string passed to <code>Name</code>.<br>
 * @param File           File where the set is located.<br>
 * <br>
 * @param SizeInBits     Set size.<br>
 * @param AlignInBits    Set alignment.<br>
 * @param BaseTy         The base type of the set.
 *)

PROCEDURE CreateSetType (Builder    : BuilderRef;
                         Scope      : MetadataRef;
                         Name       : TEXT;
                         NameLen    : uint32_t;
                         File       : MetadataRef;
                         LineNumber : uint;
                         SizeInBits : uint64_t;
                         AlignInBits: uint32_t;
                         BaseTy     : MetadataRef; ): MetadataRef;


(**
 * Create a descriptor for a subrange with constant bounds.<br>
 * @param Builder    The DIBuilder.<br>
 * @param Scope      The scope this module is imported into.<br>
 * @param Name       A name that uniquely identifies this set.<br>
 * @param NameLen    The length of the C string passed to <code>Name</code>.<br>
 * @param File       File where the subrange is located.<br>
 * @param BaseTy     The base type of the subrange. eg integer or enumeration<br>
 * @param LowerBound Lower bound of the subrange.<br>
 * @param Count      Count of elements in the subrange.
 *)

PROCEDURE GetSubrangeConst (Builder          : BuilderRef;
                            Scope            : MetadataRef;
                            Name             : TEXT;
                            NameLen          : uint32_t;
                            File, BaseTy     : MetadataRef;
                            LowerBound, Count: int64_t;     ): MetadataRef;


(**
 * Create a descriptor for a subrange with dynamic bounds.<br>
 * @param Builder    The DIBuilder.<br>
 * @param Scope      The scope this module is imported into.<br>
 * @param Name       A name that uniquely identifies this set.<br>
 * @param NameLen    The length of the C string passed to <code>Name</code>.<br>
 * @param File       File where the subrange is located.<br>
 * @param BaseTy     The base type of the subrange. eg integer or enumeration<br>
 * @param LowerBound Lower bound of the subrange.<br>
 * @param Count      Count of elements in the subrange.
 *)

PROCEDURE GetSubrangeExpr (Builder                        : BuilderRef;
                           Scope                          : MetadataRef;
                           Name                           : TEXT;
                           NameLen                        : uint32_t;
                           File, BaseTy, LowerBound, Count: MetadataRef; ):
  MetadataRef;


(**
 * Create debugging information entry for a union.<br>
 * @param Builder      The DIBuilder.<br>
 * @param Scope        Scope in which this union is defined.<br>
 * @param Name         Union name.<br>
 * @param NameLen      Length of union name.<br>
 * @param File         File where this member is defined.<br>
 * @param LineNumber   Line number.<br>
 * @param SizeInBits   Member size.<br>
 * @param AlignInBits  Member alignment.<br>
 * @param Flags        Flags to encode member attribute, e.g. private<br>
 * @param Elements     Union elements.<br>
 * @param NumElements  Number of union elements.<br>
 * @param RunTimeLang  Optional parameter, Objective-C runtime version.<br>
 * @param UniqueId     A unique identifier for the union.<br>
 * @param UniqueIdLen  Length of unique identifier.
 *)

PROCEDURE CreateUnionType (Builder    : BuilderRef;
                           Scope      : MetadataRef;
                           Name       : TEXT;
                           NameLen    : uint32_t;
                           File       : MetadataRef;
                           LineNumber : uint;
                           SizeInBits : uint64_t;
                           AlignInBits: uint32_t;
                           Flags      : LLVMDIFlags;
                           Elements   : UNTRACED REF MetadataRef;
                           NumElements, RunTimeLang: uint;
                           UniqueId                : TEXT;
                           UniqueIdLen             : uint32_t; ):
  MetadataRef;


(**
 * Create debugging information entry for an array.<br>
 * @param Builder      The DIBuilder.<br>
 * @param Size         Array size.<br>
 * @param AlignInBits  Alignment.<br>
 * @param Ty           Element type.<br>
 * @param Subscripts   Subscripts.<br>
 * @param NumSubscripts Number of subscripts.
 *)

PROCEDURE CreateArrayType (Builder      : BuilderRef;
                           Size         : uint64_t;
                           AlignInBits  : uint32_t;
                           Ty           : MetadataRef;
                           Subscripts   : UNTRACED REF MetadataRef;
                           NumSubscripts: uint;                     ):
  MetadataRef;


(**
 * Create debugging information entry for a dynamic array.<br>
 * @param Builder      The DIBuilder.<br>
 * @param Size         Array size.<br>
 * @param AlignInBits  Alignment.<br>
 * @param Ty           Element type.<br>
 * @param Subscripts   Subscripts.<br>
 * @param NumSubscripts Number of subscripts.<br>
 * @param DataLocation DataLocation.<br>
 * @param Associated   Associated.<br>
 * @param Allocated    Allocated.<br>
 * @param Rank         Rank.
 *)

PROCEDURE CreateDynamicArrayType
  (Builder                                  : BuilderRef;
   Size                                     : uint64_t;
   AlignInBits                              : uint32_t;
   Ty                                       : MetadataRef;
   Subscripts                               : UNTRACED REF MetadataRef;
   NumSubscripts                            : uint;
   DataLocation, Associated, Allocated, Rank: MetadataRef;              ):
  MetadataRef;


(**
 * Create debugging information entry for a vector type.<br>
 * @param Builder      The DIBuilder.<br>
 * @param Size         Vector size.<br>
 * @param AlignInBits  Alignment.<br>
 * @param Ty           Element type.<br>
 * @param Subscripts   Subscripts.<br>
 * @param NumSubscripts Number of subscripts.
 *)

PROCEDURE CreateVectorType (Builder      : BuilderRef;
                            Size         : uint64_t;
                            AlignInBits  : uint32_t;
                            Ty           : MetadataRef;
                            Subscripts   : UNTRACED REF MetadataRef;
                            NumSubscripts: uint;                     ):
  MetadataRef;


(**
 * Create a DWARF unspecified type.<br>
 * @param Builder   The DIBuilder.<br>
 * @param Name      The unspecified type's name.<br>
 * @param NameLen   Length of type name.
 *)

PROCEDURE CreateUnspecifiedType
  (Builder: BuilderRef; Name: TEXT; NameLen: uint32_t; ): MetadataRef;


(**
 * Create debugging information entry for a basic<br>
 * type.<br>
 * @param Builder     The DIBuilder.<br>
 * @param Name        Type name.<br>
 * @param NameLen     Length of type name.<br>
 * @param SizeInBits  Size of the type.<br>
 * @param Encoding    DWARF encoding code, e.g. <code>LLVMDWARFTypeEncoding_float</code>.<br>
 * @param Flags       Flags to encode optional attribute like endianity
 *)

PROCEDURE CreateBasicType (Builder   : BuilderRef;
                           Name      : TEXT;
                           NameLen   : uint32_t;
                           SizeInBits: uint64_t;
                           Encoding  : uint;
                           Flags     : LLVMDIFlags; ): MetadataRef;


(**
 * Create debugging information entry for a pointer.<br>
 * @param Builder     The DIBuilder.<br>
 * @param PointeeTy         Type pointed by this pointer.<br>
 * @param SizeInBits        Size.<br>
 * @param AlignInBits       Alignment. (optional, pass 0 to ignore)<br>
 * @param AddressSpace      DWARF address space. (optional, pass 0 to ignore)<br>
 * @param Name              Pointer type name. (optional)<br>
 * @param NameLen           Length of pointer type name. (optional)
 *)

PROCEDURE CreatePointerType (Builder     : BuilderRef;
                             PointeeTy   : MetadataRef;
                             SizeInBits  : uint64_t;
                             AlignInBits : uint32_t;
                             AddressSpace: uint;
                             Name        : TEXT;
                             NameLen     : uint32_t;    ): MetadataRef;


(**
 * Create debugging information entry for a struct.<br>
 * @param Builder     The DIBuilder.<br>
 * @param Scope        Scope in which this struct is defined.<br>
 * @param Name         Struct name.<br>
 * @param NameLen      Struct name length.<br>
 * @param File         File where this member is defined.<br>
 * @param LineNumber   Line number.<br>
 * @param SizeInBits   Member size.<br>
 * @param AlignInBits  Member alignment.<br>
 * @param Flags        Flags to encode member attribute, e.g. private<br>
 * @param Elements     Struct elements.<br>
 * @param NumElements  Number of struct elements.<br>
 * @param RunTimeLang  Optional parameter, Objective-C runtime version.<br>
 * @param VTableHolder The object containing the vtable for the struct.<br>
 * @param UniqueId     A unique identifier for the struct.<br>
 * @param UniqueIdLen  Length of the unique identifier for the struct.
 *)

PROCEDURE CreateStructType (Builder    : BuilderRef;
                            Scope      : MetadataRef;
                            Name       : TEXT;
                            NameLen    : uint32_t;
                            File       : MetadataRef;
                            LineNumber : uint;
                            SizeInBits : uint64_t;
                            AlignInBits: uint32_t;
                            Flags      : LLVMDIFlags;
                            DerivedFrom: MetadataRef;
                            Elements   : UNTRACED REF MetadataRef;
                            NumElements, RunTimeLang: uint;
                            VTableHolder            : MetadataRef;
                            UniqueId                : TEXT;
                            UniqueIdLen             : uint32_t;    ):
  MetadataRef;


(**
 * Create debugging information entry for a member.<br>
 * @param Builder      The DIBuilder.<br>
 * @param Scope        Member scope.<br>
 * @param Name         Member name.<br>
 * @param NameLen      Length of member name.<br>
 * @param File         File where this member is defined.<br>
 * @param LineNo       Line number.<br>
 * @param SizeInBits   Member size.<br>
 * @param AlignInBits  Member alignment.<br>
 * @param OffsetInBits Member offset.<br>
 * @param Flags        Flags to encode member attribute, e.g. private<br>
 * @param Ty           Parent type.
 *)

PROCEDURE CreateMemberType (Builder     : BuilderRef;
                            Scope       : MetadataRef;
                            Name        : TEXT;
                            NameLen     : uint32_t;
                            File        : MetadataRef;
                            LineNo      : uint;
                            SizeInBits  : uint64_t;
                            AlignInBits : uint32_t;
                            OffsetInBits: uint64_t;
                            Flags       : LLVMDIFlags;
                            Ty          : MetadataRef; ): MetadataRef;


(**
 * Create debugging information entry for a<br>
 * C++ static data member.<br>
 * @param Builder      The DIBuilder.<br>
 * @param Scope        Member scope.<br>
 * @param Name         Member name.<br>
 * @param NameLen      Length of member name.<br>
 * @param File         File where this member is declared.<br>
 * @param LineNumber   Line number.<br>
 * @param Type         Type of the static member.<br>
 * @param Flags        Flags to encode member attribute, e.g. private.<br>
 * @param ConstantVal  Const initializer of the member.<br>
 * @param AlignInBits  Member alignment.
 *)

PROCEDURE CreateStaticMemberType (Builder    : BuilderRef;
                                  Scope      : MetadataRef;
                                  Name       : TEXT;
                                  NameLen    : uint32_t;
                                  File       : MetadataRef;
                                  LineNumber : uint;
                                  Type       : MetadataRef;
                                  Flags      : LLVMDIFlags;
                                  ConstantVal: ValueRef;
                                  AlignInBits: uint32_t;    ): MetadataRef;


(**
 * Create debugging information entry for a pointer to member.<br>
 * @param Builder      The DIBuilder.<br>
 * @param PointeeType  Type pointed to by this pointer.<br>
 * @param ClassType    Type for which this pointer points to members of.<br>
 * @param SizeInBits   Size.<br>
 * @param AlignInBits  Alignment.<br>
 * @param Flags        Flags.
 *)

PROCEDURE CreateMemberPointerType (Builder               : BuilderRef;
                                   PointeeType, ClassType: MetadataRef;
                                   SizeInBits            : uint64_t;
                                   AlignInBits           : uint32_t;
                                   Flags                 : LLVMDIFlags; ):
  MetadataRef;


(**
 * Create debugging information entry for Objective-C instance variable.<br>
 * @param Builder      The DIBuilder.<br>
 * @param Name         Member name.<br>
 * @param NameLen      The length of the C string passed to <code>Name</code>.<br>
 * @param File         File where this member is defined.<br>
 * @param LineNo       Line number.<br>
 * @param SizeInBits   Member size.<br>
 * @param AlignInBits  Member alignment.<br>
 * @param OffsetInBits Member offset.<br>
 * @param Flags        Flags to encode member attribute, e.g. private<br>
 * @param Ty           Parent type.<br>
 * @param PropertyNode Property associated with this ivar.
 *)

PROCEDURE CreateObjCIVar (Builder         : BuilderRef;
                          Name            : TEXT;
                          NameLen         : uint32_t;
                          File            : MetadataRef;
                          LineNo          : uint;
                          SizeInBits      : uint64_t;
                          AlignInBits     : uint32_t;
                          OffsetInBits    : uint64_t;
                          Flags           : LLVMDIFlags;
                          Ty, PropertyNode: MetadataRef; ): MetadataRef;


(**
 * Create debugging information entry for Objective-C property.<br>
 * @param Builder            The DIBuilder.<br>
 * @param Name               Property name.<br>
 * @param NameLen            The length of the C string passed to <code>Name</code>.<br>
 * @param File               File where this property is defined.<br>
 * @param LineNo             Line number.<br>
 * @param GetterName         Name of the Objective C property getter selector.<br>
 * @param GetterNameLen      The length of the C string passed to <code>GetterName</code>.<br>
 * @param SetterName         Name of the Objective C property setter selector.<br>
 * @param SetterNameLen      The length of the C string passed to <code>SetterName</code>.<br>
 * @param PropertyAttributes Objective C property attributes.<br>
 * @param Ty                 Type.
 *)

PROCEDURE CreateObjCProperty (Builder           : BuilderRef;
                              Name              : TEXT;
                              NameLen           : uint32_t;
                              File              : MetadataRef;
                              LineNo            : uint;
                              GetterName        : TEXT;
                              GetterNameLen     : uint32_t;
                              SetterName        : TEXT;
                              SetterNameLen     : uint32_t;
                              PropertyAttributes: uint;
                              Ty                : MetadataRef; ):
  MetadataRef;


(**
 * Create a uniqued DIType* clone with FlagObjectPointer and FlagArtificial set.<br>
 * @param Builder   The DIBuilder.<br>
 * @param Type      The underlying type to which this pointer points.
 *)

PROCEDURE CreateObjectPointerType
  (Builder: BuilderRef; Type: MetadataRef; ): MetadataRef;


(**
 * Create debugging information entry for a qualified<br>
 * type, e.g. 'const int'.<br>
 * @param Builder     The DIBuilder.<br>
 * @param Tag         Tag identifying type,<br>
 *                    e.g. LLVMDWARFTypeQualifier_volatile_type<br>
 * @param Type        Base Type.
 *)

PROCEDURE CreateQualifiedType
  (Builder: BuilderRef; Tag: uint; Type: MetadataRef; ): MetadataRef;


(**
 * Create debugging information entry for a c++<br>
 * style reference or rvalue reference type.<br>
 * @param Builder   The DIBuilder.<br>
 * @param Tag       Tag identifying type,<br>
 * @param Type      Base Type.
 *)

PROCEDURE CreateReferenceType
  (Builder: BuilderRef; Tag: uint; Type: MetadataRef; ): MetadataRef;


(**
 * Create C++11 nullptr type.<br>
 * @param Builder   The DIBuilder.
 *)

PROCEDURE CreateNullPtrType (Builder: BuilderRef; ): MetadataRef;


(**
 * Create debugging information entry for a typedef.<br>
 * @param Builder    The DIBuilder.<br>
 * @param Type       Original type.<br>
 * @param Name       Typedef name.<br>
 * @param File       File where this type is defined.<br>
 * @param LineNo     Line number.<br>
 * @param Scope      The surrounding context for the typedef.
 *)

PROCEDURE CreateTypedef (Builder    : BuilderRef;
                         Type       : MetadataRef;
                         Name       : TEXT;
                         NameLen    : uint32_t;
                         File       : MetadataRef;
                         LineNo     : uint;
                         Scope      : MetadataRef;
                         AlignInBits: uint32_t;    ): MetadataRef;


(**
 * Create debugging information entry to establish inheritance relationship<br>
 * between two types.<br>
 * @param Builder       The DIBuilder.<br>
 * @param Ty            Original type.<br>
 * @param BaseTy        Base type. Ty is inherits from base.<br>
 * @param BaseOffset    Base offset.<br>
 * @param VBPtrOffset  Virtual base pointer offset.<br>
 * @param Flags         Flags to describe inheritance attribute, e.g. private
 *)

PROCEDURE CreateInheritance (Builder    : BuilderRef;
                             Ty, BaseTy : MetadataRef;
                             BaseOffset : uint64_t;
                             VBPtrOffset: uint32_t;
                             Flags      : LLVMDIFlags; ): MetadataRef;


(**
 * Create a permanent forward-declared type.<br>
 * @param Builder             The DIBuilder.<br>
 * @param Tag                 A unique tag for this type.<br>
 * @param Name                Type name.<br>
 * @param NameLen             Length of type name.<br>
 * @param Scope               Type scope.<br>
 * @param File                File where this type is defined.<br>
 * @param Line                Line number where this type is defined.<br>
 * @param RuntimeLang         Indicates runtime version for languages like<br>
 *                            Objective-C.<br>
 * @param SizeInBits          Member size.<br>
 * @param AlignInBits         Member alignment.<br>
 * @param UniqueIdentifier    A unique identifier for the type.<br>
 * @param UniqueIdentifierLen Length of the unique identifier.
 *)

PROCEDURE CreateForwardDecl (Builder            : BuilderRef;
                             Tag                : uint;
                             Name               : TEXT;
                             NameLen            : uint32_t;
                             Scope, File        : MetadataRef;
                             Line, RuntimeLang  : uint;
                             SizeInBits         : uint64_t;
                             AlignInBits        : uint32_t;
                             UniqueIdentifier   : TEXT;
                             UniqueIdentifierLen: uint32_t;    ):
  MetadataRef;


(**
 * Create a temporary forward-declared type.<br>
 * @param Builder             The DIBuilder.<br>
 * @param Tag                 A unique tag for this type.<br>
 * @param Name                Type name.<br>
 * @param NameLen             Length of type name.<br>
 * @param Scope               Type scope.<br>
 * @param File                File where this type is defined.<br>
 * @param Line                Line number where this type is defined.<br>
 * @param RuntimeLang         Indicates runtime version for languages like<br>
 *                            Objective-C.<br>
 * @param SizeInBits          Member size.<br>
 * @param AlignInBits         Member alignment.<br>
 * @param Flags               Flags.<br>
 * @param UniqueIdentifier    A unique identifier for the type.<br>
 * @param UniqueIdentifierLen Length of the unique identifier.
 *)

PROCEDURE CreateReplaceableCompositeType (Builder          : BuilderRef;
                                          Tag              : uint;
                                          Name             : TEXT;
                                          NameLen          : uint32_t;
                                          Scope, File      : MetadataRef;
                                          Line, RuntimeLang: uint;
                                          SizeInBits       : uint64_t;
                                          AlignInBits      : uint32_t;
                                          Flags            : LLVMDIFlags;
                                          UniqueIdentifier : TEXT;
                                          UniqueIdentifierLen: uint32_t; ):
  MetadataRef;


(**
 * Create debugging information entry for a bit field member.<br>
 * @param Builder             The DIBuilder.<br>
 * @param Scope               Member scope.<br>
 * @param Name                Member name.<br>
 * @param NameLen             Length of member name.<br>
 * @param File                File where this member is defined.<br>
 * @param LineNumber          Line number.<br>
 * @param SizeInBits          Member size.<br>
 * @param OffsetInBits        Member offset.<br>
 * @param StorageOffsetInBits Member storage offset.<br>
 * @param Flags               Flags to encode member attribute.<br>
 * @param Type                Parent type.
 *)

PROCEDURE CreateBitFieldMemberType
  (Builder                                      : BuilderRef;
   Scope                                        : MetadataRef;
   Name                                         : TEXT;
   NameLen                                      : uint32_t;
   File                                         : MetadataRef;
   LineNumber                                   : uint;
   SizeInBits, OffsetInBits, StorageOffsetInBits: uint64_t;
   Flags                                        : LLVMDIFlags;
   Type                                         : MetadataRef; ):
  MetadataRef;


(**
 * Create debugging information entry for a class.<br>
 * @param Scope               Scope in which this class is defined.<br>
 * @param Name                Class name.<br>
 * @param NameLen             The length of the C string passed to <code>Name</code>.<br>
 * @param File                File where this member is defined.<br>
 * @param LineNumber          Line number.<br>
 * @param SizeInBits          Member size.<br>
 * @param AlignInBits         Member alignment.<br>
 * @param OffsetInBits        Member offset.<br>
 * @param Flags               Flags to encode member attribute, e.g. private.<br>
 * @param DerivedFrom         Debug info of the base class of this type.<br>
 * @param Elements            Class members.<br>
 * @param NumElements         Number of class elements.<br>
 * @param VTableHolder        Debug info of the base class that contains vtable<br>
 *                            for this type. This is used in<br>
 *                            DW_AT_containing_type. See DWARF documentation<br>
 *                            for more info.<br>
 * @param TemplateParamsNode  Template type parameters.<br>
 * @param UniqueIdentifier    A unique identifier for the type.<br>
 * @param UniqueIdentifierLen Length of the unique identifier.
 *)

PROCEDURE CreateClassType
  (Builder                         : BuilderRef;
   Scope                           : MetadataRef;
   Name                            : TEXT;
   NameLen                         : uint32_t;
   File                            : MetadataRef;
   LineNumber                      : uint;
   SizeInBits                      : uint64_t;
   AlignInBits                     : uint32_t;
   OffsetInBits                    : uint64_t;
   Flags                           : LLVMDIFlags;
   DerivedFrom                     : MetadataRef;
   Elements                        : UNTRACED REF MetadataRef;
   NumElements                     : uint;
   VTableHolder, TemplateParamsNode: MetadataRef;
   UniqueIdentifier                : TEXT;
   UniqueIdentifierLen             : uint32_t;                 ):
  MetadataRef;


(**
 * Create a uniqued DIType* clone with FlagArtificial set.<br>
 * @param Builder     The DIBuilder.<br>
 * @param Type        The underlying type.
 *)

PROCEDURE CreateArtificialType (Builder: BuilderRef; Type: MetadataRef; ):
  MetadataRef;


(**
 * Get the name of this DIType.<br>
 * @param DType     The DIType.<br>
 * @param Length    The length of the returned string.<br>
 * <br>
 * @see DIType#getName()
 *)

PROCEDURE LLVMDITypeGetName (DType: MetadataRef; VAR Length: uint32_t; ):
  TEXT;


(**
 * Get the size of this DIType in bits.<br>
 * @param DType     The DIType.<br>
 * <br>
 * @see DIType#getSizeInBits()
 *)

PROCEDURE LLVMDITypeGetSizeInBits (DType: MetadataRef; ): uint64_t;


(**
 * Get the offset of this DIType in bits.<br>
 * @param DType     The DIType.<br>
 * <br>
 * @see DIType#getOffsetInBits()
 *)

PROCEDURE LLVMDITypeGetOffsetInBits (DType: MetadataRef; ): uint64_t;


(**
 * Get the alignment of this DIType in bits.<br>
 * @param DType     The DIType.<br>
 * <br>
 * @see DIType#getAlignInBits()
 *)

PROCEDURE LLVMDITypeGetAlignInBits (DType: MetadataRef; ): uint32_t;


(**
 * Get the source line where this DIType is declared.<br>
 * @param DType     The DIType.<br>
 * <br>
 * @see DIType#getLine()
 *)

PROCEDURE LLVMDITypeGetLine (DType: MetadataRef; ): CARDINAL;


(**
 * Get the flags associated with this DIType.<br>
 * @param DType     The DIType.<br>
 * <br>
 * @see DIType#getFlags()
 *)

PROCEDURE LLVMDITypeGetFlags (DType: MetadataRef; ): LLVMDIFlags;


(**
 * Create a descriptor for a value range.<br>
 * @param Builder    The DIBuilder.<br>
 * @param LowerBound Lower bound of the subrange, e.g. 0 for C, 1 for Fortran.<br>
 * @param Count      Count of elements in the subrange.
 *)

PROCEDURE GetOrCreateSubrange
  (Builder: BuilderRef; LowerBound, Count: int64_t; ): MetadataRef;


(**
 * Create an array of DI Nodes.<br>
 * @param Builder        The DIBuilder.<br>
 * @param Data           The DI Node elements.<br>
 * @param NumElements    Number of DI Node elements.
 *)

PROCEDURE GetOrCreateArray (Builder    : BuilderRef;
                            Data       : UNTRACED REF MetadataRef;
                            NumElements: uint32_t;                 ):
  MetadataRef;


(**
 * Create a new descriptor for the specified variable which has a complex<br>
 * address expression for its address.<br>
 * @param Builder     The DIBuilder.<br>
 * @param Addr        An array of complex address operations.<br>
 * @param Length      Length of the address operation array.
 *)

PROCEDURE CreateExpression
  (Builder: BuilderRef; Addr: UNTRACED REF int64_t; Length: uint32_t; ):
  MetadataRef;


(**
 * Create a new descriptor for the specified variable that does not have an<br>
 * address, but does have a constant value.<br>
 * @param Builder     The DIBuilder.<br>
 * @param Value       The constant value.
 *)

PROCEDURE CreateConstantValueExpression
  (Builder: BuilderRef; Value: int64_t; ): MetadataRef;


(**
 * Create a new descriptor for the specified variable.<br>
 * @param Scope       Variable scope.<br>
 * @param Name        Name of the variable.<br>
 * @param NameLen     The length of the C string passed to <code>Name</code>.<br>
 * @param Linkage     Mangled  name of the variable.<br>
 * @param LinkLen     The length of the C string passed to <code>Linkage</code>.<br>
 * @param File        File where this variable is defined.<br>
 * @param LineNo      Line number.<br>
 * @param Ty          Variable Type.<br>
 * @param LocalToUnit Boolean flag indicate whether this variable is<br>
 *                    externally visible or not.<br>
 * @param Expr        The location of the global relative to the attached<br>
 *                    GlobalVariable.<br>
 * @param Decl        Reference to the corresponding declaration.<br>
 *                    variables.<br>
 * @param AlignInBits Variable alignment(or 0 if no alignment attr was<br>
 *                    specified)
 *)

PROCEDURE CreateGlobalVariableExpression (Builder    : BuilderRef;
                                          Scope      : MetadataRef;
                                          Name       : TEXT;
                                          NameLen    : uint32_t;
                                          Linkage    : TEXT;
                                          LinkLen    : uint32_t;
                                          File       : MetadataRef;
                                          LineNo     : uint;
                                          Ty         : MetadataRef;
                                          LocalToUnit: BOOLEAN;
                                          Expr, Decl : MetadataRef;
                                          AlignInBits: uint32_t;    ):
  MetadataRef;


(**
 * Retrieves the <code>DIVariable</code> associated with this global variable expression.<br>
 * @param GVE    The global variable expression.<br>
 * <br>
 * @see llvm#DIGlobalVariableExpression::getVariable()
 *)

PROCEDURE LLVMDIGlobalVariableExpressionGetVariable (GVE: MetadataRef; ):
  MetadataRef;


(**
 * Retrieves the <code>DIExpression</code> associated with this global variable expression.<br>
 * @param GVE    The global variable expression.<br>
 * <br>
 * @see llvm#DIGlobalVariableExpression::getExpression()
 *)

PROCEDURE LLVMDIGlobalVariableExpressionGetExpression (GVE: MetadataRef; ):
  MetadataRef;


(**
 * Get the metadata of the file associated with a given variable.<br>
 * @param Var     The variable object.<br>
 * <br>
 * @see DIVariable#getFile()
 *)

PROCEDURE LLVMDIVariableGetFile (Var: MetadataRef; ): MetadataRef;


(**
 * Get the metadata of the scope associated with a given variable.<br>
 * @param Var     The variable object.<br>
 * <br>
 * @see DIVariable#getScope()
 *)

PROCEDURE LLVMDIVariableGetScope (Var: MetadataRef; ): MetadataRef;


(**
 * Get the source line where this <code>DIVariable</code> is declared.<br>
 * @param Var     The DIVariable.<br>
 * <br>
 * @see DIVariable#getLine()
 *)

PROCEDURE LLVMDIVariableGetLine (Var: MetadataRef; ): CARDINAL;


(**
 * Create a new temporary <code>MDNode</code>.  Suitable for use in constructing cyclic<br>
 * <code>MDNode</code> structures. A temporary <code>MDNode</code> is not uniqued, may be RAUW'd,<br>
 * and must be manually deleted with <code>LLVMDisposeTemporaryMDNode</code>.<br>
 * @param Ctx            The context in which to construct the temporary node.<br>
 * @param Data           The metadata elements.<br>
 * @param NumElements    Number of metadata elements.
 *)

PROCEDURE LLVMTemporaryMDNode (Ctx        : ContextRef;
                               Data       : UNTRACED REF MetadataRef;
                               NumElements: uint32_t;                 ):
  MetadataRef;


(**
 * Deallocate a temporary node.<br>
 * <br>
 * Calls <code>replaceAllUsesWith(nullptr)</code> before deleting, so any remaining<br>
 * references will be reset.<br>
 * @param TempNode    The temporary metadata node.
 *)

PROCEDURE LLVMDisposeTemporaryMDNode (TempNode: MetadataRef; );


(**
 * Replace all uses of temporary metadata.<br>
 * @param TempTargetMetadata    The temporary metadata node.<br>
 * @param Replacement           The replacement metadata node.
 *)

PROCEDURE LLVMMetadataReplaceAllUsesWith
  (TempTargetMetadata, Replacement: MetadataRef; );


(**
 * Create a new descriptor for the specified global variable that is temporary<br>
 * and meant to be RAUWed.<br>
 * @param Scope       Variable scope.<br>
 * @param Name        Name of the variable.<br>
 * @param NameLen     The length of the C string passed to <code>Name</code>.<br>
 * @param Linkage     Mangled  name of the variable.<br>
 * @param LnkLen      The length of the C string passed to <code>Linkage</code>.<br>
 * @param File        File where this variable is defined.<br>
 * @param LineNo      Line number.<br>
 * @param Ty          Variable Type.<br>
 * @param LocalToUnit Boolean flag indicate whether this variable is<br>
 *                    externally visible or not.<br>
 * @param Decl        Reference to the corresponding declaration.<br>
 * @param AlignInBits Variable alignment(or 0 if no alignment attr was<br>
 *                    specified)
 *)

PROCEDURE CreateTempGlobalVariableFwdDecl (Builder    : BuilderRef;
                                           Scope      : MetadataRef;
                                           Name       : TEXT;
                                           NameLen    : uint32_t;
                                           Linkage    : TEXT;
                                           LnkLen     : uint32_t;
                                           File       : MetadataRef;
                                           LineNo     : uint;
                                           Ty         : MetadataRef;
                                           LocalToUnit: BOOLEAN;
                                           Decl       : MetadataRef;
                                           AlignInBits: uint32_t;    ):
  MetadataRef;


(**
 * Insert a new llvm.dbg.declare intrinsic call before the given instruction.<br>
 * @param Builder     The DIBuilder.<br>
 * @param Storage     The storage of the variable to declare.<br>
 * @param VarInfo     The variable's debug info descriptor.<br>
 * @param Expr        A complex location expression for the variable.<br>
 * @param DebugLoc    Debug info location.<br>
 * @param Instr       Instruction acting as a location for the new intrinsic.
 *)

PROCEDURE InsertDeclareBefore (Builder                : BuilderRef;
                               Storage                : ValueRef;
                               VarInfo, Expr, DebugLoc: MetadataRef;
                               Instr                  : ValueRef;    ):
  ValueRef;


(**
 * Insert a new llvm.dbg.declare intrinsic call at the end of the given basic<br>
 * block. If the basic block has a terminator instruction, the intrinsic is<br>
 * inserted before that terminator instruction.<br>
 * @param Builder     The DIBuilder.<br>
 * @param Storage     The storage of the variable to declare.<br>
 * @param VarInfo     The variable's debug info descriptor.<br>
 * @param Expr        A complex location expression for the variable.<br>
 * @param DebugLoc    Debug info location.<br>
 * @param Block       Basic block acting as a location for the new intrinsic.
 *)

PROCEDURE InsertDeclareAtEnd (Builder                : BuilderRef;
                              Storage                : ValueRef;
                              VarInfo, Expr, DebugLoc: MetadataRef;
                              Block                  : BasicBlockRef; ):
  ValueRef;


(**
 * Insert a new llvm.dbg.value intrinsic call before the given instruction.<br>
 * @param Builder     The DIBuilder.<br>
 * @param Val         The value of the variable.<br>
 * @param VarInfo     The variable's debug info descriptor.<br>
 * @param Expr        A complex location expression for the variable.<br>
 * @param DebugLoc    Debug info location.<br>
 * @param Instr       Instruction acting as a location for the new intrinsic.
 *)

PROCEDURE InsertDbgValueBefore (Builder                : BuilderRef;
                                Val                    : ValueRef;
                                VarInfo, Expr, DebugLoc: MetadataRef;
                                Instr                  : ValueRef;    ):
  ValueRef;


(**
 * Insert a new llvm.dbg.value intrinsic call at the end of the given basic<br>
 * block. If the basic block has a terminator instruction, the intrinsic is<br>
 * inserted before that terminator instruction.<br>
 * @param Builder     The DIBuilder.<br>
 * @param Val         The value of the variable.<br>
 * @param VarInfo     The variable's debug info descriptor.<br>
 * @param Expr        A complex location expression for the variable.<br>
 * @param DebugLoc    Debug info location.<br>
 * @param Block       Basic block acting as a location for the new intrinsic.
 *)

PROCEDURE InsertDbgValueAtEnd (Builder                : BuilderRef;
                               Val                    : ValueRef;
                               VarInfo, Expr, DebugLoc: MetadataRef;
                               Block                  : BasicBlockRef; ):
  ValueRef;


(**
 * Create a new descriptor for a local auto variable.<br>
 * @param Builder         The DIBuilder.<br>
 * @param Scope           The local scope the variable is declared in.<br>
 * @param Name            Variable name.<br>
 * @param NameLen         Length of variable name.<br>
 * @param File            File where this variable is defined.<br>
 * @param LineNo          Line number.<br>
 * @param Ty              Metadata describing the type of the variable.<br>
 * @param AlwaysPreserve  If true, this descriptor will survive optimizations.<br>
 * @param Flags           Flags.<br>
 * @param AlignInBits     Variable alignment.
 *)

PROCEDURE CreateAutoVariable (Builder       : BuilderRef;
                              Scope         : MetadataRef;
                              Name          : TEXT;
                              NameLen       : uint32_t;
                              File          : MetadataRef;
                              LineNo        : uint;
                              Ty            : MetadataRef;
                              AlwaysPreserve: BOOLEAN;
                              Flags         : LLVMDIFlags;
                              AlignInBits   : uint32_t;    ): MetadataRef;


(**
 * Create a new descriptor for a function parameter variable.<br>
 * @param Builder         The DIBuilder.<br>
 * @param Scope           The local scope the variable is declared in.<br>
 * @param Name            Variable name.<br>
 * @param NameLen         Length of variable name.<br>
 * @param ArgNo           Unique argument number for this variable; starts at 1.<br>
 * @param File            File where this variable is defined.<br>
 * @param LineNo          Line number.<br>
 * @param Ty              Metadata describing the type of the variable.<br>
 * @param AlwaysPreserve  If true, this descriptor will survive optimizations.<br>
 * @param Flags           Flags.
 *)

PROCEDURE CreateParameterVariable (Builder       : BuilderRef;
                                   Scope         : MetadataRef;
                                   Name          : TEXT;
                                   NameLen       : uint32_t;
                                   ArgNo         : uint;
                                   File          : MetadataRef;
                                   LineNo        : uint;
                                   Ty            : MetadataRef;
                                   AlwaysPreserve: BOOLEAN;
                                   Flags         : LLVMDIFlags; ):
  MetadataRef;


(**
 * Get the metadata of the subprogram attached to a function.<br>
 * <br>
 * @see llvm#Function::getSubprogram()
 *)

PROCEDURE LLVMGetSubprogram (Func: ValueRef; ): MetadataRef;


(**
 * Set the subprogram attached to a function.<br>
 * <br>
 * @see llvm#Function::setSubprogram()
 *)

PROCEDURE LLVMSetSubprogram (Func: ValueRef; SP: MetadataRef; );


(**
 * Get the line associated with a given subprogram.<br>
 * @param Subprogram     The subprogram object.<br>
 * <br>
 * @see DISubprogram#getLine()
 *)

PROCEDURE LLVMDISubprogramGetLine (Subprogram: MetadataRef; ): CARDINAL;


(**
 * Get the debug location for the given instruction.<br>
 * <br>
 * @see llvm#Instruction::getDebugLoc()
 *)

PROCEDURE LLVMInstructionGetDebugLoc (Inst: ValueRef; ): MetadataRef;


(**
 * Set the debug location for the given instruction.<br>
 * <br>
 * To clear the location metadata of the given instruction, pass NULL to <code>Loc</code>.<br>
 * <br>
 * @see llvm#Instruction::setDebugLoc()
 *)

PROCEDURE LLVMInstructionSetDebugLoc (Inst: ValueRef; Loc: MetadataRef; );


(**
 * Obtain the enumerated type of a Metadata instance.<br>
 * <br>
 * @see llvm#Metadata::getMetadataID()
 *)

PROCEDURE LLVMGetMetadataKind (Metadata: MetadataRef; ): CARDINAL;

PROCEDURE LLVMReplaceArrays (Builder    : BuilderRef;
                             T, Elements: UNTRACED REF MetadataRef;
                             NumElements: uint;                     );


END M3DebugInfo.
