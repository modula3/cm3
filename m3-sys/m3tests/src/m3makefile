% Copyright (C) 1994, Digital Equipment Corporation.
% All rights reserved.
% See the file COPYRIGHT for a full description.
%
% Last modified on Thu Jul  6 09:23:10 PDT 1995 by kalsow
%      modified on Tue Mar 12 22:05:06 1991 by muller

%------------------------------------------------------------------------------

M3TESTS = "yes"
include ("Test.common")

%------------------------------------------------------------------------------

if not defined("TARGET_ENDIAN")
  error("TARGET_ENDIAN must be defined")
else
  if not equal(TARGET_ENDIAN, "LITTLE") and not equal(TARGET_ENDIAN, "BIG")
    error("TARGET_ENDIAN must be BIG or LITTLE but it is " & TARGET_ENDIAN)
  end
end

diff = "@-diff -u -b"
diff_slash = "/"
head = "| head -30"

Solaris = FALSE
BcOk = TRUE

if equal ($OS, "Windows_NT")
  if not equal (try_exec("@diff nul nul 2>nul"), 0)
    diff = "@-fc"
    diff_slash = "\\"
  end
  if not equal (try_exec("@head nul 2>nul"), 0)
    head = ""
  end
  BcOk = FALSE
else
  Solaris = equal(q_exec_get("uname")[1], "SunOS\n")
  BcOk = not Solaris
end

proc FileRemoveRecursive(a) is
% fs_rmrec might not work
  if equal ($OS, "Windows_NT")
    exec("@-rmdir /q/s ", subst_chars(a, "/", "\\"))
  else
    exec("@rm -rf ", a)
  end
end

proc GetFileSize(a) is
  return len(fs_contents(a))
end

proc GetFileLineCount(a) is
  return len(split(fs_contents(a), "\n"))
end

proc GetFileLineCount2(a, b) is
% add up the line counts of two files
  return len(split(fs_contents(a) & fs_contents(b), "\n"))
end

proc PickExe(a) is
  if equal(OS_TYPE, "POSIX")
    return a
  end
  a = "\\cygwin\\bin\\" & a & ".exe"
  if FileExists(a)
    return a
  end
  return FALSE
end

DATE = PickExe("date")
BC = PickExe("bc")

%------------------------------------------------------------------------------
% build the test library
%
import ("libm3")
Module ("Test")
c_source("TestC")
build_standalone ()
library ("test")

% include floating point pieces from m3core
%if defined ("ROOT")
%  include ("../../../m3-libs/m3core/src/float/m3makefile")
%else
%  include (PKG_INSTALL & "/m3core/src/float/m3makefile")
%end

proc ProbeForTargetSpecificFile(Dir, Leaf, Default) is
%
% For file "foo", this looks for, e.g.:
% foo-big_endian32, foo32, foo-big_endian
% and then gives up and returns foo.
% "32" and "big" are tailored to the platform: can be 64 or "little"
%
  local wordSize = {"32BITS" : "32", "64BITS" : "64"}{WORD_SIZE}
  local endian =   {"BIG":"-big","LITTLE":"-little"}{TARGET_ENDIAN} & "_endian"
  foreach a in [wordSize, endian, endian & wordSize, "-" & TARGET]
    local b = Dir & "/" & Leaf & a
    if FileExists (b)
      return b
    end
  end
  foreach a in ["/expected/" & TARGET & "/"]
    local b = Dir & a & Leaf
    if FileExists (b)
      return b
    end
  end
  return Default
end

if not defined ("LIB_ONLY")
%------------------------------------------------------------------------------
% misc. utilities
%

proc compare_file (dir, Leaf, probeForTargetSpecificFile) is
  local ExpectedPath = dir & "/" & Leaf
  local OutputPath = dir & "/" & BUILD_DIR & "/" & Leaf

  if not FileExists (OutputPath)
    html ([OutputPath, "missing"])
    jux ([OutputPath, "missing", CR])
    return
  end

  if not FileExists (ExpectedPath)

    % missing file compares equal to zero length file, ok

    if equal(GetFileSize(OutputPath), 0)
      return
    end

    if probeForTargetSpecificFile
      ExpectedPath = ProbeForTargetSpecificFile(dir, Leaf, ExpectedPath)
    end
    if not FileExists (ExpectedPath)
      write (ExpectedPath, " is missing (3)", CR)
      html ([ExpectedPath, "missing"])
      jux ([ExpectedPath, "missing", CR])
      return
    end
  end

  ExpectedPath = subst_chars (ExpectedPath, "/", diff_slash)
  OutputPath = subst_chars (OutputPath, "/", diff_slash)

  if probeForTargetSpecificFile
    ExpectedPath = ProbeForTargetSpecificFile(dir, Leaf, ExpectedPath)
  end

  exec (diff, ExpectedPath, OutputPath, head)
  if defined("HTML")
    exec (diff, ExpectedPath, OutputPath, ">>", report)
    if equal(OS_TYPE, "POSIX")
      d = quote_xml(q_exec_get (["diff", "-u", ExpectedPath, OutputPath])[1])
      jux (d)
    end
  end
end

if defined ("LOG_CMPS")
  ComparisonLogFilePath = PACKAGE_DIR & "/m3tests-" & datestamp() & ".diffs"
  fs_rmfile(ComparisonLogFilePath)
end

proc FileExists(x) is
    return not stale(x, x)
end

proc cmp_file (dir, file, ignoreLinesWith, ignoreTexts, probeForTargetSpecificFile) is
  local ExpectedPath = dir & "/" & file
  local OutputPath = dir & "/" & BUILD_DIR & "/" & file

  if probeForTargetSpecificFile
    ExpectedPath = ProbeForTargetSpecificFile(dir, file, ExpectedPath)
  end

  if not FileExists (OutputPath)
    return FALSE
  end

  if not FileExists (ExpectedPath)
    % missing file compares equal to zero length file, ok
    return equal(GetFileSize(OutputPath), 0)
  end

  local ComparisonLogData = [ ]
  if defined ("LOG_CMPS")
    %
    % not sure about this -- how is it used?
    %
    local str_probeForTargetSpecificFile = "FALSE"
    if probeForTargetSpecificFile
      str_probeForTargetSpecificFile = "\"" & probeForTargetSpecificFile & "\""
    end
    ComparisonLogData += "cmp_file(" & ExpectedPath & ", " & OutputPath & ", [ ], [ ], " & str_probeForTargetSpecificFile & ")\n"
    write(ComparisonLogData)
  end

  local OutputContents = fs_contents (OutputPath)
  local ExpectedContents = fs_contents (ExpectedPath)

  if not empty (ignoreLinesWith)
    local ocLines = split (OutputContents, "\n")
    OutputContents = ""
    foreach line in ocLines
      local found = FALSE
      foreach ign in ignoreLinesWith
        if tcontains (line, ign)
          found = TRUE
        end
      end
      if not found
        OutputContents = OutputContents & line & "\n"
      end
    end
    local ecLines = split (ExpectedContents, "\n")
    ExpectedContents = ""
    foreach line in ecLines
      local found = FALSE
      foreach ign in ignoreLinesWith
        if tcontains (line, ign)
          found = TRUE
        end
      end
      if not found
        ExpectedContents = ExpectedContents & line & "\n"
      end
    end
  end
  if not empty (ignoreTexts)
    res = OutputContents
    foreach ign in ignoreTexts
      res = subst (res, ign, "", 9999)
    end
    OutputContents = res
    res = ExpectedContents
    foreach ign in ignoreTexts
      res = subst (res, ign, "", 9999)
    end
    ExpectedContents = res
  end

  if defined ("LOG_CMPS")
    ComparisonLogData += OutputPath & ":\n" & OutputContents & "\n"
    ComparisonLogData += ExpectedPath & ":\n" & ExpectedContents & "\n"
  end

  %if equal(try_exec ("@cmp", OutputPath, ExpectedPath), 0)
  if equal(OutputContents, ExpectedContents)
    if defined ("LOG_CMPS")
      ComparisonLogData += "--> TRUE\n"
      >> ComparisonLogFilePath in
        write (ComparisonLogData)
      end
    end
    return TRUE
  end
  if defined ("LOG_CMPS")
    ComparisonLogData += "--> FALSE\n"
    >> ComparisonLogFilePath in
      write (ComparisonLogData)
    end
  end
  return FALSE
end


% Write test results in HTML to `report`.
report     = PACKAGE_DIR & "/m3tests.html"

% "JUX" is "JUnit XML", a more-or-less standard reporting format.
%
% We accumulate test results in `juxworking` before writing the summary
% report to `juxreport`.
juxworking = PACKAGE_DIR & "/m3tests-results.xml.working"
juxreport  = PACKAGE_DIR & "/m3tests-results.xml"

% Truncate report files.
if defined("HTML")
  > report in
    write( "" )
  end
  > juxworking in
    write( "" )
  end
end

% Append to the HTML test report.
proc html (args) is
  if defined("HTML")
    >> report in
      write( args )
    end
  end
end

% Append to the JUnit XML test report.
proc jux (args) is
  if defined("HTML")
    >> juxworking in
      write( args )
    end
  end
end

proc quote_xml (arg) is
  ret = subst (arg, "&", "&amp;", 0)
  ret = subst (ret, "<", "&lt;", 0)
  ret = subst (ret, ">", "&gt;", 0)
  return ret
end

% Initialize success/failure counts.  These are used to produce the final `juxreport`.
success = "res.ok"
failure = "res.ko"
> success in write("") end
> failure in write("") end

% Initialize HTML report.
html(["<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">", CR])
html(["<html>", CR])
html(["  <head>", CR])
html(["    <title>CM3 M3Tests Status for target platform ", TARGET, "</title>", CR])
html(["    <META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html\">", CR])
html(["    <META HTTP-EQUIV=\"Content-Style-Type\" CONTENT=\"text/css\">", CR])
html(["    <META HTTP-EQUIV=\"Resource-type\" CONTENT=\"document\"> ", CR])
html(["    <META HTTP-EQUIV=\"Reply-to\" CONTENT=\"m3-support@elego.de\"> ", CR])
html(["    <LINK HREF=\"../normal.css\" REL=\"stylesheet\" TYPE=\"text/css\">", CR])
html(["    <META NAME=\"robots\" content=\"noindex\">", CR])
html(["", CR])
html(["    <style type=\"text/css\">", CR])
html(["    <!--", CR])
html(["    .white    { color:#FFFFFF; }", CR])
html(["    .bgred    { background:#FF4444; }", CR])
html(["    .bggreen  { background:#44FF44; }", CR])
html(["    .bgblue   { background:#5555FF; }", CR])
html(["    .bgyellow { background:#FFFF00; }", CR])
html(["    .small    { font-size:8pt; }", CR])
html(["    .tl       { text-align: left; vertical-align: top; }", CR])
html(["    //-->", CR])
html(["    </style>", CR])
html(["  </head>", CR])
html(["", CR])
html(["  <body bgcolor=\"#ffffff\">", CR])
html(["    <h2>CM3 M3Tests Status for Target Platform ", TARGET, "</h2>", CR])
html(["", CR])
html(["    <p>", CR])
html(["      report generated at ", datetime(), "on ", hostname(), CR])
html(["    </p>", CR])
html(["    <table border=\"2\" cellspacing=\"1\" cellpadding=\"4\">", CR])
html(["      <thead>", CR])
html(["        <tr class=\"bgblue white\">", CR])
html(["          <td width=\"5%\">", CR])
html(["            <b>Package</b>", CR])
html(["          </td>", CR])
html(["          <td width=\"45%\">", CR])
html(["            <b>Status</b>", CR])
html(["", CR])
html(["          </td>", CR])
html(["          <td width=\"50%\">", CR])
html(["            <b>Diffs</b>", CR])
html(["          </td>", CR])
html(["        </tr>", CR])
html(["      </thead>", CR])
html(["      <tbody>", CR])


%------------------------------------------------------------------------------
% run a test case
%

cm3opts = ""
runopts = ""
if equal(M3_BACKEND_MODE, "StAloneLlvmAsm")
% llvm debug mode not tested
  cm3opts = cm3opts & "-g0 "
% llvm optimisations if required
%  cm3opts = cm3opts & "-O2 "
end

readonly proc run_test (class, group, uid, comment, should_run, cm3opts, runopts, probeForTargetSpecificFiles) is  local dir = "../src/" & group & "/" & uid
  FileRemoveRecursive(dir & "/" & BUILD_DIR)
  if DATE
    tstart = compress (q_exec_get (DATE & " '+%s'")[1]) % second resolution only
  end

  if defined ("_all") or defined (class) or defined ("_" & uid)
    write ("--- ", uid, " --- ", comment, CR)
    fs_mkdir (dir & "/" & BUILD_DIR)
    fs_putfile (dir & "/" & BUILD_DIR & "/runopts", runopts)

    local ExpectedDir = dir & "/expected/" & TARGET
    local keep = defined("keep") or FileExists(ExpectedDir)

    local silent = ""
    if defined("debug")
      silent = silent & " -debug "
    end
    if defined("commands")
      silent = silent & " -commands "
    end
    if equal(silent, "")
        silent = "-silent"
    end
    if keep
        silent = silent & " -keep"
    end

    exec ("-cd", dir, "&& cm3", silent, "-DM3TESTS", cm3opts, ">" & BUILD_DIR & "/stdout.build.raw 2>" & BUILD_DIR & "/stderr.build.raw")

    NormalizeFile (dir & "/" & BUILD_DIR & "/stdout.build")
    NormalizeFile (dir & "/" & BUILD_DIR & "/stderr.build")

    if defined ("CAPTURE_BUILD")
      if not cmp_file (dir, "stdout.build", [ ], [ ], probeForTargetSpecificFiles)
        cp_if (dir & "/" & BUILD_DIR & "/stdout.build", dir & "/stdout.build")
      end
      if not cmp_file (dir, "stderr.build", [ ], [ ], probeForTargetSpecificFiles)
        cp_if (dir & "/" & BUILD_DIR & "/stderr.build", dir & "/stderr.build")
      end
    end

    local ignoreTexts = [ ]
    local ignoreLines = [ ]
    if should_run
      if equal (sub (uid, 0, 1), "r")
        ignoreLines = ["Abort trap", "Bus error", "Aborted",
                       "Segmentation fault"]
      end
    end
    if equal (uid, "r003")
      ignoreTexts = ["40 bytes", "80 bytes"]
    end

    local ok1 = cmp_file (dir, "stdout.build", ignoreLines, ignoreTexts, probeForTargetSpecificFiles) and
                cmp_file (dir, "stderr.build", ignoreLines, ignoreTexts, probeForTargetSpecificFiles)
    local ok2 = TRUE
    local ok3 = TRUE

    if should_run
      ok2 = cmp_file (dir, "stdout.pgm", ignoreLines, ignoreTexts, probeForTargetSpecificFiles) and
            cmp_file (dir, "stderr.pgm", ignoreLines, ignoreTexts, probeForTargetSpecificFiles)
    end

    if probeForTargetSpecificFiles and FileExists (ExpectedDir)
      foreach a in fs_lsfiles(ExpectedDir, TRUE)
        ok3 = cmp_file(dir, a, ignoreLines, ignoreTexts, probeForTargetSpecificFiles) and ok3
      end
    end

    if DATE and BC
      tstop = compress (q_exec_get (DATE & " '+%s'")[1])
      ttime = ""
      if BcOk
        ret = q_exec ("echo " & tstop & "-" & tstart & " | " & BC & " > ttime")
        ttime = compress ( fs_contents ("ttime"))
      end
    else
      ttime = "0"
    end

    if ok1 and ok2 and ok3
      html (["<tr class=\"bggreen tl\"><td>", uid,
             "</td><td class=\"small\" width=\"45%\">", comment])
      jux (["<testcase time=\"" & ttime & "\" name=\"" & uid & ": " &
             quote_xml( comment ) & "\">", CR])
      >> success in
        write (uid, CR)
      end
    else
      html (["<tr class=\"bgred tl\"><td>", uid,
             "</td><td class=\"small\" width=\"45%\">", comment])
      jux (["<testcase time=\"" & ttime & "\" name=\"" & uid & ": " &
             quote_xml( comment ) & "\">", CR])
      if not ok1 msg = "build failed" end
      if not ok2 msg = "output of program run differs" end
      if not ok3 msg = "code differs" end
      jux (["<error message=\"", msg, "\">", CR])
      >> failure in
        write (uid, CR)
      end
    end

    html ("</td><td class=\"small\"><pre>")
    compare_file (dir, "stdout.build", probeForTargetSpecificFiles)
    compare_file (dir, "stderr.build", probeForTargetSpecificFiles)
    if should_run
      compare_file (dir, "stdout.pgm", probeForTargetSpecificFiles)
      compare_file (dir, "stderr.pgm", probeForTargetSpecificFiles)
    end
    if probeForTargetSpecificFiles and FileExists (ExpectedDir)
      foreach a in fs_lsfiles(ExpectedDir, TRUE)
        compare_file(dir, a, probeForTargetSpecificFiles)
      end
    end
    if not ok1 or not ok2 or not ok3
       jux (["</error>", CR])
    end
    jux (["</testcase>", CR])

    html (["</pre></td></tr>", CR])

    if not keep
      FileRemoveRecursive(dir & "/" & BUILD_DIR)
    end
  end
end


%------------------------------------------------------------------- ptests ---
% PROG tests: complete programs where the output of the program
%   is what is of interest.

readonly proc p_test (group, uid, comment) is
  run_test ("_ptests", group, uid, comment, "run", cm3opts, runopts, "probeForTargetSpecificFiles")
end

p_test ("p2", "p288", "field default constant constructors")
p_test ("p2", "p287", "constant constructors")
p_test ("p2", "p286", "Order of compilation error with array constructor parameter.")
p_test ("p2", "p283", "Long.LT") % This fails an assert in integrated backend.
p_test ("p2", "p282", "grisuc") % This fails in Grisu when using C backend.
p_test ("p2", "p281", "Const Array Decl Bugs (#25), reported by darko20 on 03/24/2018.")
p_test ("p2", "p280", "Parameter passing, many cases, including packed.")
p_test ("p2", "p279", "misaligned, packed components of array and record constructors.")
p_test ("p2", "p278", "64-bit-sized but only 32-bit-aligned values, on 32-bit machines.")
p_test ("p2", "p277", "mixtures of nested constructors")
p_test ("p2", "p275", "More set operators on a small set type in a packed record.")
p_test ("p2", "p274", "Mixed, nested, constructor values.")
p_test ("p2", "p273", "Mixed, nested, constructors with statically inevitable RT errors.")
p_test ("p2", "p272", "Set constructors with statically inevitable RT errors.")
p_test ("p2", "p271", "Constant array constructor, passed READONLY, is passed by value.")
p_test ("p2", "p270", "Array constructors with statically inevitable RT errors.")
p_test ("p2", "p269", "Nested array constructors.")
p_test ("p2", "p268", "Record constructors with statically inevitable RT errors.")
p_test ("p2", "p265", "grisu-based") % grisu-based test, loophole integers/floats, multiply longint within function parameters
p_test ("p2", "p264", "mixtures of fixed and open arrays")
p_test ("p2", "p247", "gcc 4.5.1 assertion failure for SPARC64_SOLARIS")
p_test ("p2", "p246", "gcc 4.5 assertion failure inlining in Poly.m3 for I386_DARWIN, SOLgnu, all 32bit?")
p_test ("p2", "p245", "gcc 4.5 assertion failure inlining in TextConv.m3")
p_test ("p2", "p244", "gcc 4.5 backend crash with 'fre' optimization")
p_test ("p2", "p243", "nested functions removed by gcc backend 'unit at a time'")
p_test ("p2", "p242", "m3totex crashes gcc backend if 'pre' optimimization enabled")
p_test ("p2", "p241", "Formatter crashes gcc backend if 'ter' optimimization enabled")
p_test ("p2", "p238", "'man vs. boy' aka nested procedures+recursion aka static chain test")
p_test ("p2", "p229", "minimal 64bit divide test")
p_test ("p2", "p228", "sign/zero extend return values of functions returning types smaller than 32bits")
p_test ("p2", "p225", "__try/__finally")
p_test ("p2", "p212", "float and double constants, jmpbuf")
p_test ("p2", "p211", "float and double constants work")
p_test ("p2", "p210", "open array initializers runtime failure")
p_test ("p2", "p209", "open array initializers compile failure")
p_test ("p2", "p208", "catching runtime errors")
p_test ("p2", "p207", "subrange declarations")
p_test ("p2", "p206", "ARRAY constructors in var decls using named open array types")
p_test ("p2", "p205", "SUBARRAY of imported CONST ARRAY")
p_test ("p2", "p204", "IP address initializers")
p_test ("p2", "p203", "fingerprint of NULL")
p_test ("p2", "p202", "SUBARRAY actual parameter")
p_test ("p2", "p201", "recursive values")
p_test ("p2", "p200", "recursive types again")
p_test ("p1", "p199", "exporting an obsolete function")
p_test ("p1", "p198", "compiler hash function")
p_test ("p1", "p197", "appending pickles to files")
p_test ("p1", "p196", "procedure valued defaults")
p_test ("p1", "p195", "messy method calls")
p_test ("p1", "p194", "open arrays in fixed array initializers !!BUG!!")
p_test ("p1", "p193", "implicit narrow on '&' operands")
p_test ("p1", "p192", "recursive declarations")
p_test ("p1", "p191", "array assignment generates bad C  !!BUG!!")
p_test ("p1", "p190", "order of evaluation for messy method calls")
p_test ("p1", "p189", "module initialization order")
p_test ("p1", "p188", "initialized globals")
p_test ("p1", "p187", "array assignment when index type changes")
p_test ("p1", "p186", "case statement with large labels")
p_test ("p1", "p185", "REAL vs. C float")
p_test ("p1", "p184", "fold constant to check type equality")
p_test ("p1", "p183", "hidden object field")
p_test ("p1", "p182", "renamed hello world")
p_test ("p1", "p181", "<*NOWARN*>")
p_test ("p1", "p180", "simple generic test")
p_test ("p1", "p179", "alignment of ARRAY OF BITS 32 FOR INTEGER")
p_test ("p1", "p178", "packed fields vs. C's unsigned arithmetic")
p_test ("p1", "p177", "unaligned object field references")
p_test ("p1", "p176", "need full assignment in NEW and constructors")
p_test ("p1", "p175", "CASE stmt with very large bounds")
p_test ("p1", "p174", "large enumeration")
p_test ("p1", "p173", "LONGREAL vs. C's double")
p_test ("p1", "p172", "REAL vs. C's float")
p_test ("p1", "p171", "array constructor as record default")
p_test ("p1", "p170", "simple BITS FOR test")
p_test ("p1", "p169", "runtime fingerprint")
p_test ("p1", "p168", "record constructor with loopholed argument")
p_test ("p1", "p167", "array constructors as parameters")
p_test ("p1", "p166", "RTMisc.Zero test")
p_test ("p1", "p165", "simple TYPECODE test")
p_test ("p1", "p164", "simple thread tests")
p_test ("p1", "p163", "simple statements")
p_test ("p1", "p162", "more operations on very big sets in the heap")
p_test ("p1", "p160", "more operations on very big sets in the heap")
p_test ("p1", "p159", "operations on very big sets in the heap")
p_test ("p1", "p158", "operations on subword-sized sets") % Previously not supported in CM3
p_test ("p1", "p157", "operations on big sets in the heap")
p_test ("p1", "p156", "operations on medium-sized sets")
p_test ("p1", "p155", "operations on small sets")
p_test ("p1", "p151", "by-value open array parameters")
p_test ("p1", "p150", "up-level addressing with INLINEs")
p_test ("p1", "p149", "up-level addressing")
p_test ("p1", "p148", "simple procedure calls")
p_test ("p1", "p146", "NUMBER")
p_test ("p1", "p145", "pass-thru REF types")
p_test ("p1", "p144", "imported variables and order of evaluation")
p_test ("p1", "p143", "variable initialization")
p_test ("p1", "p142", "procedure defaults")
p_test ("p1", "p141", "RTProcess.Exit")
p_test ("p1", "p140", "exceptions")
p_test ("p1", "p139", "memory copy")
p_test ("p1", "p138", "bit field assignments") % Fails on Master branch, 2020-1-9
p_test ("p1", "p137", "bit insert and extract")
p_test ("p1", "p136", "bit operations")
p_test ("p1", "p134", "BITS FOR tests") % -- archaic Modula-2+ bit-field packing
p_test ("p1", "p133", "assignments of records and arrays")
p_test ("p1", "p132", "assignments of builtin types")
p_test ("p1", "p131", "TRUNC, ROUND, FLOOR, CEILING again")
p_test ("p1", "p129", "simple DIV test")
p_test ("p1", "p128", "simple FLOOR test")
p_test ("p1", "p127", "TRUNC, ROUND, FLOOR, CEILING")
p_test ("p1", "p126", "REAL arithmetic")
p_test ("p1", "p125", "MOD of subrange")
p_test ("p1", "p124", "negative DIV of subrange")
p_test ("p1", "p123", "simple arithmetic expresssions")
p_test ("p1", "p122", "RETURN from within TRY-FINALLY")
p_test ("p1", "p121", "real parameters vs. the C compiler")
p_test ("p1", "p120", "small exception arguments (big-endian problem)")
p_test ("p1", "p119", "small exception arguments (big-endian problem)")
p_test ("p1", "p118", "LAST (REAL)")
p_test ("p1", "p117", "SUBARRAY (LOOPHOLE)")
p_test ("p1", "p116b", "default IEEE floating point tests from Xerox PARC")
p_test ("p1", "p115", "reuse of open array conversion within an expression")
p_test ("p1", "p114", "array expressions")
p_test ("p1", "p113", "FIRST/LAST of REAL")
p_test ("p1", "p112", "local revelation that a type is an object")
p_test ("p1", "p111", "C reserved words in call to NEW")
p_test ("p1", "p110", "FIRST/LAST of enumerated types")
p_test ("p1", "p109", "FIRST/LAST of enumerated types in record constants")
p_test ("p1", "p108", "array of procedure constants")
p_test ("p1", "p107", "interface versus implementation names for keyword binding")
p_test ("p1", "p106", "ambiguous desugaring from manual")
p_test ("p1", "p105", "FROM-IMPORT vs. revelations")
p_test ("p1", "p104", "obsolete pragma")
p_test ("p1", "p103", "runtime test of TextRd")
p_test ("p1", "p102", "C reserved words in record constructors and NEW")
p_test ("p1", "p101", "nested procedure in a module's main body")
p_test ("p1", "p100", "unnamed types within LOOPHOLE")
p_test ("p0", "p099", "array constructors and procedure parameters")
p_test ("p0", "p098", "procedure compatibility within an array constructor")
p_test ("p0", "p097", "NEW with method overrides")
p_test ("p0", "p096", "procedure/method constants")
p_test ("p0", "p095", "thread.signal/wait exercise")
p_test ("p0", "p094", "array constants and forward references")
p_test ("p0", "p093", "Rd.GetLine (long line)")
p_test ("p0", "p092", "array of real parameters")
p_test ("p0", "p091", "NULL <: PROCEDURE in array constructor")
p_test ("p0", "p090", "REAL parameter passing - MIPS cc bug")
p_test ("p0", "p089", "revelations of renamed types")
p_test ("p0", "p088", "importing an interface under different names")
p_test ("p0", "p087", "set constructors with variable sized ranges")
p_test ("p0", "p086", "constant folding of FIRST (open array)")
p_test ("p0", "p085", "various combinations of FATAL pragma")
p_test ("p0", "p084", "method overrides and NARROW")
p_test ("p0", "p083", "mixing of exceptions in version stamps")
p_test ("p0", "p082", "operations constant set expressions")
p_test ("p0", "p081", "open array constants")
p_test ("p0", "p080", "order of initialization between interfaces")
p_test ("p0", "p079", "up-level reference of a FOR variable")
p_test ("p0", "p078", "use of constant open arrays in constants")
p_test ("p0", "p077", "BITS 2 FOR [-1..1]")
p_test ("p0", "p076", "b3tests/b005 - more array problems")
p_test ("p0", "p075", "casting open/fixed array to/from open/fixed array")
p_test ("p0", "p074", "b2tests/b004 - initialization of REF RECORD")
p_test ("p0", "p073", "MOD and DIV - new fast versions")
p_test ("p0", "p072", "CHAR literals > 127")
p_test ("p0", "p071", "SUBARRAY := SUBARRAY")
p_test ("p0", "p069", "two object types that differs only by default overwriting")
p_test ("p0", "p067", "mixup in imported names")
p_test ("p0", "p066", "exception handler stack screwed up")
p_test ("p0", "p065", "typecode")
p_test ("p0", "p064", "procedure parameters")
p_test ("p0", "p063", "structural equivalence")
p_test ("p0", "p062", "typecase and List")
p_test ("p0", "p061", "object types & NEW")
p_test ("p0", "p060", "opaque types")
p_test ("p0", "p059", "cc optimizer bug")
p_test ("p0", "p058", "subarray")
p_test ("p0", "p057", "open array parameter")
p_test ("p0", "p056", "subarray assignment")
p_test ("p0", "p055", "recursive fibonacci")
p_test ("p0", "p054", "Richards' simulation benchmark")
p_test ("p0", "p053", "set operations")
p_test ("p0", "p052", "indexing of ref open array")
p_test ("p0", "p051", "external variables")
p_test ("p0", "p050", "open array parameters")
p_test ("p0", "p049", "procedure parameters")
p_test ("p0", "p048", "nested procedures")
p_test ("p0", "p047", "Real - Integer LOOPHOLE")
p_test ("p0", "p046", "Word.Insert, array of [0..255]")
p_test ("p0", "p045", "nested procedures")
p_test ("p0", "p044", "MIN, MAX, WITH and record constructors")
p_test ("p0", "p043", "List.Sort, NARROW, and NEW")
p_test ("p0", "p042", "floating point ABS, MAX, divide")
p_test ("p0", "p041", "floating point comparison and SIGN function")
p_test ("p0", "p040", "binary <-> ASCII conversion routines")
p_test ("p0", "p039", "VERY LONG thread test - commented out")
p_test ("p0", "p038", "sizes of two-byte signed integer subranges")
p_test ("p0", "p037", "tests Time.LongPause")
p_test ("p0", "p036", "fibonacci")
p_test ("p0", "p035", "equality of procedures")
p_test ("p0", "p034", "equality of open arrays and records")
p_test ("p0", "p032", "passing of array parameters")
p_test ("p0", "p031", "parameter modes, except arrays")
p_test ("p0", "p030", "non-opaque OBJECTs")
p_test ("p0", "p029", "nested procedures with up-level variable references")
p_test ("p0", "p028", "fixed ARRAY types variables assignments and subscripting")
p_test ("p0", "p027", "RECORD types variables and assignments")
p_test ("p0", "p026", "user and language specified variable initialization")
p_test ("p0", "p025", "assignment of INTEGER subranges")
p_test ("p0", "p024", "WITH statements")
p_test ("p0", "p023", "WHILE and EXIT statements")
p_test ("p0", "p022", "TYPECASE statements")
p_test ("p0", "p021", "Imbricated TRY FINALLY statements")
p_test ("p0", "p020", "TRY FINALLY and RETURN statements")
p_test ("p0", "p019", "REPEAT and EXIT statements")
p_test ("p0", "p018", "IF statements")
p_test ("p0", "p017", "FOR and EXIT statements")
p_test ("p0", "p016", "CASE statements")
p_test ("p0", "p015", "simple procedure with integer argument")
p_test ("p0", "p014", "variables in nested blocks and procedures")
p_test ("p0", "p013", "indirect calls")
p_test ("p0", "p012", "up-level addressing")
p_test ("p0", "p011", "BITSIZE BYTESIZE ADRSIZE")
p_test ("p0", "p010", "TYPECODE NARROW")
p_test ("p0", "p009", "ORD VAL NUMBER FIRST LAST")
p_test ("p0", "p008", "thread alerts")
p_test ("p0", "p007", "a whole bunch of threads - does the memory grow ?")
p_test ("p0", "p006", "a bit more complicated")
p_test ("p0", "p005", "a simple thread program")
p_test ("p0", "p004", "exception mechanism")
p_test ("p0", "p003", "Fmt")
p_test ("p0", "p002", "Text")
p_test ("p0", "p001", "Hello world")


% programs with extra command line flags

readonly proc p_run_flags_test (group, uid, comment, runopts) is
  %local cm3opts = ""
  run_test ("_p_run_flags_test", group, uid, comment, "run", cm3opts, runopts, "probeForTargetSpecificFiles")
end

p_run_flags_test ("p2", "p216", "runtime arguments: @M3nogc", "@M3nogc")
p_run_flags_test ("p2", "p215", "runtime arguments: @M3nogenerational", "@M3nogenerational")
p_run_flags_test ("p2", "p214", "runtime arguments: @M3noincremental", "@M3noincremental")
p_run_flags_test ("p2", "p213", "runtime arguments: @M3paranoidgc", "@M3paranoidgc")


% programs that we do not actually run

readonly proc build_flags_test (group, uid, comment, cm3opts) is
  local run = FALSE
  %local runopts = ""
  run_test ("_build_flags_tests", group, uid, comment, run, cm3opts, runopts, "probeForTargetSpecificFiles")
end

% The following test won't run until FSUtils.RmRec() is fixed
build_flags_test ("p2", "p223", ".M3SHIP Library", "-no-m3ship-resolution -group-writable")
build_flags_test ("p2", "p222", ".M3SHIP Library", "-no-m3ship-resolution -group-writable")
build_flags_test ("p2", "p221", ".M3SHIP Library", "-no-m3ship-resolution")
build_flags_test ("p2", "p220", ".M3SHIP library", "-no-m3ship-resolution")
build_flags_test ("p2", "p219", ".M3SHIP Program group-writable", "-no-m3ship-resolution -group-writable")
build_flags_test ("p2", "p218", ".M3SHIP Program", "-no-m3ship-resolution")
build_flags_test ("p2", "p217", ".M3SHIP program", "-no-m3ship-resolution")


% programs that we run with and without an agreed upon flag,
% to hide or reveal output that will vary some across target platforms
%  (wordsize and/or endian specific,
% hopefully never "fully target specific")

readonly proc mixed_portability_test (group, uid, comment) is
  run_test ("_mixed_portability_tests_less_portable", group, uid, comment, "", cm3opts, runopts, FALSE)
  run_test ("_mixed_portability_tests_portable", group, uid, comment, "run", cm3opts, runopts & " -include-less-portable-output", "probeForTargetSpecificFiles")
end

mixed_portability_test ("p2", "p227", "longint, word, add, insert, extract, etc. (slow)")


% some currently broken tests...

%p_test ("p2", "p240", "exact codegen")
%p_test ("p2", "p226", "atomics")
%p_test ("p2", "p224", "mutex checker (approx. 4 to 5 minutes)")
%p_test ("p1", "p161", "more operations on very big sets in the heap") %Extremely time-consuming
%p_test ("p1", "p135", "more BITS FOR tests") % CM3 restriction: scalars in packed array elements cannot cross word boundaries
%p_test ("p1", "p130", "signed/unsigned conversions")
%p_test ("p0", "p068", "PrintProc for arrays and array of chars and Text.T") %obsolete.

%if _FloatPieces contains "IEEE-default"
%end
%else
% p_test ("p1", "p154", "simple SCANF tests on RdV")
% p_test ("p1", "p153", "more elaborate SCANF tests")
% p_test ("p1", "p152", "simple SCANF tests")
% p_test ("p1", "p147", "Modula-2+ PRINTF tests")
% p_test ("p1", "p116", "IEEE floating point tests from Xerox PARC")
% p_test ("p0", "p070", "procedure registration") % not supported in CM3
  % implemented (all procedure raise exceptions). In this case we run
  % a stripped-down set of tests.
  % In all IEEE-default configurations, the FloatMode interface is not


%------------------------------------------------------------------- etests ---
% ERROR tests: modules containing static errors where the generated
%   error messages are of interest.

readonly proc e_test (group, uid, comment) is
  run_test ("_etests", group, uid, comment, "", cm3opts, runopts, "probeForTargetSpecificFiles")
end

e_test ("e0", "e040", "Bad SUBARRAY actuals")
e_test ("e0", "e035", "illegal recursive declaration")
e_test ("e0", "e034", "structural equivalence of records")
e_test ("e0", "e033", "importing the builtin scope through an arbitrary interace")
e_test ("e0", "e032", "FROM IMPORT in an IMPORTed interface is visible in the module")
e_test ("e0", "e031", "spurious '..' in array initializer")
e_test ("e0", "e030", "missing main program")
e_test ("e0", "e029", "use type instead of value as an initializer")
e_test ("e0", "e028", "circular FROM imports")
e_test ("e0", "e027", "b1tests/b005 - ARRAY [1..0] OF x is empty")
e_test ("e0", "e026", "two types with the same brand")
e_test ("e0", "e025", "incompatible array parameter")
e_test ("e0", "e024", "illegal recursive declaration")
e_test ("e0", "e023", "illegal recursive declaration")
e_test ("e0", "e022", "illegal recursive declaration")
e_test ("e0", "e021", "illegal recursive declaration")
e_test ("e0", "e020", "illegal recursive declaration")
e_test ("e0", "e019", "illegal recursive declaration")
e_test ("e0", "e018", "illegal recursive declaration")
e_test ("e0", "e017", "illegal recursive declaration")
e_test ("e0", "e016", "FROM IMPORT in an EXPORTed interface is visible in the module")
e_test ("e0", "e015", "illegal recursive declaration x=y/y=x")
e_test ("e0", "e014", "coverage of procedure signature in interface by module")
e_test ("e0", "e013", "illegal recursive declaration")
e_test ("e0", "e012", "NULL is not a statment")
e_test ("e0", "e011", "m3compiler accepts any type for VAR ARRAY OF formal")
e_test ("e0", "e010", "verify that there are enough elements in an array constructor")
e_test ("e0", "e009", "method specified in NEW incompatible with type declaration")
e_test ("e0", "e008", "circular imports")
e_test ("e0", "e007", "procedure constants (no longer an error...)")
e_test ("e0", "e006", "non-imported exceptions are visible !")
e_test ("e0", "e005", "/ instead of DIV on CARDINAL constants")
e_test ("e0", "e004", "Text.Cat with the wrong number of arguments")
e_test ("e0", "e003", "exception not at the top-level")
e_test ("e0", "e002", "non-constant variable initialization in an interface")
e_test ("e0", "e001", "assigning non-overlapping subrange types")


%------------------------------------------------------------------- rtests ---
%  RUNTIME tests: modules containing runtime error where the generated
%    error messages are of interest.

readonly proc r_test (group, uid, comment) is
  run_test ("_rtests", group, uid, comment, "run", cm3opts, runopts, "probeForTargetSpecificFiles")
end

r_test ("r0", "r005", "assertion failure messages include expression")
r_test ("r0", "r004", "negative size for an open array")
r_test ("r0", "r003", "b3tests/b002 - improper size for an open array parameter")
r_test ("r0", "r002", "stack overflow in the main thread")
r_test ("r0", "r001", "unhandled exception")

%------------------------------------------------------------------- xtests ---
%  MISC tests (x): programs or modules that require a human to test
%    because they have non-deterministic or timing dependent behavior.

readonly proc x_test (group, uid, comment) is
  if defined ("_all") return end
  run_test ("_xtests", group, uid, comment, "run", cm3opts, runopts, "probeForTargetSpecificFiles")
end

x_test ("x0", "x007", "thread.alerted/shutdown exercise")
x_test ("x0", "x006", "concurrent input and output")
x_test ("x0", "x005", "Wr.PutChar(Rd.GetChar) loop - needs input")
x_test ("x0", "x004", "Readers - requires input")
x_test ("x0", "x003", "more Thread tests - requires input")
x_test ("x0", "x002", "Wr.PutChar (Rd.GetChar) loop on a file")
x_test ("x0", "x001", "Wr.PutChar (Rd.GetChar) loop")


%------------------------------------------------------------------- ctests ---
%  CODE tests: tiny modules where the code output by the compiler
%     is what's of interest.
%
% -- only wizards should bother to run the ctests, to tell if they
%     work, you must manually examine the code that's produced
%

proc c_test (group, uid, comment) is
  if defined ("_all") return end
  run_test ("_ctests", group, uid, comment, "", cm3opts, runopts, "probeForTargetSpecificFiles")
end

c_test ("c1", "c144", "qid")
c_test ("c1", "c142", "imported procedure value parms in word or struct")
c_test ("c1", "c141", "unknown")
c_test ("c1", "c140", "unknown")
c_test ("c1", "c139", "unknown")
c_test ("c1", "c138", "unknown")
c_test ("c1", "c136", "unknown")
c_test ("c1", "c135", "unknown")
c_test ("c1", "c134", "statically initialized fields")
c_test ("c1", "c133", "unknown")
c_test ("c1", "c132", "unknown")
c_test ("c1", "c131", "unknown")
c_test ("c1", "c130", "unknown")
c_test ("c1", "c129", "unknown")
c_test ("c1", "c128", "unknown")
c_test ("c1", "c127", "nasty scoping and lazy typechecking interactions")
c_test ("c1", "c126", "assignability of recursive types")
c_test ("c1", "c125", "LAST of subrange assignment in record constructor")
c_test ("c1", "c124", "recursion on Module names is allowed")
c_test ("c1", "c123", "implicit import of large constants")
c_test ("c1", "c122", "the compiler dumps core !")
c_test ("c1", "c121", "b1tests/b008 - multiple timestamps for a single type")
c_test ("c1", "c120", "b2tests/b001 - empty records cause improper C type")
c_test ("c1", "c119", "b1tests/b004 - open array actual / VAR fixed array formal")
c_test ("c1", "c118", "b1tests/b002 - BYTESIZE illegal in CASE ?")
c_test ("c1", "c117", "b1tests/b001 - array constructors")
c_test ("c1", "c116", "subrange of enumerated type used as array index =b1tests/b003")
c_test ("c1", "c115", "line 15: illegal operand for MOD ?")
c_test ("c1", "c114", "initialization of UNTRACED REF variables")
c_test ("c1", "c113", "size of local copies of value formal arrays")
c_test ("c1", "c112", "assignable types")
c_test ("c1", "c111", "external variables should not be initialized")
c_test ("c1", "c110", "ObjectType.Method does not work")
c_test ("c1", "c109", "unknown")
c_test ("c1", "c108", "unknown")
c_test ("c1", "c107", "unknown")
c_test ("c1", "c106", "unknown")
c_test ("c1", "c105", "unknown")
c_test ("c1", "c104", "unknown")
c_test ("c1", "c103", "unknown")
c_test ("c1", "c102", "unknown")
c_test ("c1", "c101", "unknown")
c_test ("c1", "c100", "unknown")
c_test ("c0", "c099", "unknown")
c_test ("c0", "c098", "unknown")
c_test ("c0", "c097", "unknown")
c_test ("c0", "c096", "unknown")
c_test ("c0", "c095", "unknown")
c_test ("c0", "c094", "unknown")
c_test ("c0", "c093", "unknown")
c_test ("c0", "c092", "unknown")
c_test ("c0", "c091", "unknown")
c_test ("c0", "c090", "unknown")
c_test ("c0", "c089", "unknown")
c_test ("c0", "c088", "unknown")
c_test ("c0", "c087", "unknown")
c_test ("c0", "c086", "unknown")
c_test ("c0", "c085", "unknown")
c_test ("c0", "c084", "unknown")
c_test ("c0", "c083", "unknown")
c_test ("c0", "c082", "unknown")
c_test ("c0", "c081", "unknown")
c_test ("c0", "c080", "unknown")
c_test ("c0", "c079", "unknown")
c_test ("c0", "c078", "unknown")
c_test ("c0", "c077", "unknown")
c_test ("c0", "c076", "unknown")
c_test ("c0", "c075", "unknown")
c_test ("c0", "c074", "INC and DEC - range checking")
c_test ("c0", "c073", "procedure arguments")
c_test ("c0", "c072", "ASSERT")
c_test ("c0", "c071", "procedures that return structures in C")
c_test ("c0", "c070", "scopes")
c_test ("c0", "c069", "assignment of open arrays")
c_test ("c0", "c068", "does refany have a typecell ?")
c_test ("c0", "c067", "EXTERNAL vs. non EXTERNAL")
c_test ("c0", "c066", "Constructor expressions")
c_test ("c0", "c065", "ADDRESS arithmetic")
c_test ("c0", "c064", "common subexpressions are not always common")
c_test ("c0", "c063", "NIL is a ROOT")
c_test ("c0", "c062", "RCmaps of REF types")
c_test ("c0", "c061", "CASE statements")
c_test ("c0", "c060", "nested procedures and variables")
c_test ("c0", "c059", "recursive types and constant expressions")
c_test ("c0", "c058", "open array parameters")
c_test ("c0", "c057", "CSE on array indexing expressions")
c_test ("c0", "c056", "twisted mutually recursive types")
c_test ("c0", "c055", "coverage of arithmetic operations and relations")
c_test ("c0", "c054", "coverage of builtinWord")
c_test ("c0", "c053", "MAX")
c_test ("c0", "c052", "type identification")
c_test ("c0", "c051", "revealing objects")
c_test ("c0", "c050", "opaque object types")
c_test ("c0", "c049", "based constants and BITS FOR...")
c_test ("c0", "c048", "NUMBER")
c_test ("c0", "c047", "RAISE statements")
c_test ("c0", "c046", "declaring an opaque type")
c_test ("c0", "c045", "Text.PutStr -  passing a fixed array to an open array formal")
c_test ("c0", "c044", "escape character literals")
c_test ("c0", "c043", "RECORD constants")
c_test ("c0", "c042", "SET declarations and constants")
c_test ("c0", "c041", "FIRST and LAST as constants")
c_test ("c0", "c040", "large INTEGER constants")
c_test ("c0", "c039", "SUBARRAY")
c_test ("c0", "c038", "open ARRAY indexing")
c_test ("c0", "c037", "NEW of opaque OBJECTs with default and non-default slots")
c_test ("c0", "c036", "NEW of OBJECTs with default and non-default slots")
c_test ("c0", "c035", "NEW of open arrays")
c_test ("c0", "c034", "NEW of REF types that require initialization")
c_test ("c0", "c033", "NEW of simple REF types")
c_test ("c0", "c032", "BRANDED REF types")
c_test ("c0", "c031", "assignment and initialization of INTEGER subranges")
c_test ("c0", "c030", "opaque OBJECTS")
c_test ("c0", "c029", "non-opaque OBJECTs")
c_test ("c0", "c028", "type minimization of REF/RECORD")
c_test ("c0", "c027", "nested procedures with up-level variable references")
c_test ("c0", "c026", "fixed ARRAY types variables assignments and subscripting")
c_test ("c0", "c025", "RECORD types variables and assignments")
c_test ("c0", "c024", "importing an external subrange type")
c_test ("c0", "c023", "simple subrange type in an Interface")
c_test ("c0", "c022", "user and language specified variable initialization")
c_test ("c0", "c021", "procedures and variables in an Interface")
c_test ("c0", "c020", "assignment of INTEGER subranges")
c_test ("c0", "c019", "WITH statements")
c_test ("c0", "c018", "WHILE and EXIT statements")
c_test ("c0", "c017", "TYPECASE statements")
c_test ("c0", "c016", "TRY EXCEPT statements")
c_test ("c0", "c015", "imbricated TRY FINALLY statements")
c_test ("c0", "c014", "TRY FINALLY and RETURN statements")
c_test ("c0", "c013", "REPEAT and EXIT statements")
c_test ("c0", "c012", "LOOP and EXIT statements")
c_test ("c0", "c011", "address subtraction")
c_test ("c0", "c010", "IF statements")
c_test ("c0", "c009", "FOR and EXIT statements")
c_test ("c0", "c008", "CASE statements")
c_test ("c0", "c007", "a procedure with an integer argument")
c_test ("c0", "c006", "variables in nested blocks and procedures")
c_test ("c0", "c005", "declaration of T subtype REFANY")
c_test ("c0", "c004", "declaration of REF INTEGER")
c_test ("c0", "c003", "a program with two statements")
c_test ("c0", "c002", "empty unsafe program")
c_test ("c0", "c001", "empty program")



% Finalize HTML report.
html(["      </tbody>", CR])
html(["    </table>", CR])
html(["", CR])
html(["    <hr>", CR])
html(["    <address><a href=\"mailto:m3-support{at}elego.de\">m3-support{at}elego.de</a></address>", CR])
html(["  </body>", CR])
html(["</html>", CR])

% Finalize JUnit XML report.
if defined("HTML")
  nok  = GetFileLineCount(success)
  nko  = GetFileLineCount(failure)
  nall = GetFileLineCount2(success, failure)
  > juxreport in
    write ("<testsuite name=\"m3tests\" ")
    write ("tests=\"" & nall & "\" ")
    write ("errors=\"" & nko & "\">", CR)
    write(fs_contents(juxworking))
    write ("</testsuite>", CR)
  end
  fs_rmfile (juxworking)
end
end % NOT LIB_ONLY
