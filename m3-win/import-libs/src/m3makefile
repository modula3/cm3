%
% Jay Krell
% jaykrell@cornell.edu
% October 18, 2006 in Windows cmd
% ported to Quake December 31, 2006 so it might be run at the right time in a build (ie: the first package, before m3core)
% Possibly also for a hypothetical Windows targeted non-Windows hosted build.
% 
% This is the second stage in producing Windows import .libs.
% Given Quake code snippets output by make-lib-1.cmd, produce
% .c and .def files and compile and link them.
%

%
%
% The .libs that come with CM3 5.2.6 do not work with Visual C++ prior to 5.0, nor with 8.0.
% The Visual C++ 7.1 and 8.0 Express Editions are missing many .libs.
% We are stuck with no /really simple/ solution, but several not too difficult solutions.
%
% We could detect the linker version and accept the 5.2.6 .libs.
%   We presently do no toolset version checking, though this isn't a bad option.
%
% We could delete the .libs if using Visual C++ 2.0 or 4.0.
%    Again, we don't do toolset version checking.
%
% We could delete the .libs unconditionally and users of Express Editions must
% install the free download Platform SDK.
%    This is not a bad option.
%
% We could detect the linker version and have like \cm3\lib\vc20, \cm3\lib\vc40, \cm3\lib\vc50, etc.
% Some of these directories would be copies of \cm3\lib, others would be generated by make-lib-2.
%
% We could require users (esp. of older toolsets) to run scripts\win\lib\make-lib-2.
%   This is ok.
%
% We could run make-lib-2 for folks automatically.
%   That is what we do.
%
% Future binary distributions should perhaps contain .libs built with the oldest supported toolset (perhaps
%  that is already the case). But this automatic way should be good.
%
%

%
% The kernel32.lib installed by CM3 5.2.6 is missing InterlockedCompareExchange
% that is needed by msvcrt.lib 8.0.
%
% The user32.lib installed by 5.2.6 causes the Visual C++ 4.0 linker to
% have an "internal error".
%
% The wsock32.lib installed by 5.2.6 causes the Visual C++ 4.0 linker to
% error regarding corrupt debugging information.
%
% There are more link errors, make everything.
%

% It would be nice if we could turn off linking to all .libs, but we cannot. This does nothing.
% This is only part of the commented out attempt to use Quake more and exec("cl...") less.
% It does nothing either way.
SYSTEM_LIBS = { }
SYSTEM_LIBORDER = { }

local Files = {
    "advapi32",
    "comctl32",
    "comdlg32",
    "gdi32",
    "glu32",
    "kernel32",
    "netapi32",
    "odbc32",
    "odbccp32",
    "opengl32",
    "user32",
    "winspool",
    "wsock32",
}

local readonly Signatures = {
 "0" : "void",
 "4" : "u a1",
 "8" : "u a1, u a2",
"12" : "u a1, u a2, u a3",
"16" : "u a1, u a2, u a3, u a4",
"20" : "u a1, u a2, u a3, u a4, u a5",
"24" : "u a1, u a2, u a3, u a4, u a5, u a6",
"28" : "u a1, u a2, u a3, u a4, u a5, u a6, u a7",
"32" : "u a1, u a2, u a3, u a4, u a5, u a6, u a7, u a8",
"36" : "u a1, u a2, u a3, u a4, u a5, u a6, u a7, u a8, u a9",
"40" : "u a1, u a2, u a3, u a4, u a5, u a6, u a7, u a8, u a9, u a10",
"44" : "u a1, u a2, u a3, u a4, u a5, u a6, u a7, u a8, u a9, u a10, u a11",
"48" : "u a1, u a2, u a3, u a4, u a5, u a6, u a7, u a8, u a9, u a10, u a11, u a12",
"52" : "u a1, u a2, u a3, u a4, u a5, u a6, u a7, u a8, u a9, u a10, u a11, u a12, u a13",
"56" : "u a1, u a2, u a3, u a4, u a5, u a6, u a7, u a8, u a9, u a10, u a11, u a12, u a13, u a14",
"64" : "u a1, u a2, u a3, u a4, u a5, u a6, u a7, u a8, u a9, u a10, u a11, u a12, u a13, u a14, u a15, u a16",
"68" : "u a1, u a2, u a3, u a4, u a5, u a6, u a7, u a8, u a9, u a10, u a11, u a12, u a13, u a14, u a15, u a16, u a17",
"72" : "u a1, u a2, u a3, u a4, u a5, u a6, u a7, u a8, u a9, u a10, u a11, u a12, u a13, u a14, u a15, u a16, u a17, u a18",
% obvious hack here, with several obvious fixes
% Quake can't do math so we'd have to resort to leveraging the pass 1 Perl or some C++.
}

proc SourceFilePath(a) is
    return ".." & SL & "src" & SL & a
end

foreach File in Files

    local readonly QuakeFileName = File & ".quake"
    local readonly CppFilePath = File & ".c"
    local readonly ObjFilePath = File & ".obj"
    local readonly DefFilePath = File & ".def"
    local readonly LibFilePath = File & ".lib"

    if stale(LibFilePath, [SourceFilePath(QuakeFileName),
        %SourceFilePath("m3makefile")
        ])

        include(QuakeFileName)

        local Extension = "dll"
        local CppFileContents = [ ]
        local DefFileContents = [ ]
%
% These should be large strings and we'd say
% CppFileContents = CppFileContents & ...
% but that overflows buffers in the Modula-3 code, so use arrays instead.
% This nets us some extra whitespace, but that is ok.
%
        CppFileContents += ["#if defined(__cplusplus)" & CR]
        CppFileContents += ["extern \"C\" {" & CR]
        CppFileContents += ["#endif" & CR]
        CppFileContents += ["#pragma warning(disable:4100) /* unused parameter */" & CR]
        CppFileContents += ["typedef unsigned u;" & CR]

        %
        % This is only used if you build with derived_c + library below.
        %
        %CppFileContents += ["void __stdcall _DllMainCRTStartup(u a, u b, u c) { }" & CR]

        DefFileContents += [DefFileContents & "EXPORTS" & CR]

        foreach FunctionName in Files{File}
            if equal(FunctionName, "Extension")
                Extension = Files{File}{"Extension"}
            else
                Signature = Files{File}{FunctionName}
                DefFileContents += [" " & FunctionName & CR]
                if equal(Signature, "__cdecl")
                    CppFileContents += ["void __cdecl " & FunctionName & "() { }" & CR]
                else
                    CppFileContents += ["void __stdcall " & FunctionName & "("
                        & Signatures{Signature} & ") { }" & CR]
                end
            end
        end
        CppFileContents += ["#if defined(__cplusplus)" & CR]
        CppFileContents += ["} /* extern \"C\" */" & CR]
        CppFileContents += ["#endif" & CR]
        > CppFilePath in
            write(CppFileContents)
        end
        > DefFilePath in
            write(DefFileContents)
        end
        %
        % This almost works but does a lot of extra stuff and installs a lot of extra files including
        % bogus .dlls to \cm3\bin. We want the .libs but not the .dlls.
        %
        %derived_c(File)
        %library(File)

        %
        % This needs work.
        % In order for folks using older toolsets to be able to use the .libs in the distribution,
        % try to use an older toolset.
        %
        local msvc20 = "\\msvc20\\bin"
        local CommandPrefix = ""
        if file_exists(msvc20) and equal($OS, "Windows_NT")
            %
            % Visual C++ does like the spaces from 8.0, at least in %INCLUDE%.
            % /X works
            %
            %CommandPrefix = "set INCLUDE= && set LIB= && " & msvc20 & SL
            CommandPrefix = msvc20 & SL
        end
        %exec(CommandPrefix & "cl /c /X /nologo /W4 /WX /Tp" & CppFilePath)
        %exec(CommandPrefix & "link /nologo /dll /nodefaultlib /noentry /def:" & DefFilePath & " /out:" & File & "." & Extension & " " & ObjFilePath)
        exec(CommandPrefix & "cl /LD /Zl /X /nologo /W4 /WX /Tp" & CppFilePath & " /link /nodefaultlib /noentry /def:" & DefFilePath & " /out:" & File & "." & Extension)
        LibdExport(File & ".lib")

        %
        % .m3x files needed but not otherwise produced.
        %
        > File & ".m3x" in 
          write("")
        end
    end
end

%
% .M3WEB needed but not otherwise produced.
%
> ".M3WEB" in 
  write("")
end

%
% This should be built-in.
%
proc file_exists(a) is
  return not stale (a, a)
end
