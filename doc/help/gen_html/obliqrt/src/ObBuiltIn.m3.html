<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: obliqrt/src/ObBuiltIn.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>obliqrt/src/ObBuiltIn.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright 1991 Digital Equipment Corporation. 
 Distributed only by permission. 

<P><PRE>MODULE <module><implements><A HREF="ObBuiltIn.i3.html">ObBuiltIn</A></implements></module>;
IMPORT <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../libm3/src/rw/TextRd.i3.html">TextRd</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../libm3/src/fmtlex/Lex.i3.html">Lex</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="ObLib.i3.html">ObLib</A>, <A HREF="ObValue.i3.html">ObValue</A>, <A HREF="../../synloc/src/SynLocation.i3.html">SynLocation</A>, <A HREF="../../m3core/src/text/TextConv.i3.html">TextConv</A>,
       <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../netobj/src/netobjrt/NetObj.i3.html">NetObj</A>, <A HREF="../../libm3/src/params/Env.i3.html">Env</A>, <A HREF="../../libm3/src/params/Params.i3.html">Params</A>, <A HREF="../../libm3/src/arith/POSIX/Math.i3.html">Math</A>, <A HREF="ObEval.i3.html">ObEval</A>, <A HREF="../../sharedobj/src/ObjectSpace.i3.html">ObjectSpace</A>, <A HREF="../../m3core/src/float/IEEE-default/FloatMode.i3.html">FloatMode</A>,
       <A HREF="../../sharedobj/src/SharedObj.i3.html">SharedObj</A>, <A HREF="../../sharedobj/src/SharedObjRT.i3.html">SharedObjRT</A>, <A HREF="ObValueNotify.i3.html">ObValueNotify</A>, <A HREF="Obliq.i3.html">Obliq</A>, <A HREF="../../m3core/src/time/Common/Time.i3.html">Time</A>, <A HREF="../../synloc/src/SynWr.i3.html">SynWr</A>,
       <A HREF="../../events/src/WorkerPool.i3.html">WorkerPool</A>, <A HREF="../../events/src/Work.i3.html">Work</A>;

PROCEDURE <A NAME="Setup"><procedure>Setup</procedure></A> () =
  BEGIN
    SetupSys();
    SetupBool();
    SetupInt();
    SetupReal();                 (* after Int, so real_+ etc.  have
                                    precedence *)
    SetupMath();
    SetupAscii();
    SetupText();
    SetupArray();
    SetupNet();
    SetupReplica();
    SetupThread();
</PRE>    SetupReflect();
  <PRE>END Setup;
</PRE> ============ <CODE>sys</CODE> package ============ 

<P><PRE>TYPE

  SysCode = {Address, GetEnvVar, GetParamCount, GetParam, CallFailure,
             Call, Copy, TimeNow, TimeGrain};

  SysOpCode = ObLib.OpCode OBJECT code: SysCode;  END;

  PackageSys = ObLib.T OBJECT OVERRIDES Eval := EvalSys; END;

PROCEDURE <A NAME="NewSysOC"><procedure>NewSysOC</procedure></A> (name  : TEXT;
                    arity : INTEGER;
                    code  : SysCode;
                    fixity: ObLib.OpFixity := ObLib.OpFixity.Qualified):
  SysOpCode =
  BEGIN
    RETURN NEW(SysOpCode, name := name, arity := arity, code := code,
               fixity := fixity);
  END NewSysOC;

PROCEDURE <A NAME="SetupSys"><procedure>SetupSys</procedure></A> () =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(SysCode));
    opCodes^ :=
      OpCodes{NewSysOC(&quot;address&quot;, -1, SysCode.Address),
              NewSysOC(&quot;getEnvVar&quot;, 1, SysCode.GetEnvVar),
              NewSysOC(&quot;paramCount&quot;, -1, SysCode.GetParamCount),
              NewSysOC(&quot;getParam&quot;, 1, SysCode.GetParam),
              NewSysOC(&quot;callFailure&quot;, -1, SysCode.CallFailure),
              NewSysOC(&quot;call&quot;, 2, SysCode.Call),
              NewSysOC(&quot;timeNow&quot;, -1, SysCode.TimeNow),
              NewSysOC(&quot;timeGrain&quot;, -1, SysCode.TimeGrain),
              NewSysOC(&quot;copy&quot;, 1, SysCode.Copy, ObLib.OpFixity.Prefix)};
    ObLib.Register(NEW(PackageSys, name := &quot;sys&quot;, opCodes := opCodes));
  END SetupSys;

PROCEDURE <A NAME="EvalSys"><procedure>EvalSys</procedure></A> (                    self  : PackageSys;
                                       opCode: ObLib.OpCode;
                   &lt;*UNUSED*&gt;          arity : ObLib.OpArity;
                              READONLY args  : ObValue.ArgArray;
                                       temp  : BOOLEAN;
                                       loc   : SynLocation.T     ):
  ObValue.Val RAISES {ObValue.Error, ObValue.Exception} =
  VAR
    int1        : INTEGER;
    text1, text2: TEXT;
    array1      : REF ObValue.Vals;
    sysProc     : ObValue.SysCallClosure;
  BEGIN
    TRY
      CASE NARROW(opCode, SysOpCode).code OF
      | SysCode.Address =&gt; RETURN ObValue.NewText(ObValue.machineAddress);
      | SysCode.GetEnvVar =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
          END;
          text2 := Env.Get(text1);
          RETURN ObValue.NewText(text2);
      | SysCode.GetParamCount =&gt;
          RETURN NEW(ObValue.ValInt, int := Params.Count, temp := temp);
      | SysCode.GetParam =&gt;
          TYPECASE args[1] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(1, &quot;int&quot;, self.name, opCode.name, loc);
          END;
          IF (int1 &lt; 0) OR (int1 &gt;= Params.Count) THEN
            ObValue.BadArgVal(1, &quot;in range&quot;, self.name, opCode.name, loc);
          END;
          RETURN ObValue.NewText(Params.Get(int1));
      | SysCode.CallFailure =&gt; RETURN ObValue.sysCallFailure;
      | SysCode.Call =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
          END;
          TYPECASE args[2] OF
          | ObValue.ValArray (node) =&gt; array1 := node.remote.Obtain();
          ELSE
            ObValue.BadArgType(2, &quot;array&quot;, self.name, opCode.name, loc)
          END;
          IF NOT ObValue.FetchSysCall(text1, (*out*) sysProc) THEN
            ObValue.RaiseException(ObValue.sysCallFailure,
                                   self.name &amp; &quot;_&quot; &amp; opCode.name &amp; &quot;: \&quot;&quot;
                                     &amp; text1 &amp; &quot;\&quot; not found&quot;, loc);
          END;
          RETURN sysProc.SysCall(array1^, loc);
      | SysCode.Copy =&gt;
          RETURN ObValue.CopyVal(args[1], ObValue.NewTbl(), loc);
      | SysCode.TimeNow =&gt; RETURN Obliq.NewReal(Time.Now());
      | SysCode.TimeGrain =&gt;
          WITH grain = Time.Grain DO RETURN Obliq.NewReal(grain); END;
      ELSE
        ObValue.BadOp(self.name, opCode.name, loc);
        &lt;*ASSERT FALSE*&gt;
      END;
    EXCEPT
    | SharedObj.Error (atoms) =&gt;
        ObValue.RaiseSharedException(
          self.name &amp; &quot;_&quot; &amp; opCode.name, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | NetObj.Error (atoms) =&gt;
        ObValue.RaiseNetException(
          self.name &amp; &quot;_&quot; &amp; opCode.name, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, self.name &amp; &quot;_&quot; &amp; opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END EvalSys;
</PRE> ============ <CODE>bool</CODE> package ============ 

<P><PRE>TYPE

  BoolCode = {Is, IsNot, Not, And, Or};

  BoolOpCode = ObLib.OpCode OBJECT code: BoolCode;  END;

  PackageBool = ObLib.T OBJECT OVERRIDES Eval := EvalBool; END;

PROCEDURE <A NAME="NewBoolOC"><procedure>NewBoolOC</procedure></A> (name  : TEXT;
                     arity : INTEGER;
                     code  : BoolCode;
                     fixity: ObLib.OpFixity := ObLib.OpFixity.Qualified):
  BoolOpCode =
  BEGIN
    RETURN NEW(BoolOpCode, name := name, arity := arity, code := code,
               fixity := fixity);
  END NewBoolOC;

VAR true, false: ObValue.ValBool;

PROCEDURE <A NAME="SetupBool"><procedure>SetupBool</procedure></A> () =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(BoolCode));
    opCodes^ :=
      OpCodes{NewBoolOC(&quot;not&quot;, 1, BoolCode.Not, ObLib.OpFixity.Prefix),
              NewBoolOC(&quot;and&quot;, 2, BoolCode.And, ObLib.OpFixity.Infix),
              NewBoolOC(&quot;or&quot;, 2, BoolCode.Or, ObLib.OpFixity.Infix),
              NewBoolOC(&quot;is&quot;, 2, BoolCode.Is, ObLib.OpFixity.Infix),
              NewBoolOC(&quot;isnot&quot;, 2, BoolCode.IsNot, ObLib.OpFixity.Infix)};
    ObLib.Register(NEW(PackageBool, name := &quot;bool&quot;, opCodes := opCodes));
    true := NEW(ObValue.ValBool, bool := TRUE);
    false := NEW(ObValue.ValBool, bool := FALSE);
  END SetupBool;

PROCEDURE <A NAME="EvalBool"><procedure>EvalBool</procedure></A> (                    self  : PackageBool;
                                        opCode: ObLib.OpCode;
                    &lt;*UNUSED*&gt;          arity : ObLib.OpArity;
                               READONLY args  : ObValue.ArgArray;
                    &lt;*UNUSED*&gt;          temp  : BOOLEAN;
                                        loc   : SynLocation.T     ):
  ObValue.Val RAISES {ObValue.Error} =
  VAR bool1, bool2: BOOLEAN;
  BEGIN
    CASE NARROW(opCode, BoolOpCode).code OF
    | BoolCode.Not =&gt;
        TYPECASE args[1] OF
        | ObValue.ValBool (node) =&gt; bool1 := node.bool;
        ELSE
          ObValue.BadArgType(1, &quot;bool&quot;, self.name, opCode.name, loc);
        END;
        IF NOT bool1 THEN RETURN true ELSE RETURN false END;
    | BoolCode.And =&gt;
        TYPECASE args[1] OF
        | ObValue.ValBool (node) =&gt; bool1 := node.bool;
        ELSE
          ObValue.BadArgType(1, &quot;bool&quot;, self.name, opCode.name, loc);
        END;
        TYPECASE args[2] OF
        | ObValue.ValBool (node) =&gt; bool2 := node.bool;
        ELSE
          ObValue.BadArgType(2, &quot;bool&quot;, self.name, opCode.name, loc);
        END;
        IF bool1 AND bool2 THEN RETURN true ELSE RETURN false END;
    | BoolCode.Or =&gt;
        TYPECASE args[1] OF
        | ObValue.ValBool (node) =&gt; bool1 := node.bool;
        ELSE
          ObValue.BadArgType(1, &quot;bool&quot;, self.name, opCode.name, loc);
        END;
        TYPECASE args[2] OF
        | ObValue.ValBool (node) =&gt; bool2 := node.bool;
        ELSE
          ObValue.BadArgType(2, &quot;bool&quot;, self.name, opCode.name, loc);
        END;
        IF bool1 OR bool2 THEN RETURN true ELSE RETURN false END;
    | BoolCode.Is =&gt;
        IF ObValue.Is(args[1], args[2], loc) THEN
          RETURN true
        ELSE
          RETURN false
        END;
    | BoolCode.IsNot =&gt;
        IF NOT ObValue.Is(args[1], args[2], loc) THEN
          RETURN true
        ELSE
          RETURN false
        END;
    ELSE
      ObValue.BadOp(self.name, opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END EvalBool;
</PRE> ============ <CODE>int</CODE> package ============ 

<P><PRE>TYPE

  IntCode = {Minus, Add, Sub, Mult, Div, Mod, Less, More, LessEq, MoreEq};

  IntOpCode = ObLib.OpCode OBJECT code: IntCode;  END;

  PackageInt = ObLib.T OBJECT OVERRIDES Eval := EvalInt; END;

PROCEDURE <A NAME="NewIntOC"><procedure>NewIntOC</procedure></A> (name  : TEXT;
                    arity : INTEGER;
                    code  : IntCode;
                    fixity: ObLib.OpFixity := ObLib.OpFixity.Qualified):
  IntOpCode =
  BEGIN
    RETURN NEW(IntOpCode, name := name, arity := arity, code := code,
               fixity := fixity);
  END NewIntOC;

PROCEDURE <A NAME="SetupInt"><procedure>SetupInt</procedure></A> () =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(IntCode));
    opCodes^ :=
      OpCodes{
        NewIntOC(&quot;minus&quot;, 1, IntCode.Minus), NewIntOC(&quot;+&quot;, 2, IntCode.Add),
        NewIntOC(&quot;-&quot;, 2, IntCode.Sub), NewIntOC(&quot;*&quot;, 2, IntCode.Mult),
        NewIntOC(&quot;/&quot;, 2, IntCode.Div),
        NewIntOC(&quot;%&quot;, 2, IntCode.Mod, ObLib.OpFixity.Infix),
        NewIntOC(&quot;&lt;&quot;, 2, IntCode.Less), NewIntOC(&quot;&gt;&quot;, 2, IntCode.More),
        NewIntOC(&quot;&lt;=&quot;, 2, IntCode.LessEq),
        NewIntOC(&quot;&gt;=&quot;, 2, IntCode.MoreEq)};
    ObLib.Register(NEW(PackageInt, name := &quot;int&quot;, opCodes := opCodes));
  END SetupInt;

PROCEDURE <A NAME="EvalInt"><procedure>EvalInt</procedure></A> (                    self  : PackageInt;
                                       opCode: ObLib.OpCode;
                   &lt;*UNUSED*&gt;          arity : ObLib.OpArity;
                              READONLY args  : ObValue.ArgArray;
                                       temp  : BOOLEAN;
                                       loc   : SynLocation.T     ):
  ObValue.Val RAISES {ObValue.Error} =
  VAR
    int1, int2              : INTEGER;
    intCode                 : IntCode;
    intRes, intVal1, intVal2: ObValue.ValInt;
  BEGIN
    intCode := NARROW(opCode, IntOpCode).code;
    TYPECASE args[1] OF
    | ObValue.ValInt (node) =&gt; intVal1 := node; int1 := node.int;
    ELSE
      ObValue.BadArgType(1, &quot;int&quot;, self.name, opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
    CASE intCode OF
    | IntCode.Minus =&gt;
        RETURN NEW(ObValue.ValInt, int := -int1, temp := temp);
    | IntCode.Add, IntCode.Sub, IntCode.Mult, IntCode.Div, IntCode.Mod,
        IntCode.Less, IntCode.More, IntCode.LessEq, IntCode.MoreEq =&gt;
        TYPECASE args[2] OF
        | ObValue.ValInt (node) =&gt; intVal2 := node; int2 := node.int;
        ELSE
          ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        CASE intCode OF
        | IntCode.Minus =&gt;       &lt;*ASSERT FALSE*&gt;(* can't happen *)
        | IntCode.Add =&gt;
            RETURN NEW(ObValue.ValInt, int := int1 + int2, temp := temp);
        | IntCode.Sub =&gt;
            RETURN NEW(ObValue.ValInt, int := int1 - int2, temp := temp);
        | IntCode.Mult =&gt;
            RETURN NEW(ObValue.ValInt, int := int1 * int2, temp := temp);
        | IntCode.Div =&gt;
            IF int2 = 0 THEN
              ObValue.BadArgVal(2, &quot;non-zero&quot;, self.name, opCode.name, loc);
              &lt;*ASSERT FALSE*&gt;
            ELSE
              RETURN
                NEW(ObValue.ValInt, int := int1 DIV int2, temp := temp);
            END;
        | IntCode.Mod =&gt;
            IF int2 = 0 THEN
              ObValue.BadArgVal(2, &quot;non-zero&quot;, self.name, opCode.name, loc);
              &lt;*ASSERT FALSE*&gt;
            ELSE
              IF intVal1.temp THEN
                intRes := intVal1;
              ELSIF intVal2.temp THEN
                intRes := intVal2;
              ELSE
                intRes := NEW(ObValue.ValInt);
              END;
              intRes.temp := temp;
              intRes.int := int1 MOD int2;
              RETURN intRes;
            END;
        | IntCode.Less =&gt; RETURN NEW(ObValue.ValBool, bool := int1 &lt; int2);
        | IntCode.More =&gt; RETURN NEW(ObValue.ValBool, bool := int1 &gt; int2);
        | IntCode.LessEq =&gt;
            RETURN NEW(ObValue.ValBool, bool := int1 &lt;= int2);
        | IntCode.MoreEq =&gt;
            RETURN NEW(ObValue.ValBool, bool := int1 &gt;= int2);
        END;
    ELSE
      ObValue.BadOp(self.name, opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END EvalInt;
</PRE> ============ <CODE>real</CODE> package ============ 

<P><PRE>TYPE

  RealCode = {Minus, Add, Sub, Mult, Div, Less, More, LessEq, MoreEq,
              Round, Float, Floor, Ceiling};

  RealOpCode = ObLib.OpCode OBJECT code: RealCode;  END;

  PackageReal = ObLib.T OBJECT OVERRIDES Eval := EvalReal; END;

PROCEDURE <A NAME="NewRealOC"><procedure>NewRealOC</procedure></A> (name  : TEXT;
                     arity : INTEGER;
                     code  : RealCode;
                     fixity: ObLib.OpFixity := ObLib.OpFixity.Qualified):
  RealOpCode =
  BEGIN
    RETURN NEW(RealOpCode, name := name, arity := arity, code := code,
               fixity := fixity);
  END NewRealOC;

PROCEDURE <A NAME="SetupReal"><procedure>SetupReal</procedure></A> () =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(RealCode));
    opCodes^ :=
      OpCodes{NewRealOC(&quot;minus&quot;, 1, RealCode.Minus),
              NewRealOC(&quot;+&quot;, 2, RealCode.Add, ObLib.OpFixity.Infix),
              NewRealOC(&quot;-&quot;, 2, RealCode.Sub, ObLib.OpFixity.Infix),
              NewRealOC(&quot;*&quot;, 2, RealCode.Mult, ObLib.OpFixity.Infix),
              NewRealOC(&quot;/&quot;, 2, RealCode.Div, ObLib.OpFixity.Infix),
              NewRealOC(&quot;&lt;&quot;, 2, RealCode.Less, ObLib.OpFixity.Infix),
              NewRealOC(&quot;&gt;&quot;, 2, RealCode.More, ObLib.OpFixity.Infix),
              NewRealOC(&quot;&lt;=&quot;, 2, RealCode.LessEq, ObLib.OpFixity.Infix),
              NewRealOC(&quot;&gt;=&quot;, 2, RealCode.MoreEq, ObLib.OpFixity.Infix),
              NewRealOC(&quot;round&quot;, 1, RealCode.Round, ObLib.OpFixity.Prefix),
              NewRealOC(&quot;float&quot;, 1, RealCode.Float, ObLib.OpFixity.Prefix),
              NewRealOC(&quot;floor&quot;, 1, RealCode.Floor),
              NewRealOC(&quot;ceiling&quot;, 1, RealCode.Ceiling)};
    ObLib.Register(NEW(PackageReal, name := &quot;real&quot;, opCodes := opCodes));
  END SetupReal;

PROCEDURE <A NAME="EvalReal"><procedure>EvalReal</procedure></A> (                    self  : PackageReal;
                                        opCode: ObLib.OpCode;
                    &lt;*UNUSED*&gt;          arity : ObLib.OpArity;
                               READONLY args  : ObValue.ArgArray;
                                        temp  : BOOLEAN;
                                        loc   : SynLocation.T     ):
  ObValue.Val RAISES {ObValue.Error} =
  VAR
    realRes, realVal1, realVal2: ObValue.ValReal;
    real1, real2               : LONGREAL;
    intRes, intVal1, intVal2   : ObValue.ValInt;
    int1, int2                 : INTEGER;
    realCode                   : RealCode;
    isReal1, isReal2           : BOOLEAN;
  BEGIN
    realCode := NARROW(opCode, RealOpCode).code;
    TYPECASE args[1] OF
    | ObValue.ValReal (node) =&gt;
        realVal1 := node;
        real1 := node.real;
        isReal1 := TRUE;
    | ObValue.ValInt (node) =&gt;
        intVal1 := node;
        int1 := node.int;
        isReal1 := FALSE;
    ELSE
      ObValue.BadArgType(1, &quot;real or int&quot;, self.name, opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
    CASE realCode OF
    | RealCode.Minus =&gt;
        IF isReal1 THEN
          IF realVal1.temp THEN
            realRes := realVal1;
          ELSE
            realRes := NEW(ObValue.ValReal);
          END;
          realRes.temp := temp;
          realRes.real := -real1;
          RETURN realRes;
        ELSE
          IF intVal1.temp THEN
            intRes := intVal1;
          ELSE
            intRes := NEW(ObValue.ValInt);
          END;
          intRes.temp := temp;
          intRes.int := -int1;
          RETURN intRes;
        END;
    | RealCode.Float =&gt;
        IF isReal1 THEN
          IF realVal1.temp THEN realVal1.temp := temp; END;
          RETURN realVal1;
        ELSE
          RETURN NEW(ObValue.ValReal, real := FLOAT(int1, LONGREAL),
                     temp := temp);
        END;
    | RealCode.Round =&gt;
        IF isReal1 THEN
          RETURN NEW(ObValue.ValInt, int := ROUND(real1), temp := temp);
        ELSE
          IF intVal1.temp THEN intVal1.temp := temp END;
          RETURN intVal1;
        END;
    | RealCode.Floor =&gt;
        IF isReal1 THEN
          RETURN NEW(ObValue.ValInt, int := FLOOR(real1), temp := temp);
        ELSE
          IF intVal1.temp THEN intVal1.temp := temp END;
          RETURN intVal1;
        END;
    | RealCode.Ceiling =&gt;
        IF isReal1 THEN
          RETURN NEW(ObValue.ValInt, int := CEILING(real1), temp := temp);
        ELSE
          IF intVal1.temp THEN intVal1.temp := temp END;
          RETURN intVal1;
        END;
    | RealCode.Add, RealCode.Sub, RealCode.Mult, RealCode.Div =&gt;
        TYPECASE args[2] OF
        | ObValue.ValReal (node) =&gt;
            realVal2 := node;
            real2 := node.real;
            isReal2 := TRUE;
        | ObValue.ValInt (node) =&gt;
            intVal2 := node;
            int2 := node.int;
            isReal2 := FALSE;
        ELSE
          ObValue.BadArgType(2, &quot;real or int&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        IF isReal1 # isReal2 THEN
          IF isReal1 THEN
            ObValue.BadArgType(
              2, &quot;real (like argument 1)&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          ELSE
            ObValue.BadArgType(
              2, &quot;int (like argument 1)&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
        END;
        IF isReal1 THEN
          IF realVal1.temp THEN
            realRes := realVal1;
          ELSIF realVal2.temp THEN
            realRes := realVal2;
          ELSE
            realRes := NEW(ObValue.ValReal);
          END;
          realRes.temp := temp;
        ELSE
          IF intVal1.temp THEN
            intRes := intVal1;
          ELSIF intVal2.temp THEN
            intRes := intVal2;
          ELSE
            intRes := NEW(ObValue.ValInt);
          END;
          intRes.temp := temp;
        END;
        CASE realCode OF
        | RealCode.Add =&gt;
            IF isReal1 THEN
              realRes.real := real1 + real2;
              RETURN realRes;
            ELSE
              intRes.int := int1 + int2;
              RETURN intRes;
            END;
        | RealCode.Sub =&gt;
            IF isReal1 THEN
              realRes.real := real1 - real2;
              RETURN realRes;
            ELSE
              intRes.int := int1 - int2;
              RETURN intRes;
            END;
        | RealCode.Mult =&gt;
            IF isReal1 THEN
              realRes.real := real1 * real2;
              RETURN realRes;
            ELSE
              intRes.int := int1 * int2;
              RETURN intRes;
            END;
        | RealCode.Div =&gt;
            IF isReal1 THEN
              IF real2 = 0.0d0 THEN
                ObValue.BadArgVal(
                  2, &quot;a non-zero real&quot;, self.name, opCode.name, loc);
                &lt;*ASSERT FALSE*&gt;
              ELSE
                realRes.real := real1 / real2;
                RETURN realRes;
              END;
            ELSE
              IF int2 = 0 THEN
                ObValue.BadArgVal(
                  2, &quot;a non-zero int&quot;, self.name, opCode.name, loc);
                &lt;*ASSERT FALSE*&gt;
              ELSE
                intRes.int := int1 DIV int2;
                RETURN intRes;
              END;
            END;
        ELSE                     &lt;*ASSERT FALSE*&gt;
        END;
    | RealCode.Less, RealCode.More, RealCode.LessEq, RealCode.MoreEq =&gt;
        TYPECASE args[2] OF
        | ObValue.ValReal (node) =&gt; real2 := node.real; isReal2 := TRUE;
        | ObValue.ValInt (node) =&gt; int2 := node.int; isReal2 := FALSE;
        ELSE
          ObValue.BadArgType(2, &quot;real or int&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        IF isReal1 # isReal2 THEN
          IF isReal1 THEN
            ObValue.BadArgType(
              2, &quot;real (like argument 1)&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          ELSE
            ObValue.BadArgType(
              2, &quot;int (like argument 1)&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
        END;
        CASE realCode OF
        | RealCode.Less =&gt;
            IF isReal1 THEN
              IF real1 &lt; real2 THEN RETURN true ELSE RETURN false END
            ELSE
              IF int1 &lt; int2 THEN RETURN true ELSE RETURN false END
            END;
        | RealCode.More =&gt;
            IF isReal1 THEN
              IF real1 &gt; real2 THEN RETURN true ELSE RETURN false END
            ELSE
              IF int1 &gt; int2 THEN RETURN true ELSE RETURN false END
            END;
        | RealCode.LessEq =&gt;
            IF isReal1 THEN
              IF real1 &lt;= real2 THEN RETURN true ELSE RETURN false END
            ELSE
              IF int1 &lt;= int2 THEN RETURN true ELSE RETURN false END
            END;
        | RealCode.MoreEq =&gt;
            IF isReal1 THEN
              IF real1 &gt;= real2 THEN RETURN true ELSE RETURN false END
            ELSE
              IF int1 &gt;= int2 THEN RETURN true ELSE RETURN false END
            END;
        ELSE                     &lt;*ASSERT FALSE*&gt;
        END;
    ELSE
      ObValue.BadOp(self.name, opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END EvalReal;
</PRE> ============ <CODE>math</CODE> package ============ 

<P><PRE>TYPE

  MathCode = {Pi, E, Degree, Exp, Log, Sqrt, Pow, Cos, Sin, Tan, Acos,
              Asin, Atan, Atan2, Hypot};

  MathOpCode = ObLib.OpCode OBJECT code: MathCode;  END;

  PackageMath = ObLib.T OBJECT OVERRIDES Eval := EvalMath; END;

VAR MathPi, MathE, MathDegree: ObValue.Val;

PROCEDURE <A NAME="NewMathOC"><procedure>NewMathOC</procedure></A> (name: TEXT; arity: INTEGER; code: MathCode):
  MathOpCode =
  BEGIN
    RETURN NEW(MathOpCode, name := name, arity := arity, code := code);
  END NewMathOC;

PROCEDURE <A NAME="SetupMath"><procedure>SetupMath</procedure></A> () =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(MathCode));
    opCodes^ := OpCodes{NewMathOC(&quot;pi&quot;, -1, MathCode.Pi),
                        NewMathOC(&quot;e&quot;, -1, MathCode.E),
                        NewMathOC(&quot;degree&quot;, -1, MathCode.Degree),
                        NewMathOC(&quot;exp&quot;, 1, MathCode.Exp),
                        NewMathOC(&quot;log&quot;, 1, MathCode.Log),
                        NewMathOC(&quot;sqrt&quot;, 1, MathCode.Sqrt),
                        NewMathOC(&quot;pow&quot;, 2, MathCode.Pow),
                        NewMathOC(&quot;cos&quot;, 1, MathCode.Cos),
                        NewMathOC(&quot;sin&quot;, 1, MathCode.Sin),
                        NewMathOC(&quot;tan&quot;, 1, MathCode.Tan),
                        NewMathOC(&quot;acos&quot;, 1, MathCode.Acos),
                        NewMathOC(&quot;asin&quot;, 1, MathCode.Asin),
                        NewMathOC(&quot;atan&quot;, 1, MathCode.Atan),
                        NewMathOC(&quot;atan2&quot;, 2, MathCode.Atan2),
                        NewMathOC(&quot;hypot&quot;, 2, MathCode.Hypot)};
    ObLib.Register(NEW(PackageMath, name := &quot;math&quot;, opCodes := opCodes));
    MathPi := NEW(ObValue.ValReal, real := FLOAT(Math.Pi, LONGREAL),
                  temp := FALSE);
    MathE :=
      NEW(ObValue.ValReal, real := FLOAT(Math.E, LONGREAL), temp := FALSE);
    MathDegree := NEW(ObValue.ValReal,
                      real := FLOAT(Math.Degree, LONGREAL), temp := FALSE);
  END SetupMath;

PROCEDURE <A NAME="EvalMath"><procedure>EvalMath</procedure></A> (                    self  : PackageMath;
                                        opCode: ObLib.OpCode;
                    &lt;*UNUSED*&gt;          arity : ObLib.OpArity;
                               READONLY args  : ObValue.ArgArray;
                                        temp  : BOOLEAN;
                                        loc   : SynLocation.T     ):
  ObValue.Val RAISES {ObValue.Error} =
  VAR
    real1, real2               : LONGREAL;
    realRes, realVal1, realVal2: ObValue.ValReal;
  BEGIN
    CASE NARROW(opCode, MathOpCode).code OF
    | MathCode.Pi =&gt; RETURN MathPi;
    | MathCode.E =&gt; RETURN MathE;
    | MathCode.Degree =&gt; RETURN MathDegree;
    | MathCode.Exp =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt;
            IF node.temp THEN
              realRes := node;
            ELSE
              realRes := NEW(ObValue.ValReal);
            END;
            realRes.temp := temp;
            real1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        realRes.real := Math.exp(real1);
        RETURN realRes;
    | MathCode.Log =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt;
            IF node.temp THEN
              realRes := node;
            ELSE
              realRes := NEW(ObValue.ValReal);
            END;
            realRes.temp := temp;
            real1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        realRes.real := Math.log(real1);
        RETURN realRes;
    | MathCode.Sqrt =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt;
            IF node.temp THEN
              realRes := node;
            ELSE
              realRes := NEW(ObValue.ValReal);
            END;
            realRes.temp := temp;
            real1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        realRes.real := Math.sqrt(real1);
        RETURN realRes;
    | MathCode.Pow =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt; realVal1 := node; real1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        TYPECASE args[2] OF
        | ObValue.ValReal (node) =&gt; realVal2 := node; real2 := node.real;
        ELSE
          ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        IF realVal1.temp THEN
          realRes := realVal1;
        ELSIF realVal2.temp THEN
          realRes := realVal2;
        ELSE
          realRes := NEW(ObValue.ValReal);
        END;
        realRes.temp := temp;
        realRes.real := Math.pow(real1, real2);
        RETURN realRes;
    | MathCode.Cos =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt;
            IF node.temp THEN
              realRes := node;
            ELSE
              realRes := NEW(ObValue.ValReal);
            END;
            realRes.temp := temp;
            real1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        realRes.real := Math.cos(real1);
        RETURN realRes;
    | MathCode.Sin =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt;
            IF node.temp THEN
              realRes := node;
            ELSE
              realRes := NEW(ObValue.ValReal);
            END;
            realRes.temp := temp;
            real1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        realRes.real := Math.sin(real1);
        RETURN realRes;
    | MathCode.Tan =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt;
            IF node.temp THEN
              realRes := node;
            ELSE
              realRes := NEW(ObValue.ValReal);
            END;
            realRes.temp := temp;
            real1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        realRes.real := Math.tan(real1);
        RETURN realRes;
    | MathCode.Acos =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt;
            IF node.temp THEN
              realRes := node;
            ELSE
              realRes := NEW(ObValue.ValReal);
            END;
            realRes.temp := temp;
            real1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        realRes.real := Math.acos(real1);
        RETURN realRes;
    | MathCode.Asin =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt;
            IF node.temp THEN
              realRes := node;
            ELSE
              realRes := NEW(ObValue.ValReal);
            END;
            realRes.temp := temp;
            real1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        realRes.real := Math.asin(real1);
        RETURN realRes;
    | MathCode.Atan =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt;
            IF node.temp THEN
              realRes := node;
            ELSE
              realRes := NEW(ObValue.ValReal);
            END;
            realRes.temp := temp;
            real1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        realRes.real := Math.atan(real1);
        RETURN realRes;
    | MathCode.Atan2 =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt; realVal1 := node; real1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        TYPECASE args[2] OF
        | ObValue.ValReal (node) =&gt; realVal2 := node; real2 := node.real;
        ELSE
          ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        IF realVal1.temp THEN
          realRes := realVal1;
        ELSIF realVal2.temp THEN
          realRes := realVal2;
        ELSE
          realRes := NEW(ObValue.ValReal);
        END;
        realRes.temp := temp;
        realRes.real := Math.atan2(real1, real2);
        RETURN realRes;
    | MathCode.Hypot =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt; realVal1 := node; real1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        TYPECASE args[2] OF
        | ObValue.ValReal (node) =&gt; realVal2 := node; real2 := node.real;
        ELSE
          ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc);
        END;
        IF realVal1.temp THEN
          realRes := realVal1;
        ELSIF realVal2.temp THEN
          realRes := realVal2;
        ELSE
          realRes := NEW(ObValue.ValReal);
        END;
        realRes.temp := temp;
        realRes.real := Math.hypot(real1, real2);
        RETURN realRes;
    ELSE
      ObValue.BadOp(self.name, opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END EvalMath;
</PRE> ============ <CODE>ascii</CODE> package ============ 

<P><PRE>TYPE

  AsciiCode = {Char, Val};

  AsciiOpCode = ObLib.OpCode OBJECT code: AsciiCode;  END;

  PackageAscii = ObLib.T OBJECT OVERRIDES Eval := EvalAscii; END;

PROCEDURE <A NAME="NewAsciiOC"><procedure>NewAsciiOC</procedure></A> (name: TEXT; arity: INTEGER; code: AsciiCode):
  AsciiOpCode =
  BEGIN
    RETURN NEW(AsciiOpCode, name := name, arity := arity, code := code);
  END NewAsciiOC;

PROCEDURE <A NAME="SetupAscii"><procedure>SetupAscii</procedure></A> () =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(AsciiCode));
    opCodes^ := OpCodes{NewAsciiOC(&quot;char&quot;, 1, AsciiCode.Char),
                        NewAsciiOC(&quot;val&quot;, 1, AsciiCode.Val)};
    ObLib.Register(NEW(PackageAscii, name := &quot;ascii&quot;, opCodes := opCodes));
  END SetupAscii;

PROCEDURE <A NAME="EvalAscii"><procedure>EvalAscii</procedure></A> (                    self  : PackageAscii;
                                         opCode: ObLib.OpCode;
                     &lt;*UNUSED*&gt;          arity : ObLib.OpArity;
                                READONLY args  : ObValue.ArgArray;
                                         temp  : BOOLEAN;
                                         loc   : SynLocation.T     ):
  ObValue.Val RAISES {ObValue.Error} =
  VAR
    int1 : INTEGER;
    char1: CHAR;
  BEGIN
    CASE NARROW(opCode, AsciiOpCode).code OF
    | AsciiCode.Char =&gt;
        TYPECASE args[1] OF
        | ObValue.ValInt (node) =&gt; int1 := node.int;
        ELSE
          ObValue.BadArgType(1, &quot;int&quot;, self.name, opCode.name, loc);
        END;
        IF (int1 &lt; 0) OR (int1 &gt; 255) THEN
          ObValue.BadArgVal(1, &quot;0..255&quot;, self.name, opCode.name, loc);
        END;
        RETURN NEW(ObValue.ValChar, char := VAL(int1, CHAR));
    | AsciiCode.Val =&gt;
        TYPECASE args[1] OF
        | ObValue.ValChar (node) =&gt; char1 := node.char;
        ELSE
          ObValue.BadArgType(1, &quot;char&quot;, self.name, opCode.name, loc);
        END;
        RETURN NEW(ObValue.ValInt, int := ORD(char1), temp := temp);
    ELSE
      ObValue.BadOp(self.name, opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END EvalAscii;
</PRE> ============ <CODE>text</CODE> package ============ 

<P><PRE>TYPE

  TextCode =
    {New, Empty, Length, Equal, Char, Sub, Cat, Precedes, Encode, Decode,
     Implode, Explode, Hash, ToInt, FromInt, FindFirstChar, FindLastChar,
     FindFirst, FindLast, ReplaceAll};

  TextOpCode = ObLib.OpCode OBJECT code: TextCode;  END;

  PackageText = ObLib.T OBJECT OVERRIDES Eval := EvalText; END;

PROCEDURE <A NAME="NewTextOC"><procedure>NewTextOC</procedure></A> (name  : TEXT;
                     arity : INTEGER;
                     code  : TextCode;
                     fixity: ObLib.OpFixity := ObLib.OpFixity.Qualified):
  TextOpCode =
  BEGIN
    RETURN NEW(TextOpCode, name := name, arity := arity, code := code,
               fixity := fixity);
  END NewTextOC;

PROCEDURE <A NAME="SetupText"><procedure>SetupText</procedure></A> () =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(TextCode));
    opCodes^ :=
      OpCodes{NewTextOC(&quot;new&quot;, 2, TextCode.New),
              NewTextOC(&quot;empty&quot;, 1, TextCode.Empty),
              NewTextOC(&quot;length&quot;, 1, TextCode.Length),
              NewTextOC(&quot;equal&quot;, 2, TextCode.Equal),
              NewTextOC(&quot;char&quot;, 2, TextCode.Char),
              NewTextOC(&quot;sub&quot;, 3, TextCode.Sub),
              NewTextOC(&quot;&amp;&quot;, 2, TextCode.Cat, ObLib.OpFixity.Infix),
              NewTextOC(&quot;precedes&quot;, 2, TextCode.Precedes),
              NewTextOC(&quot;encode&quot;, 1, TextCode.Encode),
              NewTextOC(&quot;decode&quot;, 1, TextCode.Decode),
              NewTextOC(&quot;implode&quot;, 2, TextCode.Implode),
              NewTextOC(&quot;explode&quot;, 2, TextCode.Explode),
              NewTextOC(&quot;hash&quot;, 1, TextCode.Hash),
              NewTextOC(&quot;toInt&quot;, 1, TextCode.ToInt),
              NewTextOC(&quot;fromInt&quot;, 1, TextCode.FromInt),
              NewTextOC(&quot;findFirstChar&quot;, 3, TextCode.FindFirstChar),
              NewTextOC(&quot;findLastChar&quot;, 3, TextCode.FindLastChar),
              NewTextOC(&quot;findFirst&quot;, 3, TextCode.FindFirst),
              NewTextOC(&quot;findLast&quot;, 3, TextCode.FindLast),
              NewTextOC(&quot;replaceAll&quot;, 3, TextCode.ReplaceAll)};
    ObLib.Register(NEW(PackageText, name := &quot;text&quot;, opCodes := opCodes));
  END SetupText;

PROCEDURE <A NAME="EvalText"><procedure>EvalText</procedure></A> (                    self  : PackageText;
                                        opCode: ObLib.OpCode;
                    &lt;*UNUSED*&gt;          arity : ObLib.OpArity;
                               READONLY args  : ObValue.ArgArray;
                                        temp  : BOOLEAN;
                                        loc   : SynLocation.T     ):
  ObValue.Val RAISES {ObValue.Error, ObValue.Exception} =
  TYPE Chars = REF ARRAY OF CHAR;
  TYPE Texts = REF ARRAY OF TEXT;
  TYPE Vals = REF ARRAY OF ObValue.Val;
  VAR
    text1, text2, text3: TEXT;
    int1, int2, len    : INTEGER;
    char1              : CHAR;
    chars              : Chars;
    val                : ObValue.Val;
    texts              : Texts;
    array1             : Vals;
    chSet              : SET OF CHAR;
  BEGIN
    TRY
      CASE NARROW(opCode, TextOpCode).code OF
      | TextCode.New =&gt;
          TYPECASE args[1] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(1, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValChar (node) =&gt; char1 := node.char;
          ELSE
            ObValue.BadArgType(2, &quot;char&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          IF int1 &lt; 0 THEN
            ObValue.BadArgVal(
              1, &quot;non-negative&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          chars := NEW(Chars, int1);
          FOR i := 0 TO int1 - 1 DO chars^[i] := char1; END;
          RETURN ObValue.NewText(Text.FromChars(chars^));
      | TextCode.Empty =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          IF Text.Empty(text1) THEN RETURN true ELSE RETURN false END;
      | TextCode.Length =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          RETURN
            NEW(ObValue.ValInt, int := Text.Length(text1), temp := temp);
      | TextCode.Equal =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValText (node) =&gt; text2 := node.text;
          ELSE
            ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          IF Text.Equal(text1, text2) THEN
            RETURN true
          ELSE
            RETURN false
          END;
      | TextCode.Char =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          IF (int1 &lt; 0) OR (int1 &gt;= Text.Length(text1)) THEN
            ObValue.BadArgVal(2, &quot;in range&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          RETURN NEW(ObValue.ValChar, char := Text.GetChar(text1, int1));
      | TextCode.Sub =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValInt (node) =&gt; int2 := node.int;
          ELSE
            ObValue.BadArgType(3, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          len := Text.Length(text1);
          IF (int1 &lt; 0) OR (int1 &gt; len) THEN
            ObValue.BadArgVal(2, &quot;in range&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          IF (int2 &lt; 0) OR (int1 + int2 &gt; len) THEN
            ObValue.BadArgVal(3, &quot;in range&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          RETURN ObValue.NewText(Text.Sub(text1, int1, int2));
      | TextCode.Cat =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValText (node) =&gt; text2 := node.text;
          ELSE
            ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          RETURN ObValue.NewText(Text.Cat(text1, text2));
      | TextCode.Precedes =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValText (node) =&gt; text2 := node.text;
          ELSE
            ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          IF Text.Compare(text1, text2) &lt; 0 THEN
            RETURN true;
          ELSE
            RETURN false;
          END;
      | TextCode.Encode =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          RETURN ObValue.NewText(TextConv.Encode(text1, FALSE));
      | TextCode.Decode =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TRY
            val := ObValue.NewText(TextConv.Decode(text1, FALSE));
          EXCEPT
            TextConv.Fail =&gt;
              ObValue.BadArgVal(1, &quot;a well-formed encoded text&quot;, self.name,
                                opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          RETURN val;
      | TextCode.Implode =&gt;
          TYPECASE args[1] OF
          | ObValue.ValChar (node) =&gt; char1 := node.char;
          ELSE
            ObValue.BadArgType(1, &quot;char&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValArray (node) =&gt; array1 := node.remote.Obtain();
          ELSE
            ObValue.BadArgType(2, &quot;array&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          texts := NEW(Texts, NUMBER(array1^));
          FOR i := 0 TO NUMBER(texts^) - 1 DO
            TYPECASE array1^[i] OF
            | ObValue.ValText (node) =&gt; texts^[i] := node.text;
            ELSE
              ObValue.BadArgType(
                1, &quot;array(text)&quot;, self.name, opCode.name, loc);
              &lt;*ASSERT FALSE*&gt;
            END;
          END;
          RETURN ObValue.NewText(TextConv.Implode(texts^, char1));
      | TextCode.Explode =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text2 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          chSet := CharSet(text2);
          texts := NEW(Texts, TextConv.ExplodedSize(text1, chSet));
          TextConv.Explode(text1, texts^, chSet);
          array1 := NEW(Vals, NUMBER(texts^));
          FOR i := 0 TO NUMBER(array1^) - 1 DO
            array1[i] := ObValue.NewText(texts[i]);
          END;
          RETURN ObValue.NewArrayFromVals(array1);
      | TextCode.Hash =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          RETURN
            NEW(ObValue.ValInt, int := Text.Hash(text1), temp := temp);
      | TextCode.ToInt =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TRY
            RETURN NEW(ObValue.ValInt, int := Lex.Int(TextRd.New(text1)),
                       temp := temp);
          EXCEPT
            Lex.Error, Rd.Failure, FloatMode.Trap =&gt;
              ObValue.BadArgVal(
                1, &quot;a well-formed int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
      | TextCode.FromInt =&gt;
          TYPECASE args[1] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(1, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          RETURN ObValue.NewText(Fmt.Int(int1));
      | TextCode.FindFirstChar =&gt;
          TYPECASE args[1] OF
          | ObValue.ValChar (node) =&gt; char1 := node.char;
          ELSE
            ObValue.BadArgType(1, &quot;char&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(3, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          RETURN
            NEW(ObValue.ValInt, int := Text.FindChar(text1, char1, int1),
                temp := temp);
      | TextCode.FindLastChar =&gt;
          TYPECASE args[1] OF
          | ObValue.ValChar (node) =&gt; char1 := node.char;
          ELSE
            ObValue.BadArgType(1, &quot;char&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(3, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          RETURN
            NEW(ObValue.ValInt, int := Text.FindCharR(text1, char1, int1),
                temp := temp);
      | TextCode.FindFirst =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValText (node) =&gt; text2 := node.text;
          ELSE
            ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(3, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          RETURN NEW(ObValue.ValInt, int := FindFirst(text2, int1, text1),
                     temp := temp);
      | TextCode.FindLast =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValText (node) =&gt; text2 := node.text;
          ELSE
            ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(3, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          RETURN NEW(ObValue.ValInt, int := FindLast(text2, int1, text1),
                     temp := temp);
      | TextCode.ReplaceAll =&gt;
          TYPECASE args[1] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValText (node) =&gt; text2 := node.text;
          ELSE
            ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValText (node) =&gt; text3 := node.text;
          ELSE
            ObValue.BadArgType(3, &quot;text&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          RETURN ObValue.NewText(ReplaceAll(text3, text1, text2));
      ELSE
        ObValue.BadOp(self.name, opCode.name, loc);
        &lt;*ASSERT FALSE*&gt;
      END;
    EXCEPT
    | NetObj.Error (atoms) =&gt;
        ObValue.RaiseNetException(
          self.name &amp; &quot;_&quot; &amp; opCode.name, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, self.name &amp; &quot;_&quot; &amp; opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END EvalText;

PROCEDURE <A NAME="CharSet"><procedure>CharSet</procedure></A> (text: TEXT): SET OF CHAR =
  VAR s: SET OF CHAR;
  BEGIN
    s := SET OF CHAR{};
    FOR i := 0 TO Text.Length(text) - 1 DO
      s := s + SET OF CHAR{Text.GetChar(text, i)};
    END;
    RETURN s;
  END CharSet;

PROCEDURE <A NAME="FindFirst"><procedure>FindFirst</procedure></A> (source: TEXT; start: INTEGER; pattern: TEXT):
  INTEGER =
  VAR
    i, ii, j, srcLimit, patLimit: INTEGER;
    patFirst                    : CHAR;
  BEGIN
    srcLimit := Text.Length(source) - start;
    patLimit := Text.Length(pattern);
    IF patLimit = 0 THEN RETURN 0 END;
    patFirst := Text.GetChar(pattern, 0);
    i := start;
    LOOP
      IF i &gt;= srcLimit THEN RETURN -1 END;
      IF Text.GetChar(source, i) = patFirst THEN
        ii := i;
        j := 0;
        LOOP
          INC(j);
          IF j &gt;= patLimit THEN RETURN i END;
          INC(ii);
          IF ii &gt;= srcLimit THEN EXIT END;
          IF Text.GetChar(source, ii) # Text.GetChar(pattern, j) THEN
            EXIT
          END;
        END;
      END;
      INC(i);
    END;
  END FindFirst;

PROCEDURE <A NAME="FindLast"><procedure>FindLast</procedure></A> (source: TEXT; start: INTEGER; pattern: TEXT): INTEGER =
  VAR
    i, ii, j, patLength: INTEGER;
    patLast            : CHAR;
  BEGIN
    patLength := Text.Length(pattern);
    IF patLength = 0 THEN RETURN i END;
    patLast := Text.GetChar(pattern, patLength - 1);
    i := MIN(Text.Length(source), start);
    LOOP
      DEC(i);
      IF i &lt; 0 THEN RETURN -1 END;
      IF Text.GetChar(source, i) = patLast THEN
        ii := i;
        j := patLength - 1;
        LOOP
          DEC(j);
          IF j &lt; 0 THEN RETURN ii END;
          DEC(ii);
          IF ii &lt; 0 THEN EXIT END;
          IF Text.GetChar(source, ii) # Text.GetChar(pattern, j) THEN
            EXIT
          END;
        END;
      END;
    END;
  END FindLast;

PROCEDURE <A NAME="ReplaceAll"><procedure>ReplaceAll</procedure></A> (source: TEXT; pattern: TEXT; repl: TEXT): TEXT =
  VAR
    i, ii, j, k, srcLimit, patLimit, replLength, count: INTEGER;
    patFirst, ch                                      : CHAR;
    res                                               : REF ARRAY OF CHAR;
  BEGIN
    srcLimit := Text.Length(source);
    patLimit := Text.Length(pattern);
    IF patLimit = 0 THEN RETURN source END;
    patFirst := Text.GetChar(pattern, 0);
    count := 0;
    i := 0;
    LOOP
      IF i &gt;= srcLimit THEN EXIT END;
      IF Text.GetChar(source, i) = patFirst THEN
        ii := i;
        j := 0;
        LOOP
          INC(j);
          IF j &gt;= patLimit THEN INC(count); INC(i, patLimit); EXIT; END;
          INC(ii);
          IF (ii &gt;= srcLimit)
               OR (Text.GetChar(source, ii) # Text.GetChar(pattern, j)) THEN
            INC(i);
            EXIT;
          END;
        END;
      ELSE
        INC(i);
      END;
    END;
    replLength := Text.Length(repl);
    res := NEW(REF ARRAY OF CHAR,
               (srcLimit - (count * patLimit)) + (count * replLength));
    i := 0;
    k := 0;
    LOOP
      IF i &gt;= srcLimit THEN EXIT END;
      ch := Text.GetChar(source, i);
      IF ch = patFirst THEN
        ii := i;
        j := 0;
        LOOP
          INC(j);
          IF j &gt;= patLimit THEN
            Text.SetChars(SUBARRAY(res^, k, replLength), repl);
            INC(k, replLength);
            INC(i, patLimit);
            EXIT;
          END;
          INC(ii);
          IF (ii &gt;= srcLimit)
               OR (Text.GetChar(source, ii) # Text.GetChar(pattern, j)) THEN
            res^[k] := ch;
            INC(k);
            INC(i);
            EXIT;
          END;
        END;
      ELSE
        res^[k] := ch;
        INC(k);
        INC(i);
      END;
    END;
    RETURN Text.FromChars(res^);
  END ReplaceAll;
</PRE> ============ <CODE>array</CODE> package ============ 

<P><PRE>TYPE

  ArrayCode = {New, Gen, Size, Get, Set, Sub, Upd, Cat};

  ArrayOpCode = ObLib.OpCode OBJECT code: ArrayCode;  END;

  PackageArray = ObLib.T OBJECT OVERRIDES Eval := EvalArray; END;

PROCEDURE <A NAME="NewArrayOC"><procedure>NewArrayOC</procedure></A> (name  : TEXT;
                      arity : INTEGER;
                      code  : ArrayCode;
                      fixity: ObLib.OpFixity := ObLib.OpFixity.Qualified):
  ArrayOpCode =
  BEGIN
    RETURN NEW(ArrayOpCode, name := name, arity := arity, code := code,
               fixity := fixity);
  END NewArrayOC;

PROCEDURE <A NAME="SetupArray"><procedure>SetupArray</procedure></A> () =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(ArrayCode));
    opCodes^ :=
      OpCodes{NewArrayOC(&quot;new&quot;, 2, ArrayCode.New),
              NewArrayOC(&quot;gen&quot;, 2, ArrayCode.Gen),
              NewArrayOC(&quot;#&quot;, 1, ArrayCode.Size, ObLib.OpFixity.Prefix),
              NewArrayOC(&quot;get&quot;, 2, ArrayCode.Get),
              NewArrayOC(&quot;set&quot;, 3, ArrayCode.Set),
              NewArrayOC(&quot;sub&quot;, 3, ArrayCode.Sub),
              NewArrayOC(&quot;upd&quot;, 4, ArrayCode.Upd),
              NewArrayOC(&quot;@&quot;, 2, ArrayCode.Cat, ObLib.OpFixity.Infix)};
    ObLib.Register(NEW(PackageArray, name := &quot;array&quot;, opCodes := opCodes));
  END SetupArray;

PROCEDURE <A NAME="EvalArray"><procedure>EvalArray</procedure></A> (                    self  : PackageArray;
                                         opCode: ObLib.OpCode;
                     &lt;*UNUSED*&gt;          arity : ObLib.OpArity;
                                READONLY args  : ObValue.ArgArray;
                                         temp  : BOOLEAN;
                                         loc   : SynLocation.T     ):
  ObValue.Val RAISES {ObValue.Error, ObValue.Exception} =
  TYPE Vals = REF ARRAY OF ObValue.Val;
  VAR
    int1, int2          : INTEGER;
    vals, array1, array2: Vals;
    rem1                : ObValue.RemArray;
    badOp               : INTEGER          := 0;
    clos1               : ObValue.ValFun;
  BEGIN
    TRY
      CASE NARROW(opCode, ArrayOpCode).code OF
      | ArrayCode.New =&gt;
          TYPECASE args[1] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(1, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          IF int1 &lt; 0 THEN
            ObValue.BadArgVal(
              1, &quot;non-negative&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          vals := NEW(Vals, int1);
          FOR i := 0 TO int1 - 1 DO vals^[i] := args[2]; END;
          RETURN ObValue.NewArrayFromVals(vals);
      | ArrayCode.Gen =&gt;
          TYPECASE args[1] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(1, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValFun (node) =&gt; clos1 := node;
          ELSE
            ObValue.BadArgType(1, &quot;procedure&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          IF int1 &lt; 0 THEN
            ObValue.BadArgVal(
              1, &quot;non-negative&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          vals := NEW(Vals, int1);
          FOR i := 0 TO int1 - 1 DO
            vals^[i] :=
              ObEval.Call(clos1, ObValue.Vals{NEW(ObValue.ValInt, int := i,
                                                  temp := FALSE)}, loc);
          END;
          RETURN ObValue.NewArrayFromVals(vals);
      | ArrayCode.Size =&gt;
          TYPECASE args[1] OF
          | ObValue.ValArray (node) =&gt;
              RETURN NEW(ObValue.ValInt, int := node.remote.Size(),
                         temp := temp);
          ELSE
            ObValue.BadArgType(1, &quot;array&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
      | ArrayCode.Get =&gt;
          TYPECASE args[2] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[1] OF
          | ObValue.ValArray (node) =&gt;
              badOp := 2;
              RETURN node.remote.Get(int1);
          ELSE
            ObValue.BadArgType(1, &quot;array&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
      | ArrayCode.Set =&gt;
          TYPECASE args[1] OF
          | ObValue.ValArray (node) =&gt; rem1 := node.remote;
          ELSE
            ObValue.BadArgType(1, &quot;array&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          rem1.Set(int1, args[3]);
          badOp := 2;
          RETURN ObValue.valOk;
      | ArrayCode.Sub =&gt;
          TYPECASE args[2] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValInt (node) =&gt; int2 := node.int;
          ELSE
            ObValue.BadArgType(3, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[1] OF
          | ObValue.ValArray (node) =&gt;
              badOp := 3;
              RETURN node.remote.Sub(int1, int2);
          ELSE
            ObValue.BadArgType(1, &quot;array&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
      | ArrayCode.Upd =&gt;
          TYPECASE args[1] OF
          | ObValue.ValArray (node) =&gt; rem1 := node.remote;
          ELSE
            ObValue.BadArgType(1, &quot;array&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValInt (node) =&gt; int2 := node.int;
          ELSE
            ObValue.BadArgType(3, &quot;int&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[4] OF
          | ObValue.ValArray (node) =&gt; array1 := node.remote.Obtain();
          ELSE
            ObValue.BadArgType(4, &quot;array&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          badOp := 3;
          rem1.Upd(int1, int2, array1);
          RETURN ObValue.valOk;
      | ArrayCode.Cat =&gt;
          TYPECASE args[1] OF
          | ObValue.ValArray (node) =&gt; array1 := node.remote.Obtain();
          ELSE
            ObValue.BadArgType(1, &quot;array&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValArray (node) =&gt; array2 := node.remote.Obtain();
          ELSE
            ObValue.BadArgType(2, &quot;array&quot;, self.name, opCode.name, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
          badOp := 1;
          RETURN ObValue.ArrayCat(array1, array2);
      ELSE
        ObValue.BadOp(self.name, opCode.name, loc);
        &lt;*ASSERT FALSE*&gt;
      END;
    EXCEPT
    | ObValue.ServerError =&gt;
        ObValue.BadArgVal(badOp, &quot;in range&quot;, self.name, opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    | NetObj.Error (atoms) =&gt;
        ObValue.RaiseNetException(
          self.name &amp; &quot;_&quot; &amp; opCode.name, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, self.name &amp; &quot;_&quot; &amp; opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END EvalArray;
</PRE> ============ <CODE>net</CODE> package ============ 

<P><PRE>TYPE

  NetCode = {Error, Who, Export, Import, ExportEngine, ImportEngine};

  NetOpCode = ObLib.OpCode OBJECT code: NetCode;  END;

  PackageNet = ObLib.T OBJECT OVERRIDES Eval := EvalNet; END;

PROCEDURE <A NAME="NewNetOC"><procedure>NewNetOC</procedure></A> (name: TEXT; arity: INTEGER; code: NetCode): NetOpCode =
  BEGIN
    RETURN NEW(NetOpCode, name := name, arity := arity, code := code);
  END NewNetOC;

PROCEDURE <A NAME="SetupNet"><procedure>SetupNet</procedure></A> () =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(NetCode));
    opCodes^ := OpCodes{NewNetOC(&quot;failure&quot;, -1, NetCode.Error),
                        NewNetOC(&quot;who&quot;, 1, NetCode.Who),
                        NewNetOC(&quot;export&quot;, 3, NetCode.Export),
                        NewNetOC(&quot;import&quot;, 2, NetCode.Import),
                        NewNetOC(&quot;exportEngine&quot;, 3, NetCode.ExportEngine),
                        NewNetOC(&quot;importEngine&quot;, 2, NetCode.ImportEngine)};
    ObLib.Register(NEW(PackageNet, name := &quot;net&quot;, opCodes := opCodes));
  END SetupNet;

PROCEDURE <A NAME="EvalNet"><procedure>EvalNet</procedure></A> (                    self  : PackageNet;
                                       opCode: ObLib.OpCode;
                   &lt;*UNUSED*&gt;          arity : ObLib.OpArity;
                              READONLY args  : ObValue.ArgArray;
                   &lt;*UNUSED*&gt;          temp  : BOOLEAN;
                                       loc   : SynLocation.T     ):
  ObValue.Val RAISES {ObValue.Error, ObValue.Exception} =
  VAR text1, text2: TEXT;
  BEGIN
    CASE NARROW(opCode, NetOpCode).code OF
    | NetCode.Error =&gt; RETURN ObValue.netException;
    | NetCode.Who =&gt;
        TYPECASE args[1] OF
        | ObValue.ValObj (node) =&gt; RETURN NetObjectWho(node, loc);
        | ObValue.ValEngine (node) =&gt;
            RETURN NetEngineWho(node.remote, loc);
        ELSE
          ObValue.BadArgType(
            1, &quot;object or engine&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
    | NetCode.Export =&gt;
        TYPECASE args[1] OF
        | ObValue.ValText (node) =&gt; text1 := node.text;
        ELSE
          ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[2] OF
        | ObValue.ValText (node) =&gt; text2 := node.text;
        ELSE
          ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[3] OF
        | ObValue.ValRemObj, ObValue.ValReplObj, ObValue.ValSimpleObj =&gt;
        ELSE
          ObValue.BadArgType(3, &quot;object&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        NetExport(text1, text2, args[3], loc);
        RETURN args[3];
    | NetCode.Import =&gt;
        TYPECASE args[1] OF
        | ObValue.ValText (node) =&gt; text1 := node.text;
        ELSE
          ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[2] OF
        | ObValue.ValText (node) =&gt; text2 := node.text;
        ELSE
          ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN NetImport(text1, text2, loc);
    | NetCode.ExportEngine =&gt;
        TYPECASE args[1] OF
        | ObValue.ValText (node) =&gt; text1 := node.text;
        ELSE
          ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[2] OF
        | ObValue.ValText (node) =&gt; text2 := node.text;
        ELSE
          ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        NetExportEngine(text1, text2, args[3], loc);
        RETURN ObValue.valOk;
    | NetCode.ImportEngine =&gt;
        TYPECASE args[1] OF
        | ObValue.ValText (node) =&gt; text1 := node.text;
        ELSE
          ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[2] OF
        | ObValue.ValText (node) =&gt; text2 := node.text;
        ELSE
          ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN NetImportEngine(text1, text2, loc);
    ELSE
      ObValue.BadOp(self.name, opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END EvalNet;

PROCEDURE <A NAME="NetLocate"><procedure>NetLocate</procedure></A> (            server    : TEXT;
                     VAR (*out*) address   : TEXT;
                     VAR (*out*) netAddress: NetObj.Address;
                                 location  : SynLocation.T   )
  RAISES {ObValue.Exception} =
  BEGIN
    IF Text.Empty(server) THEN
      address := ObValue.machineAddress;
      netAddress := NIL;
    ELSE
      address := server;
      TRY
        netAddress := NetObj.Locate(address);
      EXCEPT
      | NetObj.Invalid, NetObj.Error =&gt;
          ObValue.RaiseNetException(&quot;Could not locate name server for '&quot;
                                      &amp; address &amp; &quot;'&quot;, NIL, location);
      | Thread.Alerted =&gt;
          ObValue.RaiseException(
            ObValue.threadAlerted, &quot;net_locate&quot;, location);
      END;
    END;
  END NetLocate;

PROCEDURE <A NAME="NetObjectWho"><procedure>NetObjectWho</procedure></A> (valObj: ObValue.ValObj; loc: SynLocation.T):
  ObValue.Val RAISES {ObValue.Exception} =
  VAR protected, serialized: BOOLEAN;
  BEGIN
    TRY
      RETURN
        ObValue.NewText(valObj.Who( (*out*)protected, (*out*) serialized));
    EXCEPT
    | SharedObj.Error (atoms) =&gt;
        ObValue.RaiseSharedException(&quot;net_who&quot;, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | NetObj.Error (atoms) =&gt;
        ObValue.RaiseNetException(&quot;net_who&quot;, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(ObValue.threadAlerted, &quot;net_who&quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END NetObjectWho;

PROCEDURE <A NAME="NetEngineWho"><procedure>NetEngineWho</procedure></A> (remObj: ObValue.RemEngine; loc: SynLocation.T):
  ObValue.Val RAISES {ObValue.Exception} =
  BEGIN
    TRY
      RETURN ObValue.NewText(remObj.Who());
    EXCEPT
    | NetObj.Error (atoms) =&gt;
        ObValue.RaiseNetException(&quot;net_who&quot;, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(ObValue.threadAlerted, &quot;net_who&quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END NetEngineWho;

PROCEDURE <A NAME="NetExport"><procedure>NetExport</procedure></A> (name, server: TEXT;
                     valObj      : ObValue.ValObj;
                     loc         : SynLocation.T   )
  RAISES {ObValue.Exception} =
  VAR
    address   : TEXT;
    netAddress: NetObj.Address;
  BEGIN
    NetLocate(server, (*out*) address, (*out*) netAddress, loc);
    TRY
      TYPECASE valObj OF
      | ObValue.ValRemObj (o) =&gt; NetObj.Export(name, o.remote, netAddress);
      | ObValue.ValReplObj (o) =&gt;
          NetObj.Export(
            name, NEW(ObValue.NonRemObjHookServer).init(o), netAddress);
      | ObValue.ValSimpleObj (o) =&gt;
          NetObj.Export(
            name, NEW(ObValue.NonRemObjHookServer).init(o), netAddress);
      ELSE                       &lt;*ASSERT FALSE*&gt;
      END;
    EXCEPT
    | NetObj.Error (atoms) =&gt;
        ObValue.RaiseNetException(
          &quot;net_export: '&quot; &amp; name &amp; &quot;' at '&quot; &amp; address &amp; &quot;'&quot;, atoms, loc);
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted,
          &quot;net_export: '&quot; &amp; name &amp; &quot;' at '&quot; &amp; address &amp; &quot;'&quot;, loc);
    END;
    TYPECASE valObj OF
    | ObValue.ValRemObj (remObj) =&gt;
        TYPECASE remObj.remote OF
        | ObValue.RemObjServer (serv) =&gt;
            IF Text.Empty(serv.who) THEN
              serv.who := name &amp; &quot;@&quot; &amp; address;
            END;
        ELSE
        END;
    ELSE
    END;
  END NetExport;

PROCEDURE <A NAME="NetImport"><procedure>NetImport</procedure></A> (name, server: TEXT; loc: SynLocation.T): ObValue.Val
  RAISES {ObValue.Exception} =
  VAR
    address   : TEXT;
    netAddress: NetObj.Address;
    netObj    : NetObj.T;
  BEGIN
    NetLocate(server, (*out*) address, (*out*) netAddress, loc);
    TRY
      netObj := NetObj.Import(name, netAddress);
    EXCEPT
    | NetObj.Error (atoms) =&gt;
        ObValue.RaiseNetException(
          &quot;net_import: '&quot; &amp; name &amp; &quot;' at '&quot; &amp; address &amp; &quot;'&quot;, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted,
          &quot;net_import: '&quot; &amp; name &amp; &quot;' at '&quot; &amp; address &amp; &quot;'&quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
    IF netObj = NIL THEN
      ObValue.RaiseException(
        ObValue.netException,
        &quot;net_import: '&quot; &amp; name &amp; &quot;' was not found at '&quot; &amp; address &amp; &quot;'&quot;,
        loc);
      &lt;*ASSERT FALSE*&gt;
    END;
    TYPECASE netObj OF
    | ObValue.RemObj (remObj) =&gt;
        RETURN NEW(ObValue.ValRemObj, remote := remObj);
    | ObValue.NonRemObjHook (hook) =&gt;
        TRY
          RETURN hook.Get();
        EXCEPT
        | NetObj.Error (atoms) =&gt;
            ObValue.RaiseNetException(&quot;net_import: '&quot; &amp; name &amp; &quot;' at '&quot;
                                        &amp; address &amp; &quot;'&quot;, atoms, loc);
          &lt;*ASSERT FALSE*&gt;
        | Thread.Alerted =&gt;
            ObValue.RaiseException(
              ObValue.threadAlerted,
              &quot;net_import: '&quot; &amp; name &amp; &quot;' at '&quot; &amp; address &amp; &quot;'&quot;, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
    ELSE
      ObValue.RaiseException(
        ObValue.netException, &quot;net_import failed: '&quot; &amp; name &amp; &quot;' at '&quot;
                                &amp; address &amp; &quot;' is not a network object&quot;,
        loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END NetImport;

PROCEDURE <A NAME="NetExportEngine"><procedure>NetExportEngine</procedure></A> (name, server: TEXT;
                           arg         : ObValue.Val;
                           loc         : SynLocation.T)
  RAISES {ObValue.Exception} =
  VAR
    address   : TEXT;
    netAddress: NetObj.Address;
    remEngine : ObValue.RemEngine;
  BEGIN
    NetLocate(server, (*out*) address, (*out*) netAddress, loc);
    remEngine := NEW(ObValue.RemEngineServer, who := name &amp; &quot;@&quot; &amp; address,
                     arg := arg);
    TRY
      NetObj.Export(name, remEngine, netAddress);
    EXCEPT
    | NetObj.Error (atoms) =&gt;
        ObValue.RaiseNetException(&quot;net_exportEngine: '&quot; &amp; name &amp; &quot;' at '&quot;
                                    &amp; address &amp; &quot;'&quot;, atoms, loc);
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted,
          &quot;net_exportEngine: '&quot; &amp; name &amp; &quot;' at '&quot; &amp; address &amp; &quot;'&quot;, loc);
    END;
  END NetExportEngine;

PROCEDURE <A NAME="NetImportEngine"><procedure>NetImportEngine</procedure></A> (name, server: TEXT; loc: SynLocation.T):
  ObValue.Val RAISES {ObValue.Exception} =
  VAR
    address   : TEXT;
    netAddress: NetObj.Address;
    netObj    : NetObj.T;
  BEGIN
    NetLocate(server, (*out*) address, (*out*) netAddress, loc);
    TRY
      netObj := NetObj.Import(name, netAddress);
    EXCEPT
    | NetObj.Error (atoms) =&gt;
        ObValue.RaiseNetException(&quot;net_importEngine: '&quot; &amp; name &amp; &quot;' at '&quot;
                                    &amp; address &amp; &quot;'&quot;, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted,
          &quot;net_importEngine: '&quot; &amp; name &amp; &quot;' at '&quot; &amp; address &amp; &quot;'&quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
    IF netObj = NIL THEN
      ObValue.RaiseException(
        ObValue.netException, &quot;net_importEngine: '&quot; &amp; name
                                &amp; &quot;' was not found at '&quot; &amp; address &amp; &quot;'&quot;,
        loc);
      &lt;*ASSERT FALSE*&gt;
    END;
    TYPECASE netObj OF
    | ObValue.RemEngine (remEngine) =&gt;
        RETURN NEW(ObValue.ValEngine, remote := remEngine);
    ELSE
      ObValue.RaiseException(
        ObValue.netException,
        &quot;net_importEngine failed: '&quot; &amp; name &amp; &quot;' at '&quot; &amp; address
          &amp; &quot;' is not a network engine&quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END NetImportEngine;
</PRE> ============ <CODE>replica</CODE> package ============ 

<P><PRE>TYPE
  ReplicaCode =
    {Error, Fatal, AcquireGlobalLock, ReleaseGlobalLock, SetNodeName,
     SetDefaultSequencer, Notify, CancelNotifier, DumpState};

  ReplicaOpCode = ObLib.OpCode OBJECT code: ReplicaCode;  END;

  PackageReplica = ObLib.T OBJECT OVERRIDES Eval := EvalReplica; END;

PROCEDURE <A NAME="NewReplicaOC"><procedure>NewReplicaOC</procedure></A> (name  : TEXT;
                        arity : INTEGER;
                        code  : ReplicaCode;
                        fixity: ObLib.OpFixity := ObLib.OpFixity.Qualified):
  ReplicaOpCode =
  BEGIN
    RETURN NEW(ReplicaOpCode, name := name, arity := arity, code := code,
               fixity := fixity);
  END NewReplicaOC;

PROCEDURE <A NAME="SetupReplica"><procedure>SetupReplica</procedure></A> () =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(ReplicaCode));
    opCodes^ :=
      OpCodes{
        NewReplicaOC(&quot;failure&quot;, -1, ReplicaCode.Error),
        NewReplicaOC(&quot;fatal&quot;, -1, ReplicaCode.Fatal),
        NewReplicaOC(&quot;acquire&quot;, 1, ReplicaCode.AcquireGlobalLock),
        NewReplicaOC(&quot;release&quot;, 1, ReplicaCode.ReleaseGlobalLock),
        NewReplicaOC(&quot;setNodeName&quot;, 1, ReplicaCode.SetNodeName),
        NewReplicaOC(&quot;notify&quot;, 2, ReplicaCode.Notify),
        NewReplicaOC(&quot;cancelNotifier&quot;, 1, ReplicaCode.CancelNotifier),
        NewReplicaOC(
          &quot;setDefaultSequencer&quot;, 2, ReplicaCode.SetDefaultSequencer),
        NewReplicaOC(&quot;dumpState&quot;, 0, ReplicaCode.DumpState)};
    ObLib.Register(
      NEW(PackageReplica, name := &quot;replica&quot;, opCodes := opCodes));
  END SetupReplica;

PROCEDURE <A NAME="EvalReplica"><procedure>EvalReplica</procedure></A> (                    self  : PackageReplica;
                                           opCode: ObLib.OpCode;
                       &lt;*UNUSED*&gt;          arity : ObLib.OpArity;
                                  READONLY args  : ObValue.ArgArray;
                       &lt;*UNUSED*&gt;          temp  : BOOLEAN;
                                           loc   : SynLocation.T     ):
  ObValue.Val RAISES {ObValue.Error, ObValue.Exception} =
  VAR text1, text2: TEXT;
  BEGIN
    CASE NARROW(opCode, ReplicaOpCode).code OF
    | ReplicaCode.Error =&gt; RETURN ObValue.sharedException;
    | ReplicaCode.Fatal =&gt; RETURN ObValue.sharedFatal;
    | ReplicaCode.Notify =&gt; RETURN ReplicaNotify(args[1], args[2], loc);
    | ReplicaCode.CancelNotifier =&gt;
        ReplicaCancelNotifier(args[1], loc);
        RETURN ObValue.valOk;
    | ReplicaCode.DumpState =&gt; ReplicaDumpState(loc); RETURN ObValue.valOk;
    | ReplicaCode.AcquireGlobalLock =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReplObj =&gt;
        ELSE
          ObValue.BadArgType(
            1, &quot;replicated object&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN ReplicaAcquireLock(args[1], loc);
    | ReplicaCode.ReleaseGlobalLock =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReplObj =&gt;
        ELSE
          ObValue.BadArgType(
            1, &quot;replicated object&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN ReplicaReleaseLock(args[1], loc);
    | ReplicaCode.SetNodeName =&gt;
        TYPECASE args[1] OF
        | ObValue.ValText (node) =&gt; text1 := node.text;
        ELSE
          ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN ReplicaSetNodeName(text1, loc);
    | ReplicaCode.SetDefaultSequencer =&gt;
        TYPECASE args[1] OF
        | ObValue.ValText (node) =&gt; text1 := node.text;
        ELSE
          ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[2] OF
        | ObValue.ValText (node) =&gt; text2 := node.text;
        ELSE
          ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN ReplicaSetDefaultSequencer(text1, text2, loc);
    ELSE
      ObValue.BadOp(self.name, opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END EvalReplica;

PROCEDURE <A NAME="ReplicaNotify"><procedure>ReplicaNotify</procedure></A> (valObj   : ObValue.Val;
                         notifyObj: ObValue.ValObj;
                         loc      : SynLocation.T   ): ObValue.Val
  RAISES {ObValue.Exception} =
  BEGIN
    TYPECASE valObj OF
    | ObValue.ValReplObj (obj) =&gt;
        TYPECASE notifyObj OF
        | ObValue.ValSimpleObj (notifier) =&gt;
            RETURN ObValueNotify.New(obj, notifier, loc);
        ELSE
          ObValue.RaiseException(
            ObValue.sharedException,
            &quot;replica_notify failed: '&quot;
              &amp; &quot;second argument must be a simple object&quot;, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
    ELSE
      ObValue.RaiseException(
        ObValue.sharedException,
        &quot;replica_notify failed: '&quot;
          &amp; &quot;first argument must be a replicated object&quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END ReplicaNotify;

PROCEDURE <A NAME="ReplicaCancelNotifier"><procedure>ReplicaCancelNotifier</procedure></A> (notifier: ObValue.Val; loc: SynLocation.T)
  RAISES {ObValue.Exception} =
  BEGIN
    TYPECASE notifier OF
    | ObValueNotify.ValObjCB (obj) =&gt; obj.cancel();
    ELSE
      ObValue.RaiseException(
        ObValue.sharedException,
        &quot;replica_cancelNotifier failed: '&quot;
          &amp; &quot;first argument must be a notifier callback&quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END ReplicaCancelNotifier;

PROCEDURE <A NAME="ReplicaAcquireLock"><procedure>ReplicaAcquireLock</procedure></A> (valObj: ObValue.ValObj; loc: SynLocation.T):
  ObValue.Val RAISES {ObValue.Exception} =
  BEGIN
    TRY
      TYPECASE valObj OF
      | ObValue.ValReplObj (obj) =&gt;
          SharedObj.AcquireGlobalLock(obj.replica);
      ELSE
        ObValue.RaiseException(
          ObValue.sharedException,
          &quot;replica_acquire failed: '&quot;
            &amp; &quot;argument must be a replicated object&quot;, loc);
        &lt;*ASSERT FALSE*&gt;
      END;
    EXCEPT
    | SharedObj.Error (atoms) =&gt;
        ObValue.RaiseSharedException(&quot;replica_acquire: &quot;, atoms, loc);
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, &quot;replica_acquire: &quot;, loc);
    END;
    RETURN ObValue.valOk;
  END ReplicaAcquireLock;

PROCEDURE <A NAME="ReplicaReleaseLock"><procedure>ReplicaReleaseLock</procedure></A> (valObj: ObValue.ValObj; loc: SynLocation.T):
  ObValue.Val RAISES {ObValue.Exception} =
  BEGIN
    TRY
      TYPECASE valObj OF
      | ObValue.ValReplObj (obj) =&gt;
          SharedObj.ReleaseGlobalLock(obj.replica);
      ELSE
        ObValue.RaiseException(
          ObValue.sharedException,
          &quot;replica_release failed: '&quot;
            &amp; &quot;argument must be a replicated object&quot;, loc);
        &lt;*ASSERT FALSE*&gt;
      END;
    EXCEPT
    | SharedObj.Error (atoms) =&gt;
        ObValue.RaiseSharedException(&quot;replica_release: &quot;, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, &quot;replica_release: &quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
    RETURN ObValue.valOk;
  END ReplicaReleaseLock;

PROCEDURE <A NAME="ReplicaSetNodeName"><procedure>ReplicaSetNodeName</procedure></A> (name: TEXT; loc: SynLocation.T): ObValue.Val
  RAISES {ObValue.Exception} =
  BEGIN
    TRY
      IF Text.Equal(name, &quot;&quot;) THEN name := ObValue.machineAddress; END;
      SharedObjRT.ExportSpace(name);
      RETURN ObValue.NewText(name);
    EXCEPT
    | SharedObj.Error (atoms) =&gt;
        ObValue.RaiseSharedException(&quot;replica_setNodeName: &quot;, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, &quot;replica_setNodeName: &quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END ReplicaSetNodeName;

PROCEDURE <A NAME="ReplicaDumpState"><procedure>ReplicaDumpState</procedure></A> (loc: SynLocation.T)
  RAISES {ObValue.Exception} =
  BEGIN
    TRY
      SharedObjRT.LocalSpace().printState();
    EXCEPT
    | NetObj.Error (atoms) =&gt;
        ObValue.RaiseNetException(&quot;replica_dumpState: &quot;, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, &quot;replica_setNodeName: &quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END ReplicaDumpState;

PROCEDURE <A NAME="ReplicaSetDefaultSequencer"><procedure>ReplicaSetDefaultSequencer</procedure></A> (host, name: TEXT; loc: SynLocation.T):
  ObValue.Val RAISES {ObValue.Exception} =
  VAR space: ObjectSpace.T;
  BEGIN
    TRY
      IF Text.Equal(&quot;&quot;, host) THEN
        WITH defhost = Env.Get(&quot;SEQUENCERHOST&quot;) DO
          IF defhost # NIL THEN host := defhost; END;
        END;
      END;
      IF Text.Equal(&quot;&quot;, name) THEN
        WITH defname = Env.Get(&quot;SEQUENCERNAME&quot;) DO
          IF defname # NIL THEN name := defname; END;
        END;
      END;

      IF NOT Text.Equal(&quot;&quot;, host) OR NOT Text.Equal(&quot;&quot;, name) THEN
        space := SharedObjRT.ImportSpace(host, name);
        IF space = NIL THEN
          ObValue.RaiseException(
            ObValue.sharedException,
            &quot;replica_setDefaultSequencer: node &quot; &amp; name &amp; &quot;@&quot; &amp; host
              &amp; &quot; is unavailable&quot;, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
      ELSE
        space := SharedObjRT.LocalSpace();
      END;
      SharedObjRT.SetDfltSequencer(space);
      RETURN ObValue.valOk;
    EXCEPT
    | SharedObj.Error (atoms) =&gt;
        ObValue.RaiseSharedException(
          &quot;replica_setDefaultSequencer: &quot;, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, &quot;replica_setDefaultSequencer: &quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END ReplicaSetDefaultSequencer;
</PRE> ============ <CODE>thread</CODE> package ============ 

<P><PRE>TYPE

  ThreadCode = {Alerted, NewMutex, NewCondition, Self, Fork, Join, Wait,
                Acquire, Release, Broadcast, Signal, Pause, Alert,
                TestAlert, AlertWait, AlertJoin, AlertPause, Lock,
                NewPool, AddWork, StealWorker, FinishWork};

  ThreadOpCode = ObLib.OpCode OBJECT code: ThreadCode;  END;

  PackageThread = ObLib.T OBJECT OVERRIDES Eval := EvalThread; END;

PROCEDURE <A NAME="IsMutex"><procedure>IsMutex</procedure></A> (self: ValMutex; other: ObValue.ValAnything): BOOLEAN =
  BEGIN
    TYPECASE other OF
      ValMutex (oth) =&gt; RETURN self.mutex = oth.mutex;
    ELSE
      RETURN FALSE
    END;
  END IsMutex;

PROCEDURE <A NAME="IsCondition"><procedure>IsCondition</procedure></A> (self: ValCondition; other: ObValue.ValAnything):
  BOOLEAN =
  BEGIN
    TYPECASE other OF
      ValCondition (oth) =&gt; RETURN self.condition = oth.condition;
    ELSE
      RETURN FALSE
    END;
  END IsCondition;

PROCEDURE <A NAME="IsThread"><procedure>IsThread</procedure></A> (self: ValThread; other: ObValue.ValAnything): BOOLEAN =
  BEGIN
    TYPECASE other OF
      ValThread (oth) =&gt; RETURN self.thread = oth.thread;
    ELSE
      RETURN FALSE
    END;
  END IsThread;

PROCEDURE <A NAME="IsPool"><procedure>IsPool</procedure></A> (self: ValPool; other: ObValue.ValAnything): BOOLEAN =
  BEGIN
    TYPECASE other OF
      ValPool (oth) =&gt; RETURN self.pool = oth.pool;
    ELSE
      RETURN FALSE
    END;
  END IsPool;

PROCEDURE <A NAME="CopyMutex"><procedure>CopyMutex</procedure></A> (&lt;*UNUSED*&gt; self: ObValue.ValAnything;
                     &lt;*UNUSED*&gt; tbl : ObValue.Tbl;
                     &lt;*UNUSED*&gt; loc : SynLocation.T        ):
  ObValue.ValAnything =
  BEGIN
    RETURN NEW(ValMutex, what := &quot;&lt;a Thread.Mutex&gt;&quot;, picklable := FALSE,
               tag:= &quot;Thread`Mutex&quot;,
               mutex := NEW(Thread.Mutex));
  END CopyMutex;

PROCEDURE <A NAME="CopyCondition"><procedure>CopyCondition</procedure></A> (&lt;*UNUSED*&gt; self: ObValue.ValAnything;
                         &lt;*UNUSED*&gt; tbl : ObValue.Tbl;
                         &lt;*UNUSED*&gt; loc : SynLocation.T        ):
  ObValue.ValAnything =
  BEGIN
    RETURN NEW(ValCondition, what := &quot;&lt;a Thread.Condition&gt;&quot;,
               tag:=&quot;Thread`Condition&quot;,
               picklable := FALSE, condition := NEW(Thread.Condition));
  END CopyCondition;

TYPE
  ObliqThreadClosure = Thread.SizedClosure OBJECT
                         fun      : ObValue.ValFun;
                         location : SynLocation.T;
                         result   : ObValue.Val;
                         error    : ObValue.ErrorPacket;
                         exception: ObValue.ExceptionPacket;
                       OVERRIDES
                         apply := ApplyThreadClosure;
                       END;

TYPE
  ObliqWork = Work.T OBJECT
                         fun      : ObValue.ValFun;
                         location : SynLocation.T;
                       OVERRIDES
                         handle := HandleWork;
                       END;

PROCEDURE <A NAME="Msg"><procedure>Msg</procedure></A> (swr           : SynWr.T;
               msg           : TEXT;
               sourceLocation: SynLocation.T) =
  BEGIN
    SynWr.Beg(swr, 2, loud := TRUE);
    SynWr.Text(swr, msg, loud := TRUE);
    SynLocation.PrintLocation(swr, sourceLocation);
    SynWr.End(swr, loud := TRUE);
    SynWr.NewLine(swr, loud := TRUE);
    SynWr.Flush(swr, loud := TRUE);
  END Msg;

PROCEDURE <A NAME="ApplyThreadClosure"><procedure>ApplyThreadClosure</procedure></A> (self: ObliqThreadClosure): REFANY =
  VAR noArgs: ARRAY [0 .. -1] OF ObValue.Val;
  BEGIN
    TRY
      self.result := ObEval.Call(self.fun, noArgs, self.location);
    EXCEPT
    | ObValue.Error (packet) =&gt;
        self.error := packet;
        ObValue.ErrorMsg(SynWr.err, packet);
        Msg(SynWr.err, &quot;&lt;Thread.T&gt; terminated by execution error&quot;,
            self.location);
    | ObValue.Exception (packet) =&gt;
        self.exception := packet;
        ObValue.ExceptionMsg(SynWr.err, packet);
        Msg(SynWr.err, &quot;&lt;Thread.T&gt; terminated by unhandled exception&quot;,
            self.location);
    END;
    RETURN self;
  END ApplyThreadClosure;

PROCEDURE <A NAME="HandleWork"><procedure>HandleWork</procedure></A> (self: ObliqWork) =
  VAR noArgs: ARRAY [0 .. -1] OF ObValue.Val;
  BEGIN
    TRY
      EVAL ObEval.Call(self.fun, noArgs, self.location);
    EXCEPT
    | ObValue.Error (packet) =&gt;
        ObValue.ErrorMsg(SynWr.err, packet);
        Msg(SynWr.err, &quot;&lt;work&gt; terminated by execution error&quot;,
            self.location);
    | ObValue.Exception (packet) =&gt;
        ObValue.ExceptionMsg(SynWr.err, packet);
        Msg(SynWr.err, &quot;&lt;work&gt; terminated by unhandled exception&quot;,
            self.location);
    END;
  END HandleWork;

PROCEDURE <A NAME="NewPool"><procedure>NewPool</procedure></A> (maxThreads, idleThreads, stackSize: INTEGER): ValPool =
  VAR
    pool       : WorkerPool.T;
  BEGIN
    stackSize := MIN(MAX(stackSize, 4096), LAST(CARDINAL));
    pool := NEW(WorkerPool.T).init(maxThreads, idleThreads, stackSize);
    RETURN NEW(ValPool, what := &quot;&lt;a WorkerPool.T&gt;&quot;, picklable := FALSE,
               tag:=&quot;Workerpool`T&quot;,
               pool := pool);
  END NewPool;

PROCEDURE <A NAME="ForkThread"><procedure>ForkThread</procedure></A> (fun      : ObValue.ValFun;
                      stackSize: INTEGER;
                      loc      : SynLocation.T   ): ValThread =
  VAR
    thread       : Thread.T;
    threadClosure: ObliqThreadClosure;
  BEGIN
    stackSize := MIN(MAX(stackSize, 4096), LAST(CARDINAL));
    threadClosure :=
      NEW(ObliqThreadClosure, stackSize := stackSize, fun := fun,
          location := loc, result := NIL, error := NIL, exception := NIL);
    thread := Thread.Fork(threadClosure);
    RETURN NEW(ValThread, what := &quot;&lt;a Thread.T&gt;&quot;, picklable := FALSE,
               tag:=&quot;Thread`T&quot;,
               thread := thread, joinedMu := NEW(Thread.Mutex),
               joined := FALSE);
  END ForkThread;

PROCEDURE <A NAME="JoinThread"><procedure>JoinThread</procedure></A> (threadVal: ValThread; loc: SynLocation.T):
  ObValue.Val RAISES {ObValue.Error, ObValue.Exception} =
  VAR threadClosure: ObliqThreadClosure;
  BEGIN
    LOCK threadVal.joinedMu DO
      IF threadVal.joined THEN
        ObValue.RaiseError(&quot;Thread already joined&quot;, loc);
      ELSE
        threadVal.joined := TRUE;
      END;
    END;
    threadClosure := Thread.Join(threadVal.thread);
    IF threadClosure.error # NIL THEN
      RAISE ObValue.Error(threadClosure.error);
    ELSIF threadClosure.exception # NIL THEN
      RAISE ObValue.Exception(threadClosure.exception);
    ELSE
      RETURN threadClosure.result;
    END;
  END JoinThread;

PROCEDURE <A NAME="NewThreadOC"><procedure>NewThreadOC</procedure></A> (name  : TEXT;
                       arity : INTEGER;
                       code  : ThreadCode;
                       fixity: ObLib.OpFixity := ObLib.OpFixity.Qualified):
  ThreadOpCode =
  BEGIN
    RETURN NEW(ThreadOpCode, name := name, arity := arity, code := code,
               fixity := fixity);
  END NewThreadOC;

PROCEDURE <A NAME="SetupThread"><procedure>SetupThread</procedure></A> () =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(ThreadCode));
    opCodes^ :=
      OpCodes{NewThreadOC(&quot;alerted&quot;, -1, ThreadCode.Alerted),
              NewThreadOC(
                &quot;mutex&quot;, 0, ThreadCode.NewMutex, ObLib.OpFixity.Prefix),
              NewThreadOC(&quot;condition&quot;, 0, ThreadCode.NewCondition,
                          ObLib.OpFixity.Prefix),
              NewThreadOC(&quot;self&quot;, 0, ThreadCode.Self),
              NewThreadOC(
                &quot;fork&quot;, 2, ThreadCode.Fork, ObLib.OpFixity.Prefix),
              NewThreadOC(
                &quot;join&quot;, 1, ThreadCode.Join, ObLib.OpFixity.Prefix),
              NewThreadOC(
                &quot;wait&quot;, 2, ThreadCode.Wait, ObLib.OpFixity.Prefix),
              NewThreadOC(&quot;acquire&quot;, 1, ThreadCode.Acquire),
              NewThreadOC(&quot;release&quot;, 1, ThreadCode.Release),
              NewThreadOC(&quot;broadcast&quot;, 1, ThreadCode.Broadcast,
                          ObLib.OpFixity.Prefix),
              NewThreadOC(
                &quot;signal&quot;, 1, ThreadCode.Signal, ObLib.OpFixity.Prefix),
              NewThreadOC(
                &quot;pause&quot;, 1, ThreadCode.Pause, ObLib.OpFixity.Prefix),
              NewThreadOC(&quot;alert&quot;, 1, ThreadCode.Alert),
              NewThreadOC(&quot;testAlert&quot;, 0, ThreadCode.TestAlert),
              NewThreadOC(&quot;alertWait&quot;, 2, ThreadCode.AlertWait),
              NewThreadOC(&quot;alertJoin&quot;, 1, ThreadCode.AlertJoin),
              NewThreadOC(&quot;alertPause&quot;, 1, ThreadCode.AlertPause),
              NewThreadOC(&quot;pool&quot;, 3, ThreadCode.NewPool),
              NewThreadOC(&quot;addWork&quot;, 2, ThreadCode.AddWork),
              NewThreadOC(&quot;stealWorker&quot;, 1, ThreadCode.StealWorker),
              NewThreadOC(&quot;finish&quot;, 1, ThreadCode.FinishWork),
              NewThreadOC(&quot;lock&quot;, 2, ThreadCode.Lock)};
    ObLib.Register(
      NEW(PackageThread, name := &quot;thread&quot;, opCodes := opCodes));
    ObValue.InhibitTransmission(
      TYPECODE(ValMutex), &quot;mutexes cannot be transmitted/duplicated&quot;);
    ObValue.InhibitTransmission(
      TYPECODE(ValCondition), &quot;conditions cannot be transmitted/duplicated&quot;);
    ObValue.InhibitTransmission(
      TYPECODE(ValThread), &quot;threads cannot be transmitted/duplicated&quot;);
  END SetupThread;

PROCEDURE <A NAME="EvalThread"><procedure>EvalThread</procedure></A> (                    self  : PackageThread;
                                          opCode: ObLib.OpCode;
                      &lt;*UNUSED*&gt;          arity : ObLib.OpArity;
                                 READONLY args  : ObValue.ArgArray;
                      &lt;*UNUSED*&gt;          temp  : BOOLEAN;
                                          loc   : SynLocation.T     ):
  ObValue.Val RAISES {ObValue.Error, ObValue.Exception} =
  VAR
    thread1   : Thread.T;
    threadVal1: ValThread;
    fun1      : ObValue.ValFun;
    mutex1    : Thread.Mutex;
    condition1: Thread.Condition;
    longReal1 : LONGREAL;
    int1,int2,int3: INTEGER;
    noArgs    : ARRAY [0 .. -1] OF ObValue.Val;
    pool1     : WorkerPool.T;
  BEGIN
    CASE NARROW(opCode, ThreadOpCode).code OF
    | ThreadCode.Alerted =&gt; RETURN ObValue.threadAlerted;
    | ThreadCode.NewMutex =&gt;
        mutex1 := NEW(Thread.Mutex);
        RETURN NEW(ValMutex, what := &quot;&lt;a Thread.Mutex&gt;&quot;,
                   tag:=&quot;Thread`Mutex&quot;,
                   picklable := FALSE, mutex := mutex1);
    | ThreadCode.NewCondition =&gt;
        condition1 := NEW(Thread.Condition);
        RETURN NEW(ValCondition, what := &quot;&lt;a Thread.Condition&gt;&quot;,
                   tag:=&quot;Thread`Condition&quot;,
                   picklable := FALSE, condition := condition1);
    | ThreadCode.Self =&gt;
        thread1 := Thread.Self();
        RETURN NEW(ValThread, what := &quot;&lt;a Thread.T&gt;&quot;, picklable := FALSE,
                   tag:=&quot;Thread`T&quot;,
                   thread := thread1, joinedMu := NEW(Thread.Mutex),
                   joined := FALSE);
    | ThreadCode.Fork =&gt;
        TYPECASE args[1] OF
        | ObValue.ValFun (node) =&gt; fun1 := node;
        ELSE
          ObValue.BadArgType(1, &quot;procedure&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[2] OF
        | ObValue.ValInt (node) =&gt; int1 := node.int;
        ELSE
          ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN ForkThread(fun1, int1, loc);
    | ThreadCode.Join =&gt;
        TYPECASE args[1] OF
        | ValThread (node) =&gt; threadVal1 := node;
        ELSE
          ObValue.BadArgType(1, &quot;thread&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN JoinThread(threadVal1, loc);
    | ThreadCode.Wait =&gt;
        TYPECASE args[1] OF
        | ValMutex (node) =&gt; mutex1 := node.mutex;
        ELSE
          ObValue.BadArgType(1, &quot;mutex&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[2] OF
        | ValCondition (node) =&gt; condition1 := node.condition;
        ELSE
          ObValue.BadArgType(2, &quot;condition&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        Thread.Wait(mutex1, condition1);
        RETURN ObValue.valOk;
    | ThreadCode.Acquire =&gt;
        TYPECASE args[1] OF
        | ValMutex (node) =&gt; mutex1 := node.mutex;
        ELSE
          ObValue.BadArgType(1, &quot;mutex&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        Thread.Acquire(mutex1);
        RETURN ObValue.valOk;
    | ThreadCode.Release =&gt;
        TYPECASE args[1] OF
        | ValMutex (node) =&gt; mutex1 := node.mutex;
        ELSE
          ObValue.BadArgType(1, &quot;mutex&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        Thread.Release(mutex1);
        RETURN ObValue.valOk;
    | ThreadCode.Broadcast =&gt;
        TYPECASE args[1] OF
        | ValCondition (node) =&gt; condition1 := node.condition;
        ELSE
          ObValue.BadArgType(1, &quot;condition&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        Thread.Broadcast(condition1);
        RETURN ObValue.valOk;
    | ThreadCode.Signal =&gt;
        TYPECASE args[1] OF
        | ValCondition (node) =&gt; condition1 := node.condition;
        ELSE
          ObValue.BadArgType(1, &quot;condition&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        Thread.Signal(condition1);
        RETURN ObValue.valOk;
    | ThreadCode.Pause =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt; longReal1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        IF longReal1 &lt; 0.0d0 THEN
          ObValue.BadArgVal(1, &quot;non-negative&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        Thread.Pause(longReal1);
        RETURN ObValue.valOk;
    | ThreadCode.Alert =&gt;
        TYPECASE args[1] OF
        | ValThread (node) =&gt; thread1 := node.thread;
        ELSE
          ObValue.BadArgType(1, &quot;thread&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        Thread.Alert(thread1);
        RETURN ObValue.valOk;
    | ThreadCode.TestAlert =&gt;
        IF Thread.TestAlert() THEN RETURN true ELSE RETURN false END;
    | ThreadCode.AlertJoin =&gt;
        TYPECASE args[1] OF
        | ValThread (node) =&gt; thread1 := node.thread;
        ELSE
          ObValue.BadArgType(1, &quot;thread&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TRY
          RETURN Thread.AlertJoin(thread1);
        EXCEPT
          Thread.Alerted =&gt;
            ObValue.RaiseException(ObValue.threadAlerted, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
    | ThreadCode.AlertWait =&gt;
        TYPECASE args[1] OF
        | ValMutex (node) =&gt; mutex1 := node.mutex;
        ELSE
          ObValue.BadArgType(1, &quot;mutex&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[2] OF
        | ValCondition (node) =&gt; condition1 := node.condition;
        ELSE
          ObValue.BadArgType(2, &quot;condition&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TRY
          Thread.AlertWait(mutex1, condition1);
          RETURN ObValue.valOk;
        EXCEPT
          Thread.Alerted =&gt;
            ObValue.RaiseException(ObValue.threadAlerted, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
    | ThreadCode.AlertPause =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReal (node) =&gt; longReal1 := node.real;
        ELSE
          ObValue.BadArgType(1, &quot;real&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        IF longReal1 &lt; 0.0d0 THEN
          ObValue.BadArgVal(1, &quot;non-negative&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TRY
          Thread.AlertPause(longReal1);
          RETURN ObValue.valOk;
        EXCEPT
          Thread.Alerted =&gt;
            ObValue.RaiseException(ObValue.threadAlerted, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
    | ThreadCode.Lock =&gt;
        TYPECASE args[1] OF
        | ValMutex (node) =&gt; mutex1 := node.mutex;
        ELSE
          ObValue.BadArgType(1, &quot;mutex&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[2] OF
        | ObValue.ValFun (node) =&gt; fun1 := node;
        ELSE
          ObValue.BadArgType(2, &quot;procedure&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        LOCK mutex1 DO RETURN ObEval.Call(fun1, noArgs, loc) END;
    | ThreadCode.NewPool =&gt;
        TYPECASE args[1] OF
        | ObValue.ValInt (node) =&gt; int1 := node.int;
        ELSE
          ObValue.BadArgType(1, &quot;int&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[2] OF
        | ObValue.ValInt (node) =&gt; int2 := node.int;
        ELSE
          ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[3] OF
        | ObValue.ValInt (node) =&gt; int3 := node.int;
        ELSE
          ObValue.BadArgType(3, &quot;int&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN NewPool(int1, int2, int3);
    | ThreadCode.AddWork =&gt;
        TYPECASE args[1] OF
        | ValPool (node) =&gt; pool1 := node.pool;
        ELSE
          ObValue.BadArgType(1, &quot;pool&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[2] OF
        | ObValue.ValFun (node) =&gt; fun1 := node;
        ELSE
          ObValue.BadArgType(2, &quot;procedure&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        pool1.add(NEW(ObliqWork, fun := fun1, location := loc));
        RETURN ObValue.valOk;
    | ThreadCode.StealWorker =&gt;
        TYPECASE args[1] OF
        | ValPool (node) =&gt; pool1 := node.pool;
        ELSE
          ObValue.BadArgType(1, &quot;pool&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN NEW(ObValue.ValBool, bool := pool1.stealWorker());
    | ThreadCode.FinishWork =&gt;
        TYPECASE args[1] OF
        | ValPool (node) =&gt; pool1 := node.pool;
        ELSE
          ObValue.BadArgType(1, &quot;pool&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        pool1.finish();
        RETURN ObValue.valOk;
    ELSE
      ObValue.BadOp(self.name, opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END EvalThread;
</PRE><P>
<P>
<P>
(* ============ <CODE>reflect</CODE> package ============ 

<P> the possible option tags are:
   valOk, valBool, valChar, valText, valInt, valReal, valException,
   valOption, valVar, valArray, valMethod, valClosure, valAlias,
   valObject, 
   valAnything objects will have the ta


<P><PRE>TYPE
  ReflectCode =
    {Error,
     isVar,             (* does the ide refer to an updatable value? *)

     isArray,           (* is the Val an Array? *)
     isObject,          (*            an Object? *)
     isPrimitive,       (*            a Primitive? *)
     isOpaque,          (* is this a opaque wrapper of an M3 value? *)

     isSimple,
     isReplicated,
     isRemote,
     objectType,        (* get an option describing which of the 3 it is *)

     isProtected,
     isSynchronized,
     isClosure,         (* is this value a closure? *)

     isCompatible,      (* does o1 have AT LEAST the same fields as o2? *)
                        (* the fields must be compatible (meth=meth,
                           non-meth=non-meth) and have the same number
                           of params, etc *)

     tagCompatible,     (* pass an object and an array of option
                           tagged objects, return the object option
                           tagged with the tag of the first array
                           element it is compatible with *)

     (* we do not allow method fields to be retrieved *)
     getType,           (* return an option describing the type *)
     getFields,         (* return an array of non-method fields of o *)
     getField,          (* return the named non-method field of o *)
     isAlias,           (* is the named slot an alias? *)

     getName,
     getValue,
     setValue,
     invoke,
     equals,
     toString};

  ReflectOpCode = ObLib.OpCode OBJECT code: ReflectCode;  END;

  PackageReflect = ObLib.T OBJECT OVERRIDES Eval := EvalReflect; END;

PROCEDURE NewReflectOC (name  : TEXT;
                        arity : INTEGER;
                        code  : ReflectCode;
                        fixity: ObLib.OpFixity := ObLib.OpFixity.Qualified):
  ReflectOpCode =
  BEGIN
    RETURN NEW(ReflectOpCode, name := name, arity := arity, code := code,
               fixity := fixity);
  END NewReflectOC;

PROCEDURE SetupReflect () =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(ReflectCode));
    opCodes^ :=
      OpCodes{
        NewReflectOC(&quot;failure&quot;, -1, ReflectCode.Error),
        NewReflectOC(&quot;fatal&quot;, -1, ReflectCode.Fatal),
        NewReflectOC(&quot;acquire&quot;, 1, ReflectCode.AcquireGlobalLock),
        NewReflectOC(&quot;release&quot;, 1, ReflectCode.ReleaseGlobalLock),
        NewReflectOC(&quot;setNodeName&quot;, 1, ReflectCode.SetNodeName),
        NewReflectOC(&quot;notify&quot;, 2, ReflectCode.Notify),
        NewReflectOC(&quot;cancelNotifier&quot;, 1, ReflectCode.CancelNotifier),
        NewReflectOC(
          &quot;setDefaultSequencer&quot;, 2, ReflectCode.SetDefaultSequencer),
        NewReflectOC(&quot;dumpState&quot;, 0, ReflectCode.DumpState)};
    ObLib.Register(
      NEW(PackageReflect, name := &quot;reflect&quot;, opCodes := opCodes));
  END SetupReflect;

PROCEDURE EvalReflect (                    self  : PackageReflect;
                                           opCode: ObLib.OpCode;
                       &lt;*UNUSED*&gt;          arity : ObLib.OpArity;
                                  READONLY args  : ObValue.ArgArray;
                       &lt;*UNUSED*&gt;          temp  : BOOLEAN;
                                           loc   : SynLocation.T     ):
  ObValue.Val RAISES {ObValue.Error, ObValue.Exception} =
  VAR text1, text2: TEXT;
  BEGIN
    CASE NARROW(opCode, ReflectOpCode).code OF
    | ReflectCode.Error =&gt; RETURN ObValue.sharedException;
    | ReflectCode.Fatal =&gt; RETURN ObValue.sharedFatal;
    | ReflectCode.Notify =&gt; RETURN ReflectNotify(args[1], args[2], loc);
    | ReflectCode.CancelNotifier =&gt;
        ReflectCancelNotifier(args[1], loc);
        RETURN ObValue.valOk;
    | ReflectCode.DumpState =&gt; ReflectDumpState(loc); RETURN ObValue.valOk;
    | ReflectCode.AcquireGlobalLock =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReplObj =&gt;
        ELSE
          ObValue.BadArgType(
            1, &quot;reflectted object&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN ReflectAcquireLock(args[1], loc);
    | ReflectCode.ReleaseGlobalLock =&gt;
        TYPECASE args[1] OF
        | ObValue.ValReplObj =&gt;
        ELSE
          ObValue.BadArgType(
            1, &quot;reflectted object&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN ReflectReleaseLock(args[1], loc);
    | ReflectCode.SetNodeName =&gt;
        TYPECASE args[1] OF
        | ObValue.ValText (node) =&gt; text1 := node.text;
        ELSE
          ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN ReflectSetNodeName(text1, loc);
    | ReflectCode.SetDefaultSequencer =&gt;
        TYPECASE args[1] OF
        | ObValue.ValText (node) =&gt; text1 := node.text;
        ELSE
          ObValue.BadArgType(1, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        TYPECASE args[2] OF
        | ObValue.ValText (node) =&gt; text2 := node.text;
        ELSE
          ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
        RETURN ReflectSetDefaultSequencer(text1, text2, loc);
    ELSE
      ObValue.BadOp(self.name, opCode.name, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END EvalReflect;

PROCEDURE ReflectNotify (valObj   : ObValue.Val;
                         notifyObj: ObValue.ValObj;
                         loc      : SynLocation.T   ): ObValue.Val
  RAISES {ObValue.Exception} =
  BEGIN
    TYPECASE valObj OF
    | ObValue.ValReplObj (obj) =&gt;
        TYPECASE notifyObj OF
        | ObValue.ValSimpleObj (notifier) =&gt;
            RETURN ObValueNotify.New(obj, notifier, loc);
        ELSE
          ObValue.RaiseException(
            ObValue.sharedException,
            &quot;reflect_notify failed: '&quot;
              &amp; &quot;second argument must be a simple object&quot;, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
    ELSE
      ObValue.RaiseException(
        ObValue.sharedException,
        &quot;reflect_notify failed: '&quot;
          &amp; &quot;first argument must be a reflectted object&quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END ReflectNotify;

PROCEDURE ReflectCancelNotifier (notifier: ObValue.Val; loc: SynLocation.T)
  RAISES {ObValue.Exception} =
  BEGIN
    TYPECASE notifier OF
    | ObValueNotify.ValObjCB (obj) =&gt; obj.cancel();
    ELSE
      ObValue.RaiseException(
        ObValue.sharedException,
        &quot;reflect_cancelNotifier failed: '&quot;
          &amp; &quot;first argument must be a notifier callback&quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END ReflectCancelNotifier;

PROCEDURE ReflectAcquireLock (valObj: ObValue.ValObj; loc: SynLocation.T):
  ObValue.Val RAISES {ObValue.Exception} =
  BEGIN
    TRY
      TYPECASE valObj OF
      | ObValue.ValReplObj (obj) =&gt;
          SharedObj.AcquireGlobalLock(obj.reflect);
      ELSE
        ObValue.RaiseException(
          ObValue.sharedException,
          &quot;reflect_acquire failed: '&quot;
            &amp; &quot;argument must be a reflectted object&quot;, loc);
        &lt;*ASSERT FALSE*&gt;
      END;
    EXCEPT
    | SharedObj.Error (atoms) =&gt;
        ObValue.RaiseSharedException(&quot;reflect_acquire: &quot;, atoms, loc);
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, &quot;reflect_acquire: &quot;, loc);
    END;
    RETURN ObValue.valOk;
  END ReflectAcquireLock;

PROCEDURE ReflectReleaseLock (valObj: ObValue.ValObj; loc: SynLocation.T):
  ObValue.Val RAISES {ObValue.Exception} =
  BEGIN
    TRY
      TYPECASE valObj OF
      | ObValue.ValReplObj (obj) =&gt;
          SharedObj.ReleaseGlobalLock(obj.reflect);
      ELSE
        ObValue.RaiseException(
          ObValue.sharedException,
          &quot;reflect_release failed: '&quot;
            &amp; &quot;argument must be a reflectted object&quot;, loc);
        &lt;*ASSERT FALSE*&gt;
      END;
    EXCEPT
    | SharedObj.Error (atoms) =&gt;
        ObValue.RaiseSharedException(&quot;reflect_release: &quot;, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, &quot;reflect_release: &quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
    RETURN ObValue.valOk;
  END ReflectReleaseLock;

PROCEDURE ReflectSetNodeName (name: TEXT; loc: SynLocation.T): ObValue.Val
  RAISES {ObValue.Exception} =
  BEGIN
    TRY
      IF Text.Equal(name, &quot;&quot;) THEN name := ObValue.machineAddress; END;
      SharedObjRT.ExportSpace(name);
      RETURN ObValue.NewText(name);
    EXCEPT
    | SharedObj.Error (atoms) =&gt;
        ObValue.RaiseSharedException(&quot;reflect_setNodeName: &quot;, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, &quot;reflect_setNodeName: &quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END ReflectSetNodeName;

PROCEDURE ReflectDumpState (loc: SynLocation.T)
  RAISES {ObValue.Exception} =
  BEGIN
    TRY
      SharedObjRT.LocalSpace().printState();
    EXCEPT
    | NetObj.Error (atoms) =&gt;
        ObValue.RaiseNetException(&quot;reflect_dumpState: &quot;, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, &quot;reflect_setNodeName: &quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END ReflectDumpState;

PROCEDURE ReflectSetDefaultSequencer (host, name: TEXT; loc: SynLocation.T):
  ObValue.Val RAISES {ObValue.Exception} =
  VAR space: ObjectSpace.T;
  BEGIN
    TRY
      IF Text.Equal(&quot;&quot;, host) THEN
        WITH defhost = Env.Get(&quot;SEQUENCERHOST&quot;) DO
          IF defhost # NIL THEN host := defhost; END;
        END;
      END;
      IF Text.Equal(&quot;&quot;, name) THEN
        WITH defname = Env.Get(&quot;SEQUENCERNAME&quot;) DO
          IF defname # NIL THEN name := defname; END;
        END;
      END;

      IF NOT Text.Equal(&quot;&quot;, host) OR NOT Text.Equal(&quot;&quot;, name) THEN
        space := SharedObjRT.ImportSpace(host, name);
        IF space = NIL THEN
          ObValue.RaiseException(
            ObValue.sharedException,
            &quot;reflect_setDefaultSequencer: node &quot; &amp; name &amp; &quot;@&quot; &amp; host
              &amp; &quot; is unavailable&quot;, loc);
          &lt;*ASSERT FALSE*&gt;
        END;
      ELSE
        space := SharedObjRT.LocalSpace();
      END;
      SharedObjRT.SetDfltSequencer(space);
      RETURN ObValue.valOk;
    EXCEPT
    | SharedObj.Error (atoms) =&gt;
        ObValue.RaiseSharedException(
          &quot;reflect_setDefaultSequencer: &quot;, atoms, loc);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, &quot;reflect_setDefaultSequencer: &quot;, loc);
      &lt;*ASSERT FALSE*&gt;
    END;
  END ReflectSetDefaultSequencer;
*)
BEGIN
END ObBuiltIn.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
