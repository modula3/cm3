<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: obliqlibanim/src/ObLibAnim.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>obliqlibanim/src/ObLibAnim.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright 1991 Digital Equipment Corporation.               
 Distributed only by permission.                             

<P><PRE>MODULE <module><implements><A HREF="ObLibAnim.i3.html">ObLibAnim</A></implements></module>;
IMPORT <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../obliqrt/src/ObLib.i3.html">ObLib</A>, <A HREF="../../obliqrt/src/ObValue.i3.html">ObValue</A>, <A HREF="../../obliqrt/src/ObEval.i3.html">ObEval</A>, <A HREF="../../synloc/src/SynWr.i3.html">SynWr</A>, <A HREF="../../synloc/src/SynLocation.i3.html">SynLocation</A>, <A HREF="../../libm3/src/geometry/Point.i3.html">Point</A>,
<A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../netobj/src/netobjrt/NetObj.i3.html">NetObj</A>, <A HREF="../../libm3/derived/RefList.i3.html">RefList</A>, <A HREF="../../mg/src/R2.i3.html">R2</A>, <A HREF="../../ui/src/vbt/PaintOp.i3.html">PaintOp</A>, <A HREF="../../ui/src/vbt/VBT.i3.html">VBT</A>, <A HREF="#x1">GraphVBT</A>, <A HREF="../../mgkit/src/GraphVBTExtras.i3.html">GraphVBTExtras</A>,
<A HREF="../../mg/src/Animate.i3.html">Animate</A>, <A HREF="../../ui/src/vbt/Trestle.i3.html">Trestle</A>, <A HREF="../../ui/src/vbt/TrestleComm.i3.html">TrestleComm</A>, <A HREF="../../obliqlibui/src/ObLibUI.i3.html">ObLibUI</A>, <A HREF="../../vbtkit/src/color/Color.i3.html">Color</A>, <A HREF="../../mgkit/src/PaintOpAnim.i3.html">PaintOpAnim</A>, <A HREF="../../libm3/src/geometry/Rect.i3.html">Rect</A>, <A HREF="../../mgkit/src/RectsVBT.i3.html">RectsVBT</A>;

  VAR setupDone := FALSE;

  PROCEDURE <A NAME="PackageSetup"><procedure>PackageSetup</procedure></A>() =
  BEGIN
    IF NOT setupDone THEN
      setupDone := TRUE;
      Setup();
    END;
  END PackageSetup;

  PROCEDURE <A NAME="Setup"><procedure>Setup</procedure></A>() =
  BEGIN
    SetupRects();
    SetupGraph();
    SetupZeus();
  END Setup;
</PRE> ============ <CODE>rects</CODE> package ============ 

<P><PRE>TYPE

  RectsCode =
    {Error, New, SetN, Exists, Delete, Draw, Erase, SetColor,
    SetPosition, GetPosition, SetWorld, SetMargin, SetMins, SetBg,
    Show, Hide};

  RectsOpCode =
    ObLib.OpCode OBJECT
        code: RectsCode;
      END;

  PackageRects =
    ObLib.T OBJECT
      OVERRIDES
        Eval:=EvalRects;
      END;

  VAR rectsException: ObValue.ValException;

  PROCEDURE <A NAME="NewRectsOC"><procedure>NewRectsOC</procedure></A>(name: TEXT; arity: INTEGER; code: RectsCode)
    : RectsOpCode =
  BEGIN
    RETURN NEW(RectsOpCode, name:=name, arity:=arity, code:=code);
  END NewRectsOC;

  PROCEDURE <A NAME="SetupRects"><procedure>SetupRects</procedure></A>() =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(RectsCode));
    opCodes^ :=
      OpCodes{
      NewRectsOC(&quot;failure&quot;, -1, RectsCode.Error),
      NewRectsOC(&quot;new&quot;, 0, RectsCode.New),
      NewRectsOC(&quot;setWorld&quot;, 5, RectsCode.SetWorld),
      NewRectsOC(&quot;setMargin&quot;, 5, RectsCode.SetMargin),
      NewRectsOC(&quot;setMins&quot;, 3, RectsCode.SetMins),
      NewRectsOC(&quot;setBg&quot;, 2, RectsCode.SetBg),
      NewRectsOC(&quot;setN&quot;, 3, RectsCode.SetN),
      NewRectsOC(&quot;draw&quot;, 2, RectsCode.Draw),
      NewRectsOC(&quot;erase&quot;, 2, RectsCode.Erase),
      NewRectsOC(&quot;exists&quot;, 2, RectsCode.Exists),
      NewRectsOC(&quot;delete&quot;, 3, RectsCode.Delete),
      NewRectsOC(&quot;setColor&quot;, 4, RectsCode.SetColor),
      NewRectsOC(&quot;setPosition&quot;, 7, RectsCode.SetPosition),
      NewRectsOC(&quot;getPosition&quot;, 2, RectsCode.GetPosition),
      NewRectsOC(&quot;show&quot;, 1, RectsCode.Show),
      NewRectsOC(&quot;hide&quot;, 1, RectsCode.Hide)};
    ObLib.Register(
      NEW(PackageRects, name := &quot;rects&quot;, opCodes:=opCodes));
    rectsException := NEW(ObValue.ValException, name:=&quot;rects_failure&quot;);
    ObValue.InhibitTransmission(TYPECODE(ValRects),
      &quot;rects cannot be transmitted/duplicated&quot;);
  END SetupRects;

  PROCEDURE <A NAME="EvalRects"><procedure>EvalRects</procedure></A>(self: PackageRects; opCode: ObLib.OpCode;
                      &lt;*UNUSED*&gt;arity: ObLib.OpArity; READONLY args: ObValue.ArgArray;
                      &lt;*UNUSED*&gt;temp: BOOLEAN; loc: SynLocation.T)
      : ObValue.Val RAISES {ObValue.Error, ObValue.Exception} =
    VAR rs1: ValRects; int1: INTEGER; bool1: BOOLEAN; clr1: Color.T;
      r1: Rect.T; p1,p2: RectsVBT.RealPoint;
      real1, real2, real3, real4: LONGREAL; ar1: REF ARRAY OF ObValue.Val;
    BEGIN
      TRY
      CASE NARROW(opCode, RectsOpCode).code OF
      | RectsCode.Error =&gt;
          RETURN rectsException;
      | RectsCode.SetWorld =&gt;
          TYPECASE args[1] OF | ValRects(node) =&gt; rs1:=node;
          ELSE ObValue.BadArgType(1,&quot;rects&quot;,self.name,opCode.name,loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[2] OF | ObValue.ValReal(node) =&gt; real1:=node.real;
          ELSE ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[3] OF | ObValue.ValReal(node) =&gt; real2:=node.real;
          ELSE ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[4] OF | ObValue.ValReal(node) =&gt; real3:=node.real;
          ELSE ObValue.BadArgType(4, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[5] OF | ObValue.ValReal(node) =&gt; real4:=node.real;
          ELSE ObValue.BadArgType(5, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          RectsVBT.SetWC(rs1.vbt,
            FLOAT(real1, REAL), FLOAT(real4, REAL),
            FLOAT(real2, REAL), FLOAT(real3, REAL));
          RETURN ObValue.valOk;
      | RectsCode.SetMargin =&gt;
          TYPECASE args[1] OF | ValRects(node) =&gt; rs1:=node;
          ELSE ObValue.BadArgType(1,&quot;rects&quot;,self.name,opCode.name,loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[2] OF | ObValue.ValReal(node) =&gt; real1:=node.real;
          ELSE ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[3] OF | ObValue.ValReal(node) =&gt; real2:=node.real;
          ELSE ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[4] OF | ObValue.ValReal(node) =&gt; real3:=node.real;
          ELSE ObValue.BadArgType(4, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[5] OF | ObValue.ValReal(node) =&gt; real4:=node.real;
          ELSE ObValue.BadArgType(5, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          RectsVBT.SetMargin(rs1.vbt,
            FLOAT(real1, REAL), FLOAT(real4, REAL),
            FLOAT(real2, REAL), FLOAT(real3, REAL));
          RETURN ObValue.valOk;
      | RectsCode.SetMins =&gt;
          TYPECASE args[1] OF | ValRects(node) =&gt; rs1:=node;
          ELSE ObValue.BadArgType(1,&quot;rects&quot;,self.name,opCode.name,loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[2] OF | ObValue.ValReal(node) =&gt; real1:=node.real;
          ELSE ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[3] OF | ObValue.ValReal(node) =&gt; real2:=node.real;
          ELSE ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          RectsVBT.SetMins(rs1.vbt, FLOAT(real1, REAL), FLOAT(real2, REAL));
          RETURN ObValue.valOk;
      | RectsCode.SetBg =&gt;
          TYPECASE args[1] OF | ValRects(node) =&gt; rs1:=node;
          ELSE ObValue.BadArgType(1,&quot;rects&quot;,self.name,opCode.name,loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[2] OF | ObLibUI.ValColor(node) =&gt; clr1:=node.color;
          ELSE ObValue.BadArgType(2, &quot;color&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          RectsVBT.SetBg(rs1.vbt, PaintOp.FromRGB(clr1.r, clr1.g, clr1.b,
              mode:=PaintOp.Mode.Accurate));
          RETURN ObValue.valOk;
      | RectsCode.New =&gt;
          RETURN NEW(ValRects, what:=&quot;&lt;a RectsVBT.T&gt;&quot;, tag := &quot;RectsVBT`T&quot;,
                     picklable:=FALSE, vbt:=NEW(RectsVBT.T).init(),
                     n:=-1, shown:=FALSE);
      | RectsCode.SetN =&gt;
          TYPECASE args[1] OF | ValRects(node) =&gt; rs1:=node;
          ELSE ObValue.BadArgType(1,&quot;rects&quot;,self.name,opCode.name,loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[2] OF | ObValue.ValInt(node) =&gt; int1:=node.int;
          ELSE ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[3] OF | ObValue.ValBool(node) =&gt; bool1:=node.bool;
          ELSE ObValue.BadArgType(3, &quot;bool&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          IF int1&lt;0 THEN
            ObValue.BadArgVal(2, &quot;non-negative&quot;, self.name, opCode.name, loc);&lt;*ASSERT FALSE*&gt;
          END;
          RectsVBT.SetN(rs1.vbt, int1, bool1);
          rs1.n := int1;
          RETURN ObValue.valOk;
      | RectsCode.Exists =&gt;
          TYPECASE args[1] OF | ValRects(node) =&gt; rs1:=node;
          ELSE ObValue.BadArgType(1,&quot;rects&quot;,self.name,opCode.name,loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[2] OF | ObValue.ValInt(node) =&gt; int1:=node.int;
          ELSE ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          IF (int1&lt;0) OR (int1&gt;rs1.n) THEN
            ObValue.BadArgVal(2, &quot;in range&quot;, self.name, opCode.name, loc);&lt;*ASSERT FALSE*&gt;
          END;
          RETURN NEW(ObValue.ValBool, bool:=RectsVBT.Exists(rs1.vbt, int1));
      | RectsCode.Delete =&gt;
          TYPECASE args[1] OF | ValRects(node) =&gt; rs1:=node;
          ELSE ObValue.BadArgType(1,&quot;rects&quot;,self.name,opCode.name,loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[2] OF | ObValue.ValInt(node) =&gt; int1:=node.int;
          ELSE ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[3] OF | ObValue.ValBool(node) =&gt; bool1:=node.bool;
          ELSE ObValue.BadArgType(3, &quot;bool&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          IF int1&lt;0 THEN
            ObValue.BadArgVal(2, &quot;non-negative&quot;, self.name, opCode.name, loc);&lt;*ASSERT FALSE*&gt;
          END;
          RectsVBT.Delete(rs1.vbt, int1, bool1);
          RETURN ObValue.valOk;
      | RectsCode.SetColor =&gt;
          TYPECASE args[1] OF | ValRects(node) =&gt; rs1:=node;
          ELSE ObValue.BadArgType(1,&quot;rects&quot;,self.name,opCode.name,loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[2] OF | ObValue.ValInt(node) =&gt; int1:=node.int;
          ELSE ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[3] OF | ObLibUI.ValColor(node) =&gt; clr1:=node.color;
          ELSE ObValue.BadArgType(3, &quot;color&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[4] OF | ObValue.ValBool(node) =&gt; bool1:=node.bool;
          ELSE ObValue.BadArgType(4, &quot;bool&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          IF (int1&lt;0) OR (int1&gt;rs1.n) THEN
            ObValue.BadArgVal(2, &quot;in range&quot;, self.name, opCode.name, loc);&lt;*ASSERT FALSE*&gt;
          END;
          RectsVBT.Color(rs1.vbt, int1,
            PaintOp.FromRGB(clr1.r, clr1.g, clr1.b,
              mode:=PaintOp.Mode.Accurate),
            bool1);
          RETURN ObValue.valOk;
      | RectsCode.GetPosition =&gt;
          TYPECASE args[1] OF | ValRects(node) =&gt; rs1:=node;
          ELSE ObValue.BadArgType(1,&quot;rects&quot;,self.name,opCode.name,loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[2] OF | ObValue.ValInt(node) =&gt; int1:=node.int;
          ELSE ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          IF (int1&lt;0) OR (int1&gt;rs1.n) THEN
            ObValue.BadArgVal(2, &quot;in range&quot;, self.name, opCode.name, loc);&lt;*ASSERT FALSE*&gt;
          END;
          r1 := RectsVBT.Locate(rs1.vbt, int1);
          p1 := RectsVBT.VBT2WC(rs1.vbt,
                  Point.T{h:=r1.west, v:=r1.north});
          p2 := RectsVBT.VBT2WC(rs1.vbt,
                  Point.T{h:=r1.east, v:=r1.south});
          ar1 := NEW(REF ARRAY OF ObValue.Val, 4);
          ar1^[0] := NEW(ObValue.ValReal, real:=FLOAT(p1.h,LONGREAL), temp:=FALSE);
          ar1^[1] := NEW(ObValue.ValReal, real:=FLOAT(p2.h,LONGREAL), temp:=FALSE);
          ar1^[2] := NEW(ObValue.ValReal, real:=FLOAT(p1.v,LONGREAL), temp:=FALSE);
          ar1^[3] := NEW(ObValue.ValReal, real:=FLOAT(p2.v,LONGREAL), temp:=FALSE);
          RETURN ObValue.NewArray(ar1^);
      | RectsCode.SetPosition =&gt;
          TYPECASE args[1] OF | ValRects(node) =&gt; rs1:=node;
          ELSE ObValue.BadArgType(1,&quot;rects&quot;,self.name,opCode.name,loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[2] OF | ObValue.ValInt(node) =&gt; int1:=node.int;
          ELSE ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[3] OF | ObValue.ValReal(node) =&gt; real1:=node.real;
          ELSE ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[4] OF | ObValue.ValReal(node) =&gt; real2:=node.real;
          ELSE ObValue.BadArgType(4, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[5] OF | ObValue.ValReal(node) =&gt; real3:=node.real;
          ELSE ObValue.BadArgType(5, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[6] OF | ObValue.ValReal(node) =&gt; real4:=node.real;
          ELSE ObValue.BadArgType(6, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[7] OF | ObValue.ValBool(node) =&gt; bool1:=node.bool;
          ELSE ObValue.BadArgType(4, &quot;bool&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          IF (int1&lt;0) OR (int1&gt;rs1.n) THEN
            ObValue.BadArgVal(2, &quot;in range&quot;, self.name, opCode.name, loc);&lt;*ASSERT FALSE*&gt;
          END;
          RectsVBT.Position(rs1.vbt, int1,
            FLOAT(real1, REAL), FLOAT(real4, REAL),
            FLOAT(real2, REAL), FLOAT(real3, REAL),
            bool1);
          RETURN ObValue.valOk;
      | RectsCode.Draw =&gt;
          TYPECASE args[1] OF | ValRects(node) =&gt; rs1:=node;
          ELSE ObValue.BadArgType(1,&quot;rects&quot;,self.name,opCode.name,loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[2] OF | ObValue.ValInt(node) =&gt; int1:=node.int;
          ELSE ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          IF (int1&lt;0) OR (int1&gt;rs1.n) THEN
            ObValue.BadArgVal(2, &quot;in range&quot;, self.name, opCode.name, loc);&lt;*ASSERT FALSE*&gt;
          END;
          RectsVBT.Draw(rs1.vbt, int1);
          RETURN ObValue.valOk;
      | RectsCode.Erase =&gt;
          TYPECASE args[1] OF | ValRects(node) =&gt; rs1:=node;
          ELSE ObValue.BadArgType(1,&quot;rects&quot;,self.name,opCode.name,loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[2] OF | ObValue.ValInt(node) =&gt; int1:=node.int;
          ELSE ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          IF (int1&lt;0) OR (int1&gt;rs1.n) THEN
            ObValue.BadArgVal(2, &quot;in range&quot;, self.name, opCode.name, loc);&lt;*ASSERT FALSE*&gt;
          END;
          RectsVBT.Erase(rs1.vbt, int1);
          RETURN ObValue.valOk;
      | RectsCode.Show =&gt;
          TYPECASE args[1] OF
          | ValRects(node) =&gt;
            IF node.shown THEN
              ObValue.BadArgVal(1, &quot;not already shown&quot;,
                self.name, opCode.name, loc);&lt;*ASSERT FALSE*&gt;
            END;
            node.shown := TRUE;
            Trestle.Install(node.vbt);
            NARROW(node.vbt,RectsVBT.T).redisplay();
          ELSE ObValue.BadArgType(1, &quot;rects&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          RETURN ObValue.valOk;
      | RectsCode.Hide =&gt;
          TYPECASE args[1] OF
          | ValRects(node) =&gt;
            IF node.shown THEN
              node.shown := FALSE;
              Trestle.Delete(node.vbt);
            END;
          ELSE ObValue.BadArgType(1, &quot;rects&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          RETURN ObValue.valOk;
      END;
      EXCEPT
      | TrestleComm.Failure =&gt;
        ObValue.RaiseException(rectsException, opCode.name, loc);
        &lt;*ASSERT FALSE*&gt;
      END;
    END EvalRects;
</PRE> ============ <CODE>graph</CODE> package ============ 

<P><PRE>TYPE

  GraphCode =
    {Error, New, Redisplay, Animate, Clear, SetWorld, SetMargin, SetAspect,
     SetPreferredSize, SetPixelSizeDivisor, VerticesAt, VertexHiLisAt,
     EdgesAt, PolygonsAt, SetClickAction, SetClickReleaseAction,
     SetDoubleClickAction, SetObjectLayer, NewVertex, MoveVertex,
     MoveVertexOnPath, RemoveVertex, VertexToFront, VertexToBack,
     VertexSetSize, VertexSetShape, VertexSetColor, VertexSetFont,
     VertexSetLabel, VertexSetLabelColor, VertexSetBorder,
     VertexSetBorderColor, VertexGetPosition, NewVertexHiLi,
     MoveVertexHiLi, RemoveVertexHiLi, VertexHiLiToFront, VertexHiLiToBack,
     VertexHiLiSetBorder, VertexHiLiSetColor, VertexHiLiGetVertex, NewEdge,
     MoveEdge, MoveEdgeBezier, RemoveEdge, EdgeToFront, EdgeToBack,
     EdgeSetWidth, EdgeSetColor, EdgeSetArrow, EdgeGetVertices,
     EdgeGetControls, NewPolygon, MovePolygon, RemovePolygon,
     PolygonToFront, PolygonToBack, PolygonSetColor, NewFont, DefaultFont,
     NewSpectrum, SetSpectrumColor, SetSpectrumRange, Show, Hide};

  GraphOpCode = ObLib.OpCode OBJECT code: GraphCode;  END;

  PackageGraph = ObLib.T OBJECT OVERRIDES Eval := EvalGraph; END;

PROCEDURE <A NAME="IsVertex"><procedure>IsVertex</procedure></A> (self: ValVertex; other: ObValue.ValAnything): BOOLEAN =
  BEGIN
    TYPECASE other OF
      ValVertex (oth) =&gt; RETURN self.vertex = oth.vertex;
    ELSE
      RETURN FALSE
    END;
  END IsVertex;

PROCEDURE <A NAME="IsVertexHiLi"><procedure>IsVertexHiLi</procedure></A> (self: ValVertexHiLi; other: ObValue.ValAnything):
  BOOLEAN =
  BEGIN
    TYPECASE other OF
      ValVertexHiLi (oth) =&gt; RETURN self.vertexHiLi = oth.vertexHiLi;
    ELSE
      RETURN FALSE
    END;
  END IsVertexHiLi;

PROCEDURE <A NAME="IsEdge"><procedure>IsEdge</procedure></A> (self: ValEdge; other: ObValue.ValAnything): BOOLEAN =
  BEGIN
    TYPECASE other OF
      ValEdge (oth) =&gt; RETURN self.edge = oth.edge;
    ELSE
      RETURN FALSE
    END;
  END IsEdge;

PROCEDURE <A NAME="IsPolygon"><procedure>IsPolygon</procedure></A> (self: ValPolygon; other: ObValue.ValAnything):
  BOOLEAN =
  BEGIN
    TYPECASE other OF
      ValPolygon (oth) =&gt; RETURN self.polygon = oth.polygon;
    ELSE
      RETURN FALSE
    END;
  END IsPolygon;

PROCEDURE <A NAME="IsFont"><procedure>IsFont</procedure></A> (self: ValFont; other: ObValue.ValAnything): BOOLEAN =
  BEGIN
    TYPECASE other OF
      ValFont (oth) =&gt; RETURN self.font = oth.font;
    ELSE
      RETURN FALSE
    END;
  END IsFont;

PROCEDURE <A NAME="IsSpectrum"><procedure>IsSpectrum</procedure></A> (self: ValSpectrum; other: ObValue.ValAnything):
  BOOLEAN =
  BEGIN
    TYPECASE other OF
      ValSpectrum (oth) =&gt; RETURN self.spectrum = oth.spectrum;
    ELSE
      RETURN FALSE
    END;
  END IsSpectrum;

VAR graphException: ObValue.ValException;

PROCEDURE <A NAME="NewGraphOC"><procedure>NewGraphOC</procedure></A> (name: TEXT; arity: INTEGER; code: GraphCode):
  GraphOpCode =
  BEGIN
    RETURN NEW(GraphOpCode, name := name, arity := arity, code := code);
  END NewGraphOC;

PROCEDURE <A NAME="SetupGraph"><procedure>SetupGraph</procedure></A> () =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(GraphCode));
    opCodes^ :=
      OpCodes{
        NewGraphOC(&quot;failure&quot;, -1, GraphCode.Error),
        NewGraphOC(&quot;new&quot;, 0, GraphCode.New),
        NewGraphOC(&quot;redisplay&quot;, 1, GraphCode.Redisplay),
        NewGraphOC(&quot;animate&quot;, 3, GraphCode.Animate),
        NewGraphOC(&quot;clear&quot;, 1, GraphCode.Clear),
        NewGraphOC(&quot;setWorld&quot;, 5, GraphCode.SetWorld),
        NewGraphOC(&quot;setMargin&quot;, 2, GraphCode.SetMargin),
        NewGraphOC(&quot;setAspect&quot;, 2, GraphCode.SetAspect),
        NewGraphOC(&quot;setPreferredSize&quot;, 3, GraphCode.SetPreferredSize),
        NewGraphOC(&quot;setPixelSizeDivisor&quot;, 3, GraphCode.SetPixelSizeDivisor),
        NewGraphOC(&quot;verticesAt&quot;, 5, GraphCode.VerticesAt),
        NewGraphOC(&quot;vertexHiLisAt&quot;, 5, GraphCode.VertexHiLisAt),
        NewGraphOC(&quot;edgesAt&quot;, 5, GraphCode.EdgesAt),
        NewGraphOC(&quot;polygonsAt&quot;, 5, GraphCode.PolygonsAt),
        NewGraphOC(&quot;setClickAction&quot;, 2, GraphCode.SetClickAction),
        NewGraphOC(
          &quot;setClickReleaseAction&quot;, 2, GraphCode.SetClickReleaseAction),
        NewGraphOC(
          &quot;setDoubleClickAction&quot;, 2, GraphCode.SetDoubleClickAction),
        NewGraphOC(&quot;setObjectLayer&quot;, 2, GraphCode.SetObjectLayer),

        NewGraphOC(&quot;newVertex&quot;, 1, GraphCode.NewVertex),
        NewGraphOC(&quot;moveVertex&quot;, 4, GraphCode.MoveVertex),
        NewGraphOC(&quot;moveVertexOnPath&quot;, 2, GraphCode.MoveVertexOnPath),
        NewGraphOC(&quot;removeVertex&quot;, 1, GraphCode.RemoveVertex),
        NewGraphOC(&quot;vertexToFront&quot;, 1, GraphCode.VertexToFront),
        NewGraphOC(&quot;vertexToBack&quot;, 1, GraphCode.VertexToBack),
        NewGraphOC(&quot;setVertexSize&quot;, 3, GraphCode.VertexSetSize),
        NewGraphOC(&quot;setVertexShape&quot;, 2, GraphCode.VertexSetShape),
        NewGraphOC(&quot;setVertexColor&quot;, 2, GraphCode.VertexSetColor),
        NewGraphOC(&quot;setVertexFont&quot;, 2, GraphCode.VertexSetFont),
        NewGraphOC(&quot;setVertexLabel&quot;, 2, GraphCode.VertexSetLabel),
        NewGraphOC(&quot;setVertexLabelColor&quot;, 2, GraphCode.VertexSetLabelColor),
        NewGraphOC(&quot;setVertexBorder&quot;, 2, GraphCode.VertexSetBorder),
        NewGraphOC(
          &quot;setVertexBorderColor&quot;, 2, GraphCode.VertexSetBorderColor),
        NewGraphOC(&quot;getVertexPosition&quot;, 1, GraphCode.VertexGetPosition),

        NewGraphOC(&quot;newVertexHiLi&quot;, 1, GraphCode.NewVertexHiLi),
        NewGraphOC(&quot;moveVertexHiLi&quot;, 3, GraphCode.MoveVertexHiLi),
        NewGraphOC(&quot;removeVertexHiLi&quot;, 1, GraphCode.RemoveVertexHiLi),
        NewGraphOC(&quot;vertexHiLiToFront&quot;, 1, GraphCode.VertexHiLiToFront),
        NewGraphOC(&quot;vertexHiLiToBack&quot;, 1, GraphCode.VertexHiLiToBack),
        NewGraphOC(&quot;setVertexHiLiColor&quot;, 2, GraphCode.VertexHiLiSetColor),
        NewGraphOC(&quot;setVertexHiLiBorder&quot;, 3, GraphCode.VertexHiLiSetBorder),
        NewGraphOC(&quot;getVertexHiLiVertex&quot;, 1, GraphCode.VertexHiLiGetVertex),

        NewGraphOC(&quot;newEdge&quot;, 2, GraphCode.NewEdge),
        NewGraphOC(&quot;moveEdge&quot;, 4, GraphCode.MoveEdge),
        NewGraphOC(&quot;moveEdgeBezier&quot;, 6, GraphCode.MoveEdgeBezier),
        NewGraphOC(&quot;removeEdge&quot;, 1, GraphCode.RemoveEdge),
        NewGraphOC(&quot;edgeToFront&quot;, 1, GraphCode.EdgeToFront),
        NewGraphOC(&quot;edgeToBack&quot;, 1, GraphCode.EdgeToBack),
        NewGraphOC(&quot;setEdgeWidth&quot;, 2, GraphCode.EdgeSetWidth),
        NewGraphOC(&quot;setEdgeColor&quot;, 2, GraphCode.EdgeSetColor),
        NewGraphOC(&quot;setEdgeArrows&quot;, 3, GraphCode.EdgeSetArrow),
        NewGraphOC(&quot;getEdgeVertices&quot;, 1, GraphCode.EdgeGetVertices),
        NewGraphOC(&quot;getEdgeControls&quot;, 1, GraphCode.EdgeGetControls),

        NewGraphOC(&quot;newPolygon&quot;, 1, GraphCode.NewPolygon),
        NewGraphOC(&quot;movePolygon&quot;, 3, GraphCode.MovePolygon),
        NewGraphOC(&quot;removePolygon&quot;, 1, GraphCode.RemovePolygon),
        NewGraphOC(&quot;polygonToFront&quot;, 1, GraphCode.PolygonToFront),
        NewGraphOC(&quot;polygonToBack&quot;, 1, GraphCode.PolygonToBack),
        NewGraphOC(&quot;setPolygonColor&quot;, 2, GraphCode.PolygonSetColor),

        NewGraphOC(&quot;newFont&quot;, 6, GraphCode.NewFont),
        NewGraphOC(&quot;defaultFont&quot;, -1, GraphCode.DefaultFont),

        NewGraphOC(&quot;newSpectrum&quot;, 1, GraphCode.NewSpectrum),
        NewGraphOC(&quot;setSpectrumColor&quot;, 2, GraphCode.SetSpectrumColor),
        NewGraphOC(&quot;setSpectrumRange&quot;, 2, GraphCode.SetSpectrumRange),

        NewGraphOC(&quot;show&quot;, 1, GraphCode.Show),
        NewGraphOC(&quot;hide&quot;, 1, GraphCode.Hide)};
    ObLib.Register(NEW(PackageGraph, name := &quot;graph&quot;, opCodes := opCodes));
    graphException := NEW(ObValue.ValException, name := &quot;graph_failure&quot;);
    ObValue.InhibitTransmission(
      TYPECODE(ValGraph), &quot;graphs cannot be transmitted/duplicated&quot;);
    ObValue.InhibitTransmission(
      TYPECODE(ValVertex), &quot;vetices cannot be transmitted/duplicated&quot;);
    ObValue.InhibitTransmission(
      TYPECODE(ValVertexHiLi),
      &quot;vertex hilights cannot be transmitted/duplicated&quot;);
    ObValue.InhibitTransmission(
      TYPECODE(ValEdge), &quot;edges cannot be transmitted/duplicated&quot;);
    ObValue.InhibitTransmission(
      TYPECODE(ValPolygon), &quot;polygons cannot be transmitted/duplicated&quot;);
    ObValue.InhibitTransmission(
      TYPECODE(ValFont), &quot;fonts cannot be transmitted/duplicated&quot;);
    ObValue.InhibitTransmission(
      TYPECODE(ValSpectrum), &quot;spectrums cannot be transmitted/duplicated&quot;);
  END SetupGraph;

PROCEDURE <A NAME="EvalGraph"><procedure>EvalGraph</procedure></A> (                    self  : PackageGraph;
                                         opCode: ObLib.OpCode;
                     &lt;*UNUSED*&gt;          arity : ObLib.OpArity;
                                READONLY args  : ObValue.ArgArray;
                     &lt;*UNUSED*&gt;          temp  : BOOLEAN;
                                         loc   : SynLocation.T     ):
  ObValue.Val RAISES {ObValue.Error, ObValue.Exception} =
  VAR
    gr1                       : Graph;
    gr0                       : ValGraph;
    v1, v2, v3, v4            : GraphVBT.Vertex;
    e1                        : GraphVBT.Edge;
    p1                        : GraphVBT.Polygon;
    real1, real2, real3, real4: LONGREAL;
    list                      : RefList.T;
    size                      : INTEGER;
    bool1, bool2              : BOOLEAN;
    text1, text2, text3, text4: TEXT;
    vh1                       : GraphVBT.VertexHighlight;
    font1                     : GraphVBT.WorldFont;
    fun1                      : ObValue.Val;
    int1, int2                : INTEGER;
    sp1                       : ValSpectrum;
    moveClosure               : MoveClosure;
    cl1                       : ObLibUI.ValColor;
    array1, ar1               : REF ARRAY OF ObValue.Val;
    rl1                       : RefList.T;
  BEGIN
    TRY
      CASE NARROW(opCode, GraphOpCode).code OF
      | GraphCode.Error =&gt; RETURN graphException;
      | GraphCode.New =&gt;
          gr1 := NEW(Graph, clickAction := NIL, clickReleaseAction := NIL,
                     doubleClickAction := NIL).init();
          gr0 :=
            NEW(ValGraph, what := &quot;&lt;a GraphVBT.T&gt;&quot;, picklable := FALSE,
                tag := &quot;GraphVBT`T&quot;, shown := FALSE);
          gr1.valGraph := gr0;
          gr0.vbt := gr1;
          RETURN gr0;
      | GraphCode.Redisplay =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          gr1.redisplay();
          RETURN ObValue.valOk;
      | GraphCode.Animate =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValReal (node) =&gt; real2 := node.real;
          ELSE
            ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          Animate.SetDuration(1.0);
          Animate.ResetATime();
          gr1.animate(FLOAT(real1), FLOAT(real2));
          RETURN ObValue.valOk;
      | GraphCode.Clear =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          gr1.clear();
          RETURN ObValue.valOk;
      | GraphCode.SetWorld =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValReal (node) =&gt; real2 := node.real;
          ELSE
            ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[4] OF
          | ObValue.ValReal (node) =&gt; real3 := node.real;
          ELSE
            ObValue.BadArgType(4, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[5] OF
          | ObValue.ValReal (node) =&gt; real4 := node.real;
          ELSE
            ObValue.BadArgType(5, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          gr1.setWorld(
            GraphVBT.WorldRectangle{w := FLOAT(real1), e := FLOAT(real2),
                                    n := FLOAT(real3), s := FLOAT(real4)});
          RETURN ObValue.valOk;
      | GraphCode.SetMargin =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          gr1.setMargin(FLOAT(real1));
          RETURN ObValue.valOk;
      | GraphCode.SetAspect =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          gr1.setAspect(FLOAT(real1));
          RETURN ObValue.valOk;
      | GraphCode.SetPreferredSize =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValReal (node) =&gt; real2 := node.real;
          ELSE
            ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          gr1.setPreferredSize(R2.T{FLOAT(real1), FLOAT(real2)});
          RETURN ObValue.valOk;
      | GraphCode.SetPixelSizeDivisor =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValInt (node) =&gt; int2 := node.int;
          ELSE
            ObValue.BadArgType(3, &quot;int&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          gr1.setPixelSizeDivisor(
            ARRAY [0 .. 1] OF CARDINAL{MAX(1, int1), MAX(1, int2)});
          RETURN ObValue.valOk;
      | GraphCode.VerticesAt =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValReal (node) =&gt; real2 := node.real;
          ELSE
            ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[4] OF
          | ObValue.ValReal (node) =&gt; real3 := node.real;
          ELSE
            ObValue.BadArgType(4, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[5] OF
          | ObValue.ValReal (node) =&gt; real4 := node.real;
          ELSE
            ObValue.BadArgType(5, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          rl1 := gr1.verticesAt(
                   WorldRectToScreenRect(gr1.world, VBT.Domain(gr1), real1,
                                         real2, real3, real4));
          int1 := RefList.Length(rl1);
          ar1 := NEW(REF ARRAY OF ObValue.Val, int1);
          FOR i := 0 TO int1 - 1 DO
            ar1^[i] := NEW(ValVertex, what := &quot;&lt;a GraphVBT.Vertex&gt;&quot;,
                           tag := &quot;GraphVBT`Vertex&quot;, picklable := FALSE,
                           vertex := rl1.head);
            rl1 := rl1.tail;
          END;
          RETURN ObValue.NewArray(ar1^);
      | GraphCode.VertexHiLisAt =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValReal (node) =&gt; real2 := node.real;
          ELSE
            ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[4] OF
          | ObValue.ValReal (node) =&gt; real3 := node.real;
          ELSE
            ObValue.BadArgType(4, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[5] OF
          | ObValue.ValReal (node) =&gt; real4 := node.real;
          ELSE
            ObValue.BadArgType(5, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          rl1 := gr1.vertexHighlightsAt(
                   WorldRectToScreenRect(gr1.world, VBT.Domain(gr1), real1,
                                         real2, real3, real4));
          int1 := RefList.Length(rl1);
          ar1 := NEW(REF ARRAY OF ObValue.Val, int1);
          FOR i := 0 TO int1 - 1 DO
            ar1^[i] :=
              NEW(ValVertexHiLi, what := &quot;&lt;a GraphVBT.VertexHighlight&gt;&quot;,
                  tag := &quot;GraphVBT`VertexHighlight&quot;, picklable := FALSE,
                  vertexHiLi := rl1.head);
            rl1 := rl1.tail;
          END;
          RETURN ObValue.NewArray(ar1^);
      | GraphCode.EdgesAt =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValReal (node) =&gt; real2 := node.real;
          ELSE
            ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[4] OF
          | ObValue.ValReal (node) =&gt; real3 := node.real;
          ELSE
            ObValue.BadArgType(4, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[5] OF
          | ObValue.ValReal (node) =&gt; real4 := node.real;
          ELSE
            ObValue.BadArgType(5, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          rl1 :=
            gr1.edgesAt(WorldRectToScreenRect(gr1.world, VBT.Domain(gr1),
                                              real1, real2, real3, real4));
          int1 := RefList.Length(rl1);
          ar1 := NEW(REF ARRAY OF ObValue.Val, int1);
          FOR i := 0 TO int1 - 1 DO
            ar1^[i] := NEW(ValEdge, what := &quot;&lt;a GraphVBT.Edge&gt;&quot;,
                           tag := &quot;GraphVBT`Edge&quot;, picklable := FALSE,
                           edge := rl1.head);
            rl1 := rl1.tail;
          END;
          RETURN ObValue.NewArray(ar1^);
      | GraphCode.PolygonsAt =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValReal (node) =&gt; real2 := node.real;
          ELSE
            ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[4] OF
          | ObValue.ValReal (node) =&gt; real3 := node.real;
          ELSE
            ObValue.BadArgType(4, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[5] OF
          | ObValue.ValReal (node) =&gt; real4 := node.real;
          ELSE
            ObValue.BadArgType(5, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          rl1 := gr1.polygonsAt(
                   WorldRectToScreenRect(gr1.world, VBT.Domain(gr1), real1,
                                         real2, real3, real4));
          int1 := RefList.Length(rl1);
          ar1 := NEW(REF ARRAY OF ObValue.Val, int1);
          FOR i := 0 TO int1 - 1 DO
            ar1^[i] := NEW(ValPolygon, what := &quot;&lt;a GraphVBT.Polygon&gt;&quot;,
                           tag := &quot;GraphVBT`Polygon&quot;, picklable := FALSE,
                           polygon := rl1.head);
            rl1 := rl1.tail;
          END;
          RETURN ObValue.NewArray(ar1^);
      | GraphCode.SetClickAction =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValFun (node) =&gt; fun1 := node;
          ELSE
            ObValue.BadArgType(2, &quot;procedure&quot;, self.name, opCode.name, loc);
          END;
          gr1.clickAction := fun1;
          RETURN ObValue.valOk;
      | GraphCode.SetClickReleaseAction =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValFun (node) =&gt; fun1 := node;
          ELSE
            ObValue.BadArgType(2, &quot;procedure&quot;, self.name, opCode.name, loc);
          END;
          gr1.clickReleaseAction := fun1;
          RETURN ObValue.valOk;
      | GraphCode.SetDoubleClickAction =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValFun (node) =&gt; fun1 := node;
          ELSE
            ObValue.BadArgType(2, &quot;procedure&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          gr1.doubleClickAction := fun1;
          RETURN ObValue.valOk;
      | GraphCode.SetObjectLayer =&gt;
          TYPECASE args[2] OF
          | ObValue.ValInt (node) =&gt; int1 := node.int;
          ELSE
            ObValue.BadArgType(2, &quot;int&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt;
              node.vertex.toFront(VAL(int1, GraphVBT.ZOrder));
          | ValVertexHiLi (node) =&gt;
              node.vertexHiLi.toFront(VAL(int1, GraphVBT.ZOrder));
          | ValEdge (node) =&gt;
              node.edge.toFront(VAL(int1, GraphVBT.ZOrder));
          | ValPolygon (node) =&gt;
              node.polygon.toFront(VAL(int1, GraphVBT.ZOrder));
          ELSE
            ObValue.BadArgType(
              1, &quot;graph object&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          RETURN ObValue.valOk;

      | GraphCode.NewVertex =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          v1 := NEW(GraphVBT.Vertex, graph := gr1).init();
          RETURN NEW(ValVertex, what := &quot;&lt;a GraphVBT.Vertex&gt;&quot;,
                     tag := &quot;GraphVBT`Vertex&quot;, picklable := FALSE,
                     vertex := v1);
      | GraphCode.MoveVertex =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValReal (node) =&gt; real2 := node.real;
          ELSE
            ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[4] OF
          | ObValue.ValBool (node) =&gt; bool1 := node.bool;
          ELSE
            ObValue.BadArgType(4, &quot;bool&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          v1.move(R2.T{FLOAT(real1), FLOAT(real2)}, bool1, 0.0, 1.0, NIL);
          RETURN ObValue.valOk;
      | GraphCode.MoveVertexOnPath =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValFun (node) =&gt; fun1 := node;
          ELSE
            ObValue.BadArgType(2, &quot;procedure&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          moveClosure := NEW(MoveClosure, fun := fun1, location := loc);
          (* -- Sets the final vertex position by calling the obliq
             procedure at time 1.0. *)
          v1.move(moveClosure.pos(1.0), TRUE, 0.0, 1.0, moveClosure);
          RETURN ObValue.valOk;
      | GraphCode.RemoveVertex =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          v1.remove();
          RETURN ObValue.valOk;
      | GraphCode.VertexToFront =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          v1.toFront();
          RETURN ObValue.valOk;
      | GraphCode.VertexToBack =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          v1.toBack();
          RETURN ObValue.valOk;
      | GraphCode.VertexSetSize =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValReal (node) =&gt; real2 := node.real;
          ELSE
            ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          v1.setSize(R2.T{FLOAT(real1), FLOAT(real2)});
          RETURN ObValue.valOk;
      | GraphCode.VertexSetShape =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          IF Text.Equal(text1, &quot;rectangle&quot;) THEN
            v1.setShape(GraphVBT.VertexShape.Rectangle);
          ELSIF Text.Equal(text1, &quot;ellipse&quot;) THEN
            v1.setShape(GraphVBT.VertexShape.Ellipse);
          ELSE
            ObValue.BadArgVal(2, &quot;\&quot;rectangle\&quot; or \&quot;ellipse\&quot;&quot;, self.name,
                              opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          RETURN ObValue.valOk;
      | GraphCode.VertexSetColor =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          v1.setColor(
            ExtractColor(args[2], 2, self.name, opCode.name, loc));
          RETURN ObValue.valOk;
      | GraphCode.VertexSetFont =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ValFont (node) =&gt; font1 := node.font;
          ELSE
            ObValue.BadArgType(2, &quot;font&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          v1.setFont(font1);
          RETURN ObValue.valOk;
      | GraphCode.VertexSetLabel =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          v1.setLabel(text1);
          RETURN ObValue.valOk;
      | GraphCode.VertexSetLabelColor =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          v1.setFontColor(
            ExtractColor(args[2], 2, self.name, opCode.name, loc));
          RETURN ObValue.valOk;
      | GraphCode.VertexSetBorder =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          v1.setBorder(FLOAT(real1));
          RETURN ObValue.valOk;
      | GraphCode.VertexSetBorderColor =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          (* -- v1.setBorderColor(ExtractColor(args[2], 2, self.name,
             opCode.name, loc)); *)
          v1.setFontColor(
            ExtractColor(args[2], 2, self.name, opCode.name, loc));
          RETURN ObValue.valOk;
      | GraphCode.VertexGetPosition =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          ar1 := NEW(REF ARRAY OF ObValue.Val, 2);
          ar1^[0] :=
            NEW(ObValue.ValReal, real := FLOAT(v1.pos[0], LONGREAL),
                temp := FALSE);
          ar1^[1] :=
            NEW(ObValue.ValReal, real := FLOAT(v1.pos[1], LONGREAL),
                temp := FALSE);
          RETURN ObValue.NewArray(ar1^);

      | GraphCode.NewVertexHiLi =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          vh1 := NEW(GraphVBT.VertexHighlight, vertex := v1).init();
          RETURN NEW(ValVertexHiLi, what := &quot;&lt;a GraphVBT.VertexHighlight&gt;&quot;,
                     tag := &quot;GraphVBT`VertexHighlight&quot;, picklable := FALSE,
                     vertexHiLi := vh1);
      | GraphCode.MoveVertexHiLi =&gt;
          TYPECASE args[1] OF
          | ValVertexHiLi (node) =&gt; vh1 := node.vertexHiLi;
          ELSE
            ObValue.BadArgType(
              1, &quot;vertexHiLi&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(2, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValBool (node) =&gt; bool1 := node.bool;
          ELSE
            ObValue.BadArgType(3, &quot;bool&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          vh1.move(v1, bool1);
          RETURN ObValue.valOk;
      | GraphCode.RemoveVertexHiLi =&gt;
          TYPECASE args[1] OF
          | ValVertexHiLi (node) =&gt; vh1 := node.vertexHiLi;
          ELSE
            ObValue.BadArgType(
              1, &quot;vertexHiLi&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          vh1.remove();
          RETURN ObValue.valOk;
      | GraphCode.VertexHiLiToFront =&gt;
          TYPECASE args[1] OF
          | ValVertexHiLi (node) =&gt; vh1 := node.vertexHiLi;
          ELSE
            ObValue.BadArgType(
              1, &quot;vertexHiLi&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          vh1.toFront();
          RETURN ObValue.valOk;
      | GraphCode.VertexHiLiToBack =&gt;
          TYPECASE args[1] OF
          | ValVertexHiLi (node) =&gt; vh1 := node.vertexHiLi;
          ELSE
            ObValue.BadArgType(
              1, &quot;vertexHiLi&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          vh1.toBack();
          RETURN ObValue.valOk;
      | GraphCode.VertexHiLiSetColor =&gt;
          TYPECASE args[1] OF
          | ValVertexHiLi (node) =&gt; vh1 := node.vertexHiLi;
          ELSE
            ObValue.BadArgType(
              1, &quot;vertexHiLi&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          vh1.setColor(
            ExtractColor(args[2], 2, self.name, opCode.name, loc));
          RETURN ObValue.valOk;
      | GraphCode.VertexHiLiSetBorder =&gt;
          TYPECASE args[1] OF
          | ValVertexHiLi (node) =&gt; vh1 := node.vertexHiLi;
          ELSE
            ObValue.BadArgType(
              1, &quot;vertexHiLi&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValReal (node) =&gt; real2 := node.real;
          ELSE
            ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          vh1.setBorder(R2.T{FLOAT(real1), FLOAT(real2)});
          RETURN ObValue.valOk;
      | GraphCode.VertexHiLiGetVertex =&gt;
          TYPECASE args[1] OF
          | ValVertexHiLi (node) =&gt; vh1 := node.vertexHiLi;
          ELSE
            ObValue.BadArgType(
              1, &quot;vertexHiLi&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          RETURN NEW(ValVertex, what := &quot;&lt;a GraphVBT.Vertex&gt;&quot;,
                     tag := &quot;GraphVBT`Vertex&quot;, picklable := FALSE,
                     vertex := vh1.vertex);

      | GraphCode.NewEdge =&gt;
          TYPECASE args[1] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(1, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ValVertex (node) =&gt; v2 := node.vertex;
          ELSE
            ObValue.BadArgType(2, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          e1 := NEW(GraphVBT.Edge, vertex0 := v1, vertex1 := v2).init();
          RETURN
            NEW(ValEdge, what := &quot;&lt;a GraphVBT.Edge&gt;&quot;,
                tag := &quot;GraphVBT`Edge&quot;, picklable := FALSE, edge := e1);
      | GraphCode.MoveEdge =&gt;
          TYPECASE args[1] OF
          | ValEdge (node) =&gt; e1 := node.edge;
          ELSE
            ObValue.BadArgType(1, &quot;edge&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(2, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ValVertex (node) =&gt; v2 := node.vertex;
          ELSE
            ObValue.BadArgType(3, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[4] OF
          | ObValue.ValBool (node) =&gt; bool1 := node.bool;
          ELSE
            ObValue.BadArgType(4, &quot;bool&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          e1.move(v1, v2, NIL, NIL, bool1);
          RETURN ObValue.valOk;
      | GraphCode.MoveEdgeBezier =&gt;
          TYPECASE args[1] OF
          | ValEdge (node) =&gt; e1 := node.edge;
          ELSE
            ObValue.BadArgType(1, &quot;edge&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ValVertex (node) =&gt; v1 := node.vertex;
          ELSE
            ObValue.BadArgType(2, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ValVertex (node) =&gt; v2 := node.vertex;
          ELSE
            ObValue.BadArgType(3, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[4] OF
          | ValVertex (node) =&gt; v3 := node.vertex;
          ELSE
            ObValue.BadArgType(4, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[5] OF
          | ValVertex (node) =&gt; v4 := node.vertex;
          ELSE
            ObValue.BadArgType(5, &quot;vertex&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[6] OF
          | ObValue.ValBool (node) =&gt; bool1 := node.bool;
          ELSE
            ObValue.BadArgType(6, &quot;bool&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          e1.move(v1, v2, v3, v4, bool1);
          RETURN ObValue.valOk;
      | GraphCode.RemoveEdge =&gt;
          TYPECASE args[1] OF
          | ValEdge (node) =&gt; e1 := node.edge;
          ELSE
            ObValue.BadArgType(1, &quot;edge&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          e1.remove();
          RETURN ObValue.valOk;
      | GraphCode.EdgeToFront =&gt;
          TYPECASE args[1] OF
          | ValEdge (node) =&gt; e1 := node.edge;
          ELSE
            ObValue.BadArgType(1, &quot;edge&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          e1.toFront();
          RETURN ObValue.valOk;
      | GraphCode.EdgeToBack =&gt;
          TYPECASE args[1] OF
          | ValEdge (node) =&gt; e1 := node.edge;
          ELSE
            ObValue.BadArgType(1, &quot;edge&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          e1.toBack();
          RETURN ObValue.valOk;
      | GraphCode.EdgeSetWidth =&gt;
          TYPECASE args[1] OF
          | ValEdge (node) =&gt; e1 := node.edge;
          ELSE
            ObValue.BadArgType(1, &quot;edge&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          e1.setWidth(FLOAT(real1));
          RETURN ObValue.valOk;
      | GraphCode.EdgeSetColor =&gt;
          TYPECASE args[1] OF
          | ValEdge (node) =&gt; e1 := node.edge;
          ELSE
            ObValue.BadArgType(1, &quot;edge&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          e1.setColor(
            ExtractColor(args[2], 2, self.name, opCode.name, loc));
          RETURN ObValue.valOk;
      | GraphCode.EdgeSetArrow =&gt;
          TYPECASE args[1] OF
          | ValEdge (node) =&gt; e1 := node.edge;
          ELSE
            ObValue.BadArgType(1, &quot;edge&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValBool (node) =&gt; bool1 := node.bool;
          ELSE
            ObValue.BadArgType(2, &quot;bool&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValBool (node) =&gt; bool2 := node.bool;
          ELSE
            ObValue.BadArgType(3, &quot;bool&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          e1.setArrow(ARRAY [0 .. 1] OF BOOLEAN{bool1, bool2});
          RETURN ObValue.valOk;
      | GraphCode.EdgeGetVertices =&gt;
          TYPECASE args[1] OF
          | ValEdge (node) =&gt; e1 := node.edge;
          ELSE
            ObValue.BadArgType(1, &quot;edge&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          ar1 := NEW(REF ARRAY OF ObValue.Val, 2);
          ar1^[0] := NEW(ValVertex, what := &quot;&lt;a GraphVBT.Vertex&gt;&quot;,
                         tag := &quot;GraphVBT`Vertex&quot;, picklable := FALSE,
                         vertex := e1.vertex0);
          ar1^[1] := NEW(ValVertex, what := &quot;&lt;a GraphVBT.Vertex&gt;&quot;,
                         tag := &quot;GraphVBT`Vertex&quot;, picklable := FALSE,
                         vertex := e1.vertex1);
          RETURN ObValue.NewArray(ar1^);
      | GraphCode.EdgeGetControls =&gt;
          TYPECASE args[1] OF
          | ValEdge (node) =&gt; e1 := node.edge;
          ELSE
            ObValue.BadArgType(1, &quot;edge&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          IF (e1.control0 = NIL) OR (e1.control1 = NIL) THEN
            ar1 := NEW(REF ARRAY OF ObValue.Val, 0);
            RETURN ObValue.NewArray(ar1^);
          ELSE
            ar1 := NEW(REF ARRAY OF ObValue.Val, 2);
            ar1^[0] := NEW(ValVertex, what := &quot;&lt;a GraphVBT.Vertex&gt;&quot;,
                           tag := &quot;GraphVBT`Vertex&quot;, picklable := FALSE,
                           vertex := e1.control0);
            ar1^[1] := NEW(ValVertex, what := &quot;&lt;a GraphVBT.Vertex&gt;&quot;,
                           tag := &quot;GraphVBT`Vertex&quot;, picklable := FALSE,
                           vertex := e1.control1);
            RETURN ObValue.NewArray(ar1^);
          END;

      | GraphCode.NewPolygon =&gt;
          TYPECASE args[1] OF
          | ObValue.ValArray (node) =&gt; array1 := node.remote.Obtain();
          ELSE
            ObValue.BadArgType(1, &quot;array&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          size := NUMBER(array1^);
          list := NIL;
          FOR i := 0 TO size - 1 DO
            TYPECASE array1^[(size - 1) - i] OF
            | ValVertex (node) =&gt; list := RefList.Cons(node.vertex, list);
            ELSE
              ObValue.BadArgType(
                1, &quot;array(vertex)&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
            END;
          END;
          p1 := NEW(GraphVBT.Polygon, vertices := list).init();
          RETURN NEW(ValPolygon, what := &quot;&lt;a GraphVBT.Polygon&gt;&quot;,
                     tag := &quot;GraphVBT`Polygon&quot;, picklable := FALSE,
                     polygon := p1);
      | GraphCode.MovePolygon =&gt;
          TYPECASE args[1] OF
          | ValPolygon (node) =&gt; p1 := node.polygon;
          ELSE
            ObValue.BadArgType(1, &quot;polygon&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValArray (node) =&gt; array1 := node.remote.Obtain();
          ELSE
            ObValue.BadArgType(2, &quot;array&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValBool (node) =&gt; bool1 := node.bool;
          ELSE
            ObValue.BadArgType(3, &quot;bool&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          size := NUMBER(array1^);
          list := NIL;
          FOR i := 0 TO size - 1 DO
            TYPECASE array1^[(size - 1) - i] OF
            | ValVertex (node) =&gt; list := RefList.Cons(node.vertex, list);
            ELSE
              ObValue.BadArgType(
                1, &quot;array(vertex)&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
            END;
          END;
          p1.move(list, bool1);
          RETURN ObValue.valOk;
      | GraphCode.RemovePolygon =&gt;
          TYPECASE args[1] OF
          | ValPolygon (node) =&gt; p1 := node.polygon;
          ELSE
            ObValue.BadArgType(1, &quot;polygon&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          p1.remove();
          RETURN ObValue.valOk;
      | GraphCode.PolygonToFront =&gt;
          TYPECASE args[1] OF
          | ValPolygon (node) =&gt; p1 := node.polygon;
          ELSE
            ObValue.BadArgType(1, &quot;polygon&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          p1.toFront();
          RETURN ObValue.valOk;
      | GraphCode.PolygonToBack =&gt;
          TYPECASE args[1] OF
          | ValPolygon (node) =&gt; p1 := node.polygon;
          ELSE
            ObValue.BadArgType(1, &quot;polygon&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          p1.toBack();
          RETURN ObValue.valOk;
      | GraphCode.PolygonSetColor =&gt;
          TYPECASE args[1] OF
          | ValPolygon (node) =&gt; p1 := node.polygon;
          ELSE
            ObValue.BadArgType(1, &quot;polygon&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          p1.setColor(
            ExtractColor(args[2], 2, self.name, opCode.name, loc));
          RETURN ObValue.valOk;

      | GraphCode.NewFont =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValText (node) =&gt; text1 := node.text;
          ELSE
            ObValue.BadArgType(2, &quot;text&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[3] OF
          | ObValue.ValReal (node) =&gt; real1 := node.real;
          ELSE
            ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[4] OF
          | ObValue.ValText (node) =&gt; text2 := node.text;
          ELSE
            ObValue.BadArgType(4, &quot;text&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[5] OF
          | ObValue.ValText (node) =&gt; text3 := node.text;
          ELSE
            ObValue.BadArgType(5, &quot;text&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[6] OF
          | ObValue.ValText (node) =&gt; text4 := node.text;
          ELSE
            ObValue.BadArgType(6, &quot;text&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          font1 := gr1.font(text1, FLOAT(real1), ExtractSlant(text2),
                            text3, text4);
          RETURN NEW(ValFont, what := &quot;&lt;a GraphVBT.WorldFont&gt;&quot;,
                     tag := &quot;GraphVBT`WorldFont&quot;, picklable := FALSE,
                     font := font1);
      | GraphCode.DefaultFont =&gt;
          RETURN NEW(ValFont, what := &quot;&lt;a GraphVBT.WorldFont&gt;&quot;,
                     tag := &quot;GraphVBT`WorldFont&quot;, picklable := FALSE,
                     font := GraphVBT.DefaultFont);

      | GraphCode.NewSpectrum =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt; gr1 := node.vbt;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          RETURN NEW(ValSpectrum, what := &quot;&lt;a GraphVBT.Spectrum&gt;&quot;,
                     tag := &quot;GraphVBT`Spectrum&quot;, picklable := FALSE,
                     graph := gr1,
                     spectrum := NEW(PaintOpAnim.T).init(Color.Black));
      | GraphCode.SetSpectrumColor =&gt;
          TYPECASE args[1] OF
          | ValSpectrum (node) =&gt; sp1 := node;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObLibUI.ValColor (node) =&gt; cl1 := node;
          ELSE
            ObValue.BadArgType(2, &quot;color&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          sp1.spectrum.set(sp1.graph, cl1.color);
          RETURN ObValue.valOk;
      | GraphCode.SetSpectrumRange =&gt;
          TYPECASE args[1] OF
          | ValSpectrum (node) =&gt; sp1 := node;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          TYPECASE args[2] OF
          | ObValue.ValFun (node) =&gt; fun1 := node;
          ELSE
            ObValue.BadArgType(2, &quot;procedure&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          sp1.spectrum.animate(
            sp1.graph, NEW(SpectrumClosure, fun := fun1, location := loc));
          RETURN ObValue.valOk;

      | GraphCode.Show =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt;
              IF node.shown THEN
                ObValue.BadArgVal(
                  1, &quot;not already shown&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
              END;
              node.shown := TRUE;
              Trestle.Install(node.vbt);
              NARROW(node.vbt, GraphVBT.T).redisplay();
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          RETURN ObValue.valOk;
      | GraphCode.Hide =&gt;
          TYPECASE args[1] OF
          | ValGraph (node) =&gt;
              IF node.shown THEN
                node.shown := FALSE;
                Trestle.Delete(node.vbt);
              END;
          ELSE
            ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
          END;
          RETURN ObValue.valOk;
      ELSE
        ObValue.BadOp(self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
      END;
    EXCEPT
    | TrestleComm.Failure =&gt;
        ObValue.RaiseException(graphException, opCode.name, loc); &lt;*ASSERT FALSE*&gt;
    | NetObj.Error (atoms) =&gt;
        ObValue.RaiseNetException(
          self.name &amp; &quot;_&quot; &amp; opCode.name, atoms, loc); &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, self.name &amp; &quot;_&quot; &amp; opCode.name, loc); &lt;*ASSERT FALSE*&gt;
    END;
  END EvalGraph;

TYPE
  SpectrumClosure = PaintOpAnim.Animation OBJECT
                      fun     : ObValue.ValFun;
                      location: SynLocation.T;
                    OVERRIDES
                      rgb := SpectrumRangeClosure;
                    END;

PROCEDURE <A NAME="SpectrumRangeClosure"><procedure>SpectrumRangeClosure</procedure></A> (self: SpectrumClosure; t: REAL): Color.T
  RAISES {} =
  (* Can't produce any good error messages because it must raise {} *)
  VAR
    v   : ObValue.Val;
    args: ARRAY [0 .. 0] OF ObValue.Val;
  BEGIN
    TRY
      args[0] :=
        NEW(ObValue.ValReal, real := FLOAT(t, LONGREAL), temp := FALSE);
      v := ObEval.Call(self.fun, args, self.location);
      TYPECASE v OF
      | ObLibUI.ValColor (node) =&gt; RETURN node.color;
      | ValSpectrum (node) =&gt; RETURN node.spectrum.get();
      ELSE
        ObValue.RaiseError(
          &quot;argument of graph_setSpectrumRange must return a color&quot;,
          self.location);        &lt;*ASSERT FALSE*&gt;
      END;
    EXCEPT
    | ObValue.Error (packet) =&gt;
        SynWr.Text(
          SynWr.out,
          &quot;*** A Modula3 callback to Obliq caused an Obliq error: ***\n&quot;);
        ObValue.ErrorMsg(SynWr.out, packet);
        SynWr.Flush(SynWr.out);
        RETURN Color.Black;
    | ObValue.Exception (packet) =&gt;
        SynWr.Text(
          SynWr.out,
          &quot;*** A Modula3 callback to Obliq caused an Obliq exception: ***\n&quot;);
        ObValue.ExceptionMsg(SynWr.out, packet);
        SynWr.Flush(SynWr.out);
        RETURN Color.Black;
    END;
  END SpectrumRangeClosure;

TYPE
  MoveClosure = GraphVBT.AnimationPath OBJECT
                  fun     : ObValue.ValFun;
                  location: SynLocation.T;
                OVERRIDES
                  pos := MoveOnPathClosure;
                END;

PROCEDURE <A NAME="MoveOnPathClosure"><procedure>MoveOnPathClosure</procedure></A> (self: MoveClosure; t: REAL): R2.T RAISES {} =
  (* Can't produce any good error messages because it must raise {} *)
  VAR
    v, vx, vy: ObValue.Val;
    rx, ry   : REAL;
    args     : ARRAY [0 .. 0] OF ObValue.Val;
  BEGIN
    TRY
      args[0] :=
        NEW(ObValue.ValReal, real := FLOAT(t, LONGREAL), temp := FALSE);
      v := ObEval.Call(self.fun, args, self.location);
      TYPECASE v OF
      | ObValue.ValArray (node) =&gt;
          TRY
            vx := node.remote.Get(0);
            vy := node.remote.Get(1);
          EXCEPT
          | ObValue.ServerError (msg) =&gt;
              ObValue.RaiseError(msg, self.location);
          | NetObj.Error (atoms) =&gt;
              ObValue.RaiseNetException(
                &quot;on remote array access&quot;, atoms, self.location);
          | Thread.Alerted =&gt;
              ObValue.RaiseException(
                ObValue.threadAlerted, &quot;on remote array access&quot;,
                self.location);
          END;
      ELSE
        ObValue.RaiseError(
          &quot;argument of graph_moveOnPath must return an array(2,real)&quot;,
          self.location);
      END;
      TYPECASE vx OF
      | ObValue.ValReal (node) =&gt; rx := FLOAT(node.real, REAL);
      ELSE
        ObValue.RaiseError(
          &quot;argument of graph_moveOnPath must return an array(2,real)&quot;,
          self.location);
      END;
      TYPECASE vy OF
      | ObValue.ValReal (node) =&gt; ry := FLOAT(node.real, REAL);
      ELSE
        ObValue.RaiseError(
          &quot;argument of graph_moveOnPath must return an array(2,real)&quot;,
          self.location);
      END;
      RETURN R2.T{rx, ry};
    EXCEPT
    | ObValue.Error (packet) =&gt;
        SynWr.Text(
          SynWr.out,
          &quot;*** A Modula3 callback to Obliq caused an Obliq error: ***\n&quot;);
        ObValue.ErrorMsg(SynWr.out, packet);
        SynWr.Flush(SynWr.out);
        RETURN R2.T{0.0, 0.0};
    | ObValue.Exception (packet) =&gt;
        SynWr.Text(
          SynWr.out,
          &quot;*** A Modula3 callback to Obliq caused an Obliq exception: ***\n&quot;);
        ObValue.ExceptionMsg(SynWr.out, packet);
        SynWr.Flush(SynWr.out);
        RETURN R2.T{0.0, 0.0};
    END;
  END MoveOnPathClosure;

PROCEDURE <A NAME="ExtractColor"><procedure>ExtractColor</procedure></A> (ob          : ObValue.Val;
                        argNo       : INTEGER;
                        name, opName: TEXT;
                        loc         : SynLocation.T): PaintOp.T
  RAISES {ObValue.Error} =
  BEGIN
    TYPECASE ob OF
    | ObLibUI.ValColor (node) =&gt;
        RETURN PaintOp.FromRGB(node.color.r, node.color.g, node.color.b,
                               mode := PaintOp.Mode.Accurate);
    | ValSpectrum (node) =&gt; RETURN node.spectrum.op();
    ELSE
      ObValue.BadArgType(argNo, &quot;color or spectrum&quot;, name, opName, loc); &lt;*ASSERT FALSE*&gt;
    END;
  END ExtractColor;

PROCEDURE <A NAME="ExtractSlant"><procedure>ExtractSlant</procedure></A> (slant: TEXT): GraphVBT.Slant =
  BEGIN
    IF Text.Equal(slant, &quot;Roman&quot;) THEN
      RETURN GraphVBT.Slant.Roman;
    ELSIF Text.Equal(slant, &quot;Italic&quot;) THEN
      RETURN GraphVBT.Slant.Italic;
    ELSIF Text.Equal(slant, &quot;Oblique&quot;) THEN
      RETURN GraphVBT.Slant.Oblique;
    ELSIF Text.Equal(slant, &quot;ReverseItalic&quot;) THEN
      RETURN GraphVBT.Slant.ReverseItalic;
    ELSIF Text.Equal(slant, &quot;ReverseOblique&quot;) THEN
      RETURN GraphVBT.Slant.ReverseOblique;
    ELSIF Text.Equal(slant, &quot;Other&quot;) THEN
      RETURN GraphVBT.Slant.Other;
    ELSIF Text.Equal(slant, &quot;Any&quot;) THEN
      RETURN GraphVBT.Slant.Any;
    ELSE
      RETURN GraphVBT.Slant.Roman;
    END;
  END ExtractSlant;

PROCEDURE <A NAME="Mouse"><procedure>Mouse</procedure></A> (self: Graph; READONLY cd: VBT.MouseRec) =
  VAR
    r2  : R2.T;
    args: ARRAY [0 .. 2] OF ObValue.Val;
  BEGIN
    TRY
      IF (cd.clickType = VBT.ClickType.FirstDown) AND (cd.clickCount = 0) THEN
        IF self.clickAction = NIL THEN RETURN END;
        r2 := GraphVBTExtras.ScreenPtToWorldPos(self, cd.cp.pt);
        args[0] := self.valGraph;
        args[1] := NEW(ObValue.ValReal, real := FLOAT(r2[0], LONGREAL),
                       temp := FALSE);
        args[2] := NEW(ObValue.ValReal, real := FLOAT(r2[1], LONGREAL),
                       temp := FALSE);
        EVAL ObEval.Call(
               self.clickAction, args, self.clickAction.fun.location);
      ELSIF (cd.clickType = VBT.ClickType.LastUp) AND (cd.clickCount &lt;= 1) THEN
        IF self.clickReleaseAction = NIL THEN RETURN END;
        r2 := GraphVBTExtras.ScreenPtToWorldPos(self, cd.cp.pt);
        args[0] := self.valGraph;
        args[1] := NEW(ObValue.ValReal, real := FLOAT(r2[0], LONGREAL),
                       temp := FALSE);
        args[2] := NEW(ObValue.ValReal, real := FLOAT(r2[1], LONGREAL),
                       temp := FALSE);
        EVAL ObEval.Call(self.clickReleaseAction, args,
                         self.clickReleaseAction.fun.location);
      ELSIF (cd.clickType = VBT.ClickType.FirstDown)
              AND (cd.clickCount = 2) THEN
        IF self.doubleClickAction = NIL THEN RETURN END;
        r2 := GraphVBTExtras.ScreenPtToWorldPos(self, cd.cp.pt);
        args[0] := self.valGraph;
        args[1] := NEW(ObValue.ValReal, real := FLOAT(r2[0], LONGREAL),
                       temp := FALSE);
        args[2] := NEW(ObValue.ValReal, real := FLOAT(r2[1], LONGREAL),
                       temp := FALSE);
        EVAL ObEval.Call(self.doubleClickAction, args,
                         self.doubleClickAction.fun.location);
      END;
    EXCEPT
    | ObValue.Error (packet) =&gt;
        SynWr.Text(
          SynWr.out,
          &quot;*** a graph_ click action caused an Obliq error: ***\n&quot;);
        ObValue.ErrorMsg(SynWr.out, packet);
        SynWr.Flush(SynWr.out);
    | ObValue.Exception (packet) =&gt;
        SynWr.Text(
          SynWr.out,
          &quot;*** a graph_ click action caused an Obliq exception: ***\n&quot;);
        ObValue.ExceptionMsg(SynWr.out, packet);
        SynWr.Flush(SynWr.out);
    END;
  END Mouse;

PROCEDURE <A NAME="WorldRectToScreenRect"><procedure>WorldRectToScreenRect</procedure></A> (world     : GraphVBT.WorldRectangle;
                                 domain    : Rect.T;
                                 w, e, n, s: LONGREAL                 ):
  Rect.T =
  VAR
    domainWidth, domainHeight, worldWidth, worldHeight: REAL;
    r                                                 : Rect.T;
  BEGIN
    domainWidth := FLOAT(domain.east) - FLOAT(domain.west);
    domainHeight := FLOAT(domain.south) - FLOAT(domain.north);
    worldWidth := world.e - world.w;
    worldHeight := world.s - world.n;
    IF (worldWidth = 0.0) OR (worldHeight = 0.0) THEN
      RETURN Rect.Empty
    END;
    r := Rect.T{
           west := domain.west + ROUND((FLOAT(w) - world.w) * domainWidth
                                         / worldWidth), east :=
           domain.west
             + ROUND((FLOAT(e) - world.w) * domainWidth / worldWidth),
           north := domain.north + ROUND((FLOAT(n) - world.n)
                                           * domainHeight / worldHeight),
           south := domain.north + ROUND((FLOAT(s) - world.n)
                                           * domainHeight / worldHeight)};
    IF r.east = r.west THEN r.east := r.east + 1 END;
    IF r.north = r.south THEN r.south := r.south + 1 END;
    RETURN r;
  END WorldRectToScreenRect;
</PRE> ============ <CODE>zeus</CODE> package ============ 

<P><PRE>TYPE

  ZeusCode =
    {Error, Animate};

  ZeusOpCode =
    ObLib.OpCode OBJECT
        code: ZeusCode;
      END;

  PackageZeus =
    ObLib.T OBJECT
      OVERRIDES
        Eval:=EvalZeus;
      END;

  VAR zeusException: ObValue.ValException;

  PROCEDURE <A NAME="SetupZeus"><procedure>SetupZeus</procedure></A>() =
  TYPE OpCodes = ARRAY OF ObLib.OpCode;
  VAR opCodes: REF OpCodes;
  BEGIN
    opCodes := NEW(REF OpCodes, NUMBER(ZeusCode));
    opCodes^ :=
      OpCodes{
      NEW(ZeusOpCode, name:=&quot;failure&quot;, arity:=-1, code:=ZeusCode.Error),
      NEW(ZeusOpCode, name:=&quot;animate&quot;,
          arity:=3, code:=ZeusCode.Animate)
      };
    ObLib.Register(
      NEW(PackageZeus, name:=&quot;zeus&quot;, opCodes:=opCodes));
    zeusException := NEW(ObValue.ValException, name:=&quot;zeus_failure&quot;);
  END SetupZeus;

  PROCEDURE <A NAME="EvalZeus"><procedure>EvalZeus</procedure></A>(self: PackageZeus; opCode: ObLib.OpCode;
                     &lt;*UNUSED*&gt;arity: ObLib.OpArity; READONLY args: ObValue.ArgArray;
                     &lt;*UNUSED*&gt;temp: BOOLEAN; loc: SynLocation.T)
      : ObValue.Val RAISES {ObValue.Error, ObValue.Exception} =
    VAR gr1: Graph; real1, real2: LONGREAL;
    BEGIN
      TRY
      CASE NARROW(opCode, ZeusOpCode).code OF
      | ZeusCode.Error =&gt;
          RETURN graphException;
      | ZeusCode.Animate =&gt;
          TYPECASE args[1] OF | ValGraph(node) =&gt; gr1:=node.vbt;
          ELSE ObValue.BadArgType(1, &quot;graph&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[2] OF | ObValue.ValReal(node) =&gt; real1:=node.real;
          ELSE ObValue.BadArgType(2, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          TYPECASE args[3] OF | ObValue.ValReal(node) =&gt; real2:=node.real;
          ELSE ObValue.BadArgType(3, &quot;real&quot;, self.name, opCode.name, loc); &lt;*ASSERT FALSE*&gt; END;
          gr1.animate(FLOAT(real1), FLOAT(real2));
          RETURN ObValue.valOk;
      END;
      EXCEPT
      | Thread.Alerted =&gt;
          ObValue.RaiseException(ObValue.threadAlerted,
                               self.name&amp;&quot;_&quot;&amp;opCode.name,loc);&lt;*ASSERT FALSE*&gt;
      END;
    END EvalZeus;

BEGIN
END ObLibAnim.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface GraphVBT is in:
</A><UL>
<LI><A HREF="../../fisheye/src/GraphVBT.i3.html#0TOP0">fisheye/src/GraphVBT.i3</A>
<LI><A HREF="../../mgkit/src/GraphVBT.i3.html#0TOP0">mgkit/src/GraphVBT.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
