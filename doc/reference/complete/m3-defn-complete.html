<html><head><title>Modula-3: Language definition (single page)</title><LINK HREF="../../../normal.css" REL="stylesheet" TYPE="text/css"></head>

<body>

<h1>Modula-3: Language definition (single page)</h1>
<p>
<b>Designed and written by Luca Cardelli, James Donahue, Lucille
Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson.</b>
</p><p>

</p><blockquote><em>
The language designer should be familiar with many alternative  
features designed by others, and should have excellent judgment in  
choosing the best and rejecting any that are mutually inconsistent...  
One thing he should not do is to include untried ideas of his own.  
His task is consolidation, not innovation.  
---C.A.R. Hoare
</em></blockquote>

<p> The original definition of Modula-3 was given in
<a href="http://www.research.compaq.com/SRC/modula-3/html/bib.html#m3-CDG*88">SRC Research Report 31</a>, 
August 1988. It was revised in
<a href="http://www.research.compaq.com/SRC/modula-3/html/bib.html#m3-CDG*89">report 52</a>,
November 1989. And finally published in
<a href="http://www.research.compaq.com/SRC/modula-3/html/bib.html#SPwM3">Systems Programming with
Modula-3</a>, November 1989.

</p><p> This edition of the language definition is derived from all of the
above. In the few places where it differs from the version published in
<a href="http://www.research.compaq.com/SRC/modula-3/html/bib.html#SPwM3">Systems Programming with
Modula-3</a>, this on-line version is correct. The <a href="http://www.research.compaq.com/SRC/m3defn/html/errata.html">errata</a> to the published version are available.
A <a href="http://www.research.compaq.com/SRC/m3defn/html/index.html">multi-page, hierarchical version</a> of this
language definition is also available.

</p><p> Copyright (C) 1988 Digital Equipment Corporation, Ing. C. Olivetti
and C., SpA.

</p><p> This work may not be copied or reproduced in whole or in part except 
in accordance with this provision.  Permission to copy in whole 
or in part without payment of fee is granted only to licensees 
under (and is subject to the terms and conditions of) the
<a href="http://www.research.digital.com/SRC/m3sources/html/COPYRIGHT.html">Digital License Agreement</a> for SRC Modula-3, as it appears, for example, 
on the Internet at the URL 
<a href="http://www.research.digital.com/SRC/m3sources/html/COPYRIGHT.html"><code>http://www.research.digital.com/SRC/m3sources/html/COPYRIGHT.html</code></a>.
All such whole or partial copies must include the following: a
notice that such copying is by permission of the Systems Research
Center of Digital Equipment Corporation in Palo Alto, California; an
acknowledgment of the authors and individual contributors to the work;
and this copyright notice. All rights reserved.

</p><h2>Contents</h2>

<ul>
<li> <a href="#AcksSect">Acknowledgments</a>
</li><li> <a href="#IntroSect">1. Introduction</a>
<ul>
<li>
<a href="#idx.0">History</a>,
<a href="#idx.4">Perspective</a>,
<a href="#OverviewSect">Overview</a>,
<a href="#FeaturesSect">Features</a>,
<a href="#idx.9">Interfaces</a>,
<a href="#idx.10">Objects</a>,
<a href="#idx.13">Generics</a>,
<a href="#idx.14">Threads</a>,
<a href="#idx.17">Safety</a>,
<a href="#idx.18">Garbage collection</a>,
<a href="#idx.19">Exceptions</a>,
<a href="#TypeSystemSect">Type System</a>,
<a href="#idx.20">Simplicity</a>
</li></ul>
</li><li> <a href="#DefsSect">2.1 Definitions</a>
</li><li> <a href="#TypesSect">2.2 Types</a>
<ul>
<li>
<a href="#OrdinalsSect">Ordinal types</a>,
<a href="#FloatsSect">Floating-point types</a>,
<a href="#ArraysSect">Arrays</a>,
<a href="#RecordsSect">Records</a>,
<a href="#PackedSect">Packed types</a>,
<a href="#SetsSect">Sets</a>,
<a href="#RefsSect">References</a>,
<a href="#ProcsSect">Procedures</a>,
<a href="#ObjectsSect">Objects</a>,
<a href="#SubtypingSect">Subtyping rules</a>,
<a href="#BuiltinsSect">Predeclared opaque types</a>
</li></ul>
</li><li> <a href="#StatementsSect">2.3 Statements</a>
<ul>
<li>
<a href="#AssignmentSect">Assignment</a>,
<a href="#ProcCallSect">Procedure call</a>,
<a href="#ix.92">Eval</a>,
<a href="#BlocksSect">Block statement</a>,
<a href="#SequenceSect">Sequential composition</a>,
<a href="#RaiseSect">RAISE</a>,
<a href="#TryExceptSect">TRY-EXCEPT</a>,
<a href="#TryFinallySect">TRY-FINALLY</a>,
<a href="#LoopSect">LOOP</a>,
<a href="#idx.102">EXIT</a>,
<a href="#ReturnSect">RETURN</a>,
<a href="#IfSect">IF</a>,
<a href="#WhileSect">WHILE</a>,
<a href="#RepeatSect">REPEAT</a>,
<a href="#WithSect">WITH</a>,
<a href="#ForSect">FOR</a>,
<a href="#CaseSect">CASE</a>,
<a href="#TypecaseSect">TYPECASE</a>,
<a href="#LockSect">LOCK</a>,
<a href="#IncDecSect">INC &amp; DEC</a>
</li></ul>
</li><li> <a href="#DeclsSect">2.4 Declarations</a>
<ul>
<li>
<a href="#TypeDeclsSect">Types</a>,
<a href="#idx.122">Constants</a>,
<a href="#VarsSect">Variables</a>,
<a href="#ProcsSect">Procedures</a>,
<a href="#idx.128">Exceptions</a>,
<a href="#OpaqueSect">Opaque types</a>,
<a href="#RevelationsSect">Revelations</a>,
<a href="#RecursiveDeclsSect">Recursive declarations</a>,
</li></ul>
</li><li> <a href="#UnitsSect">2.5 Modules and interfaces</a>
<ul>
<li>
<a href="#ImportsSect">Import statements</a>,
<a href="#IntfsSect">Interfaces</a>,
<a href="#ModsSect">Modules</a>,
<a href="#ExampleSect">Example</a>,
<a href="#GenericsSect">Generics</a>,
<a href="#idx.148">Initialization</a>,
<a href="#SafetySect">Safety</a>
</li></ul>
</li><li> <a href="#ExprsSect">2.6 Expressions</a>
<ul>
<li>
<a href="#ExprConventionsSect">Conventions</a>,
<a href="#idx.153">Operation syntax</a>,
<a href="#DesignatorSect">Designators</a>,
<a href="#NumericLitsSect">Numeric literals</a>,
<a href="#idx.171">Text and character literals</a>,
<a href="#NilSect">NIL</a>,
<a href="#FunctionAppSect">Function application</a>,
<a href="#ConstructorsSect">Set, array, and record constructors</a>,
<a href="#NewSect">NEW</a>,
<a href="#ArithmeticOpsSect">Arithmetic operations</a>,
<a href="#RelationsSect">Relations</a>,
<a href="#BooleanOpsSect">Boolean operations</a>,
<a href="#TypeOpsSect">Type operations</a>,
<a href="#TextOpsSect">Text operations</a>,
<a href="#idx.205">Constant expressions</a>
</li></ul>
</li><li> <a href="#UnsafeSect">2.7 Unsafe operations</a>
</li><li> <a href="#SyntaxSect">2.8 Syntax</a>
<ul>
<li>
<a href="#idx.213">Keywords</a>,
<a href="#idx.214">Reserved identifiers</a>,
<a href="#idx.215">Operators</a>,
<a href="#idx.216">Comments</a>,
<a href="#idx.217">Pragmas</a>,
<a href="#idx.219">Conventions</a>,
<a href="#UnitProdsSect">Compilation units</a>,
<a href="#StmtProdsSect">Statements</a>,
<a href="#TypeProdsSect">Types</a>,
<a href="#ExprProdsSect">Expressions</a>,
<a href="#MiscProdsSect">Miscellaneous</a>,
<a href="#idx.220">Tokens</a>
</li></ul>
</li><li> <a href="#AuthorsSect">About the authors</a>
</li></ul>

<h2><a name="AcksSect">Acknowledgments</a></h2>

<p>
Modula-3 was designed by Luca Cardelli, Jim Donahue, Mick Jordan, Bill
Kalsow, and Greg Nelson, as a joint project by the Digital Equipment
Corporation Systems Research Center and the Olivetti Research Center.
Paul Rovner made many contributions as a founding member of the design
committee.  The language specification was written by Lucille Glassman
and Greg Nelson, under the watchful supervision of the whole committee.
</p><p>
Maurice Wilkes had the inspiration that sparked the project.  
</p><p>
Our technical starting point was Modula-2+, which was designed by Paul
Rovner, Roy Levin, John Wick, Andrew Birrell, Butler Lampson, and Garret
Swart.  We made good use of the ruthlessly complete description of
Modula-2+ in Mary-Claire van Leunen's <em>Modula-2+ User's Manual</em>.
The ideas in the ``+'' part of Modula-2+ were mostly derived from the
Mesa and Cedar languages developed at Xerox PARC.
</p><p>
Niklaus Wirth designed Modula-2, the starting point of our starting
point.  He also reviewed the evolving design and made many valuable
suggestions---not one of which was a suggested addition.  Indeed, he
inspired us with the courage to pull out a number of deep-rooted weeds.
</p><p>
SRC Modula-3 was implemented by Bill Kalsow and Eric Muller.  Olivetti
Modula-3 was implemented by Mick Jordan, Trevor Morris, David Chase,
Steve Glassman, and Marion Sturtevant.
</p><p>
The language and book were greatly improved by the helpful feedback
from Bob Ayers, Andrew Black, Regis Crelier, Dan Craft, Hans Eberle,
John Ellis, Stu Feldman, Michel Gangnet, Lucille Glassman, David
Goldberg, Stephen Harrison, Sam Harbison, Jim Horning, Solange Karsenty,
Mike Kupfer, Butler Lampson, Mark Manasse, Tim Mann, Eliot Moss, Dick
Orgass, Sharon Perl, Norman Ramsey, Lyle Ramshaw, Eric Roberts, Peter
Robinson, Ed Satterthwaite, Jorge Stolfi, Garret Swart, Chuck Thacker,
and Ken Zadeck.
</p><p>
We are grateful for the support of Digital Equipment Corporation in
general, and Bob Taylor and Sam Fuller in particular.
</p><p>

</p><h2><a name="IntroSect">1. Introduction</a></h2>

<blockquote><em>
He that will not apply new remedies must expect new evils: for time is
the greatest innovator, and if time of course alter things to the
worse, and wisdom and counsel shall not alter them to the better, what
shall be the end?
---Francis Bacon
</em></blockquote>
<p>

</p><h3><a name="idx.0">1.1 History</a></h3>
<p>

On November 6th, 1986, Maurice Wilkes wrote to Niklaus Wirth proposing
that the Modula-2+ language be revised and standardized as a successor
to Modula-2.  Wirth gave this project his blessing, and the Modula-3
committee was born.
</p><p>

At the first meeting, the committee unanimously agreed to be true to
the spirit of Modula-2 by selecting simple, safe, proven features rather
than experimenting with our own untried ideas.  We found that unanimity
was harder to achieve when we got to the details.
</p><p>

<a name="idx.1">Modula-3</a>
supports interfaces, objects, generics, lightweight threads
of control, the isolation of unsafe code, garbage collection,
exceptions, and subtyping.  Some of the more problematical features
of Modula-2 have been removed, like variant records and the built-in
unsigned numeric data type.  Modula-3 is substantially simpler than other
languages with comparable power.
</p><p>

<a name="idx.2">Modula-3</a>
is closely based on Modula-2+, which was designed at the
Digital Equipment Corporation Systems Research Center and used to build
the Topaz system
[<a href="http://www.research.compaq.com/SRC/modula-3/html/bib.html#mcjones89">McJones89</a>,
<a href="http://www.research.compaq.com/SRC/modula-3/html/bib.html#rovner86">Rovner86</a>].
The Modula-3 design was
a joint project by Digital and Olivetti.  The language definition was
published in August 1988, and immediately followed by implementation
efforts at both companies.  In January 1989, the committee revised
the language to reflect the experiences of these implementation teams.
A few final revisions were made for the publication of this book.
</p><p>

<a name="idx.3">SRC Modula-3</a>
is distributed by the DEC Systems Research Center under a liberal license.
The <a href="http://www.research.compaq.com/SRC/modula-3/html/srcm3.html">distribution</a>
includes a compiler for Modula-3, the Modula-3 Abstract Syntax Tree
toolkit developed at Olivetti, and a runtime system with configuration
files for DEC, IBM, HP, and Sun workstations.
</p><p>

</p><h3><a name="idx.4">1.2 Perspective</a></h3>
<p>

Most systems programming today is done in the BCPL family of languages,
which includes B, Bliss, and C. The beauty of these languages is the
modest cost with which they were able to take a great leap
forward from assembly language.  To fully appreciate them, you must
consider the engineering constraints of machines in the 1960s.  What
language designed in the 1980s has a compiler that fits into four
thousand 18-bit words, like Ken Thompson's B compiler for the PDP-7?
The most successful of these languages was C, which by the early 1970s
had almost completely displaced assembly language in the Unix system.
</p><p>

<a name="idx.5">The</a> BCPL-like languages are easy
to implement efficiently for the same reason they are attractive to
skeptical assembly language programmers: they present a programming
model that is close to the target machine.  Pointers are identified
with arrays, and address arithmetic is ubiquitous.  Unfortunately, this
low-level programming model is inherently dangerous.  Many errors are
as disastrous as they would be in machine language.  The type system
is scanty, and reveals enough quirks of the target machine that even
experienced and disciplined programmers sometimes write unportable
code simply by accident.  The most modern language in this family,
C++, has enriched C by adding objects; but it has also given up C's
best virtue---simplicity---without relieving C's worst drawback---its
low-level programming model. 
</p><p>

<a name="idx.6">At</a>
the other extreme are languages like Lisp, ML, Smalltalk, and CLU,
whose programming models originate from mathematics.  Lisp is the hybrid
of the lambda calculus and the theory of a pairing function; ML stems
from polymorphic type theory; Smalltalk from a theory of objects and
inheritance; CLU from a theory of abstract data types.  These languages
have beautiful programming models, but they tend to be difficult to
implement efficiently, because the uniform treatment of values in the
programming model invites a runtime system in which values are uniformly
represented by pointers.  If the implementer doesn't take steps to
avoid it, as simple a statement as <tt>n := n + 1</tt> could require an
allocation, a method lookup, or both.  Good implementations avoid
most of the cost, and languages in this family have been used
successfully for systems programming.  But their general disposition
towards heap allocation rather than stack allocation remains, and they
have not become popular with systems programmers.  The runtime systems
required to make these languages efficient often isolate them in closed
environments that cannot accommodate programs written in other
languages.  If you are a fan of these languages you may find Modula-3
overly pragmatic; but read on anyway, and give us a chance to show
that pragmatic constraints do not exclude attractive solutions.
</p><p>

<a name="idx.7">Between</a>
the extremes of BCPL and Lisp is the Algol family of languages,
whose modern representatives include Pascal, Ada, Modula-2, and
Modula-3.  These languages have programming models that reflect the
engineering constraints of random-access machines but conceal the
details of any particular machine.  They give up the beauty and
mathematical symmetry of the Lisp family in order to make efficient
implementations possible without special tricks; they also have strong
type systems that avoid most of the dangerous and machine-dependent
features of the BCPL family.
</p><p>

<a name="idx.8">In</a>
the 1960s, the trend in the Algol family was toward features for
control flow and data structuring.  In the 1970s, the trend was toward
information-hiding features like interfaces, opaque types, and generics.
More recently, the trend in the Algol family has been to adopt a careful
selection of techniques from the Lisp and BCPL families.  This trend
is demonstrated by Modula-3, Oberon, and Cedar, to name three languages
that have floated portable implementations in the last few years.
</p><p>

Modula-3, Oberon, and Cedar all provide garbage collection, previously
viewed as a luxury available only in the closed runtime systems of
the Lisp family.  But the world is starting to understand that garbage
collection is the only way to achieve an adequate level of safety,
and that modern garbage collectors can work in open runtime
environments.
</p><p>

At the same time, these three languages allow a small set of unsafe,
machine-dependent operations of the sort usually associated with the
BCPL family.  In Modula-3, unsafe operations are allowed only in modules
explicitly labeled unsafe.  The combination of garbage collection with
the explicit isolation of unsafe features produces a language suitable
for programming entire systems from the highest-level applications
down to the lowest-level device drivers.
</p><p>

</p><h3><a name="OverviewSect">1.3 Overview</a></h3>
<p>

[ This section discusses the organization of the entire book,
<a href="http://www.research.digital.com/SRC/modula-3/html/bib.html#SPwM3"><i>Systems Programming with Modula-3</i></a>. It doesn't seem worth
including this material in the on-line version. ]

</p><h3><a name="FeaturesSect">1.4 Features</a></h3>
<p>

The remainder of the introduction is an overview of the most important
features of Modula-3.  
</p><p>

</p><h4><a name="idx.9">1.4.1 Interfaces</a></h4>
<p>

One of Modula-2's most successful features is the provision for explicit
interfaces between modules.  Interfaces are retained with essentially
no changes in Modula-3.  An interface to a module is a collection of
declarations that reveal the public parts of a module; things in the
module that are not declared in the interface are private.  A module
<em>imports</em> the interfaces it depends on and <em>exports</em> the
interface (or, in Modula-3, the interfaces) that it implements.
</p><p>

Interfaces make separate compilation type-safe; but it does them an
injustice to look at them in such a limited way.  Interfaces make it
possible to think about large systems without holding the whole system
in your head at once.
</p><p>

Programmers who have never used Modula-style interfaces tend to
underestimate them, observing, for example, that anything that can
be done with interfaces can also be done with C-style include files.
This misses the point: many things can be done with include files that
cannot be done with interfaces.  For example, the meaning of an include
file can be changed by defining macros in the environment into which
it is included.  Include files tempt programmers into shortcuts across
abstraction boundaries.  To keep large programs well structured, you
either need super-human will power, or proper language support for
interfaces.
</p><p>

</p><h4><a name="idx.10">1.4.2 Objects</a></h4>
<p>

THe better we understand our programs, the bigger the building blocks
we use to structure them.  After the instruction came the statement,
after the statement came the procedure, after the procedure came the
interface.  The next step seems to be the <em>abstract type</em>.
</p><p>

<a name="idx.11">At</a>
the theoretical level, an abstract type is a type defined by the
specifications of its operations instead of by the representation of
its data.  As realized in modern programming languages, a value of
an abstract type is represented by an "object" whose operations are
implemented by a suite of procedure values called the object's
"methods".  A new object type can be defined as a <em>subtype</em> of
an existing type, in which case the new type has all the methods of
the old type, and possibly new ones as well (inheritance).  The new
type can provide new implementations for the old methods (overriding).
</p><p>

Objects were invented in the mid-sixties by the farsighted designers
of Simula
[<a href="http://www.research.compaq.com/SRC/modula-3/html/bib.html#birtwistle">Birtwistle</a>].
Objects in Modula-3 are very much like
objects in Simula: they are always references, they have both data
fields and methods, and they have single inheritance but not multiple
inheritance.
</p><p>

Small examples are often used to get across the basic idea: truck as
a subtype of vehicle; rectangle as a subtype of polygon.  Modula-3
aims at larger systems that illustrate how object types provide
structure for large programs.  In Modula-3 the main design
effort is concentrated into specifying the properties of a single
abstract type---a stream of characters, a window on the screen.  Then
dozens of interfaces and modules are coded that provide useful subtypes
of the central abstraction.  The abstract type provides the blueprint
for a whole family of interfaces and modules.  If the central
abstraction is well-designed then useful subtypes can be produced
easily, and the original design cost will be repaid with interest.
</p><p>

<a name="idx.12">The</a>
combination of object types with Modula-2 opaque types produces
something new: the <em>partially opaque type</em>, where some of an
object's fields are visible in a scope and others are hidden.  Because
the committee had no experience with partially opaque types, the first
version of Modula-3 restricted them severely; but after a year of
experience it was clear that they were a good thing, and the language
was revised to remove the restrictions.
</p><p>

It is possible to use object-oriented techniques even in languages
that were not designed to support them, by explicitly allocating the
data records and method suites.  This approach works reasonably smoothly
when there are no subtypes; however it is through subtyping that
object-oriented techniques offer the most leverage.  The approach works
badly when subtyping is needed: either you allocate the data records
for the different parts of the object individually (which is expensive
and notationally cumbersome) or you must rely on unchecked type
transfers, which is unsafe.  Whichever approach is taken, the subtype
relations are all in the programmer's head: only with an object-oriented
language is it possible to get object-oriented static typechecking.
</p><p>

</p><h4><a name="idx.13">1.4.3 Generics</a></h4>
<p>

A generic module is a template in which some of the imported interfaces
are regarded as formal parameters, to be bound to actual interfaces
when the generic is instantiated.  For example, a generic hash table
module could be instantiated to produce tables of integers, tables
of text strings, or tables of any desired type.  The different generic
instances are compiled independently: the source program is reused,
but the compiled code will generally be different for different
instances.
</p><p>

To keep Modula-3 generics simple, they are confined to the module level:
generic procedures and types do not exist in isolation, and generic
parameters must be entire interfaces.
</p><p>

In the same spirit of simplicity, there is no separate typechecking
associated with generics.  Implementations are expected to expand the
generic and typecheck the result.  The alternative would be to invent
a polymorphic type system flexible enough to express the constraints
on the parameter interfaces that are necessary in order for the generic
body to compile.  This has been achieved for ML and CLU, but it has
not yet been achieved satisfactorily in the Algol family of languages,
where the type systems are less uniform.  (The rules associated with
Ada generics are too complicated for our taste.)
</p><p>

</p><h4><a name="idx.14">1.4.4 Threads</a></h4>
<p>

Dividing a computation into concurrent processes (or threads of control)
is a fundamental method of separating concerns.  For example, suppose
you are programming a terminal emulator with a blinking cursor: the
most satisfactory way to separate the cursor blinking code from the
rest of the program is to make it a separate thread.  Or suppose you
are augmenting a program with a new module that communicates over a
buffered channel.  Without threads, the rest of the program will be
blocked whenever the new module blocks on its buffer, and conversely,
the new module will be unable to service the buffer whenever any other
part of the program blocks.  If this is unacceptable (as it almost
always is) there is no way to add the new module without finding and
modifying every statement of the program that might block.  These
modifications destroy the structure of the program by introducing
undesirable dependencies between what would otherwise be independent
modules.
</p><p>

<a name="idx.15">The</a>
provisions for threads in Modula-2 are weak, amounting essentially
to coroutines.  Hoare's monitors
[<a href="http://www.research.compaq.com/SRC/modula-3/html/bib.html#hoare">Hoare</a>]
are a sounder basis for
concurrent programming.  Monitors were used in Mesa, where they worked
well; except that the requirement that a monitored data structure be
an entire module was irksome.  For example, it is often useful for
a monitored data structure to be an object instead of a module.  Mesa
relaxed this requirement, made a slight change in the details of the
semantics of Hoare's <tt>Signal</tt> primitive, and introduced the
<tt>Broadcast</tt> primitive as a convenience
[<a href="http://www.research.compaq.com/SRC/modula-3/html/bib.html#lampson80">Lampson</a>].
The Mesa primitives were simplified in the Modula-2+ design, and the result
was successful enough to be incorporated with no substantial changes
in Modula-3.
</p><p>

<a name="idx.16">A</a>
threads package is a tool with a very sharp edge.  A common
programming error is to access a shared variable without obtaining
the necessary lock.  This introduces a race condition that can lie
dormant throughout testing and strike after the program is shipped.
Theoretical work on process algebra has raised hopes that the rendezvous
model of concurrency may be safer than the shared memory model, but
the experience with Ada, which adopted the rendezvous, lends at best
equivocal support for this hope---Ada still allows shared variables,
and apparently they are widely used.
</p><p>

</p><h4><a name="idx.17">1.4.5 Safety</a></h4>
<p>

A language feature is <em>unsafe</em> if its misuse can corrupt the runtime
system so that further execution of the program is not faithful to
the language semantics.  An example of an unsafe feature is array
assignment without bounds checking: if the index is out of bounds,
then an arbitrary location can be clobbered and the address space can
become fatally corrupted.  An error in a safe program can cause the
computation to abort with a run-time error message or to give the wrong
answer, but it can't cause the computation to crash in a rubble of
bits.
</p><p>

Safe programs can share the same address space, each safe from
corruption by errors in the others.  To get similar protection for
unsafe programs requires placing them in separate address spaces.  As
large address spaces become available, and programmers use them to
produce tightly-coupled applications, safety becomes more and more
important.
</p><p>

Unfortunately, it is generally impossible to program the lowest levels of
a system with complete safety.  Neither the compiler nor the runtime
system can check the validity of a bus address for an I/O controller,
nor can they limit the ensuing havoc if it is invalid.  This presents
the language designer with a dilemma.  If he holds out for safety,
then low level code will have to be programmed in another language.
But if he adopts unsafe features, then his safety guarantee becomes
void everywhere.  
</p><p>

The languages of the BCPL family are full of unsafe features;
the languages of the Lisp family generally have none (or none that
are documented).  In this area Modula-3 follows the lead of Cedar by
adopting a small number of <a href="#UnsafeSect">unsafe features</a>
that are allowed only in
modules explicitly labeled unsafe.  In a safe module, the compiler
prevents any errors that could corrupt the runtime system; in an unsafe
module, it is the programmer's responsibility to avoid them.
</p><p>

</p><h4><a name="idx.18">1.4.6 Garbage collection</a></h4>
<p>

A classic unsafe runtime error is to free a data structure that is
still reachable by active references (or "dangling pointers").  The
error plants a time bomb that explodes later, when the storage is
reused.  If on the other hand the programmer fails to free records
that have become unreachable, the result will be a "storage leak"
and the computation space will grow without bound.  Problems due to
dangling pointers and storage leaks tend to persist long after other
errors have been found and removed.  The only sure way to avoid
these problems is the automatic freeing of unreachable storage, or
garbage collection.
</p><p>

Modula-3 therefore provides "traced references", which are like
Modula-2 pointers except that the storage they point to is kept in
the "traced heap" where it will be freed automatically when all
references to it are gone.
</p><p>

Another great benefit of garbage collection is that it simplifies
interfaces.  Without garbage collection, an interface must specify
whether the client or the implementation has the responsibility for
freeing each allocated reference, and the conditions under which it
is safe to do so.  This can swamp the interface in complexity.  For
example, Modula-3 supports text strings by a simple required interface
<tt>Text</tt>, rather than with a built-in type.  Without garbage
collection, this approach would not be nearly as attractive.
</p><p>

New refinements in garbage collection have appeared continually for
more than twenty years, but it is still difficult to implement
efficiently.  For many programs, the programming time saved by
simplifying interfaces and eliminating storage leaks and dangling
pointers makes garbage collection a bargain, but the lowest levels
of a system may not be able to afford it.  For example, in SRC's Topaz
system, the part of the operating system that manages files and
heavy-weight processes relies on garbage collection, but the inner
"nub" that implements virtual memory and thread context switching
does not.  Essentially all Topaz application programs rely on garbage
collection.
</p><p>

For programs that cannot afford garbage collection, Modula-3 provides
a set of reference types that are not traced by the garbage collector.
In most other respects, traced and untraced references behave
identically.
</p><p>

</p><h4><a name="idx.19">1.4.7 Exceptions</a></h4>
<p>

An exception is a control construct that exits many scopes at once.
Raising an exception exits active scopes repeatedly until a handler
is found for the exception, and transfers control to the handler.  If
there is no handler, the computation terminates in some system-dependent
way---for example, by entering the debugger.
</p><p>

There are many arguments for and against exceptions, most of which
revolve around inconclusive issues of style and taste.  One argument
in their favor that has the weight of experience behind it is that
exceptions are a good way to handle any runtime error that is usually,
but not necessarily, fatal.  If exceptions are not available, each
procedure that might encounter a runtime error must return an additional
code to the caller to identify whether an error has occurred.  This
can be clumsy, and has the practical drawback that even careful
programmers may inadvertently omit the test for the error return code.
The frequency with which returned error codes are ignored has become
something of a standing joke in the Unix/C world.  Raising an exception
is more robust, since it stops the program unless there is an explicit
handler for it.
</p><p>

</p><h4><a name="TypeSystemSect">1.4.8 Type system</a></h4>
<p>

Like all languages in the Algol family, Modula-3 is strongly typed.
The basic idea of strong typing is to partition the value space into
types, restrict variables to hold values of a single type, and restrict
operations to apply to operands of fixed types.  In actuality, strong
typing is rarely so simple.  For example, each of the following
complications is present in at least one language of the Algol family:
a variable of type <tt>[0..9]</tt> may be safely assigned to an
<tt>INTEGER</tt>, but not vice-versa (subtyping).  Operations like absolute
value may apply both to <tt>REAL</tt>s and to <tt>INTEGER</tt>s instead of
to a single type (overloading).  The types of literals (for example,
<tt>NIL</tt>) can be ambiguous.  The type of an expression may be
determined by how it is used (target-typing).  Type mismatches may
cause automatic conversions instead of errors (as when a fractional
real is rounded upon assignment to an integer).
</p><p>

We adopted several principles in order to make Modula-3's type system
as uniform as possible.  First, there are no ambiguous types or
target-typing: the type of every expression is determined by its
subexpressions, not by its use.  Second, there are no automatic
conversions.  In some cases the <em>representation</em> of a value changes
when it is assigned (for example, when assigning to a packed field
of a record type) but the abstract value itself is transferred without
change.  Third, the rules for type compatibility are defined in terms
of a single subtype relation.  The subtype relation is required for
treating objects with inheritance, but it is also useful for defining
the type compatibility rules for conventional types.
</p><p>

</p><h4><a name="idx.20">1.4.9 Simplicity</a></h4>
<p>

In the early days of the Ada project, a general in the Ada Program
Office opined that "obviously the Department of Defense is not
interested in an artificially simplified language such as Pascal".
Modula-3 represents the opposite point of view.  We used every artifice
that we could find or invent to make the language simple.
</p><p>

C. A. R. Hoare has suggested that as a rule of thumb a language is
too complicated if it can't be described precisely and readably in
fifty pages.  The Modula-3 committee elevated this to a design
principle: we gave ourselves a "complexity budget" of fifty pages,
and chose the most useful features that we could accommodate within
this budget.  In the end, we were over budget by six lines plus the
syntax equations.  This policy is a bit arbitrary, but there are so
many good ideas in programming language design that some kind of
arbitrary budget seems necessary to keep a language from getting too
complicated.
</p><p>

In retrospect, the features that made the cut were directed toward
two main goals.  Interfaces, objects, generics, and threads provide
fundamental patterns of abstraction that help to structure large
programs.  The isolation of unsafe code, garbage collection, and
exceptions help make programs safer and more robust.  Of the techniques
that we used to keep the language internally consistent, the most
important was the definition of a clean type system based on a subtype
relation.  There is no special novelty in any one of these features
individually, but there is simplicity and power in their combination.
</p><p>

</p><h2><a name="DefsSect">2.1 Definitions</a></h2>
<p>

<a name="idx.22">A</a>
Modula-3 program specifies a computation that acts on a sequence 
of digital components called <em>locations</em>.  A <em>variable</em> is a set 
of locations that represents a mathematical value according to a 
convention determined by the variable's <em>type</em>.  If a value can 
be represented by some variable of type <tt>T</tt>, then we say that 
the value is a <em>member</em> of <tt>T</tt> and <tt>T</tt> <em>contains</em> 
the value.
</p><p>

<a name="idx.23">An</a>
<em>identifier</em> is a symbol declared as a name for a variable, type,
procedure, etc.  The region of the program over which a declaration
applies is called the <em>scope</em> of the declaration.  Scopes can be
nested.  The meaning of an identifier is determined by the smallest
enclosing scope in which the identifier is declared.
</p><p>

<a name="idx.24">An</a>
<em>expression</em> specifies a computation that produces a value 
or variable.  Expressions that produce variables are called 
<em>designators</em>.  A designator can denote either a variable or the value 
of that variable, depending on the context.  Some designators are 
<em>readonly</em>, which means that they cannot be used in contexts that might 
change the value of the variable.  A designator that is not readonly 
is called <em>writable</em>. Expressions 
whose values can be determined statically are called <em>constant 
expressions</em>; they are never designators.
</p><p>

<a name="idx.25">A</a>
<em>static error</em> is an error that the implementation must detect 
before program execution.  Violations of the language definition 
are static errors unless they are explicitly classified as runtime 
errors.
</p><p>

<a name="idx.26">A</a>
<em>checked runtime error</em> is an error that the implementation 
must detect and report at runtime.  The method for reporting such 
errors is implementation-dependent.  (If the implementation maps 
them into exceptions, then a program could handle these exceptions 
and continue.)
</p><p>

<a name="idx.27">An</a>
<em>unchecked runtime error</em> is an error that is not guaranteed 
to be detected, and can cause the subsequent behavior of the 
computation to be arbitrary.  Unchecked runtime errors can occur 
only in <a href="#SafetySect">unsafe modules</a>.
</p><p>

</p><h2><a name="TypesSect">2.2 Types</a></h2>
<p>

</p><blockquote><em>
I am the voice of today, the herald of tomorrow...  
I am the leaden army that conquers the world---I am TYPE.  
---Frederic William Goudy
</em></blockquote>
<p>

<a name="idx.28">Modula-3</a>
uses structural equivalence, instead of the name equivalence
of Modula-2.  Two types are the same if their definitions become the
same when expanded; that is, when all constant expressions are replaced
by their values and all type names are replaced by their definitions.
In the case of recursive types, the expansion is the infinite limit
of the partial expansions.  A type expression is generally allowed
wherever a type is required.
</p><p>

<a name="idx.29">A</a>
type is <em>empty</em> if it contains no values.  For example,
<tt>[1..0]</tt> is an empty type.  Empty types can be used to build non-empty 
types (for example, <tt>SET OF [1..0]</tt>, which is not empty because 
it contains the empty set).  It is a static error to declare a variable 
of an empty type.
</p><p>

Every expression has a statically-determined type, which contains 
every value that the expression can produce.  The type of a designator 
is the type of the variable it produces. 
</p><p>

Assignability and type compatibility are defined in terms of a single
syntactically specified subtype relation with the property that if
<tt>T</tt> is a subtype of <tt>U</tt>, then every member of <tt>T</tt>
is a member of <tt>U</tt>.  The subtype relation is reflexive and transitive.
</p><p>

Every expression has a unique type, but a value can be a member of 
many types.  For example, the value <tt>6</tt> is a member of both
<tt>[0..9]</tt> and <tt>INTEGER</tt>.  It would be ambiguous to talk
about "the type of a value".  Thus the phrase "type of <tt>x</tt>"
means "type of the expression <tt>x</tt>", while "<tt>x</tt> is a
member of <tt>T</tt>" means "the value of <tt>x</tt> is a member of
<tt>T</tt>".  
</p><p>

<a name="idx.30">However,</a>
there is one sense in which a value can be said to have 
a type: every object or traced reference value includes a code 
for a type, called the <em>allocated type</em> of the reference value. 
The allocated type is tested by <a href="#TypecaseSect"><tt>TYPECASE</tt></a>.
</p><p>

</p><h3><a name="OrdinalsSect">2.2.1 Ordinal types</a></h3>
<p>

There are three kinds of ordinal types: enumerations, subranges,
and <tt>INTEGER</tt>.  An enumeration type is declared like this:
</p><pre>    TYPE T = {id_1, id_2, ..., id_n}
</pre>
where the <tt>id</tt>'s are distinct identifiers.  The type <tt>T</tt> is an
ordered set of <tt>n</tt> values; the expression <tt>T.id_i</tt> denotes
the <tt>i</tt>'th value of the type in increasing order.  The empty
enumeration <tt>{ }</tt> is allowed.
<p>

<a name="idx.32">Integers</a>
and enumeration elements are collectively called <em>ordinal values</em>.
The <em>base type</em> of an ordinal value <tt>v</tt> is
<tt>INTEGER</tt> if <tt>v</tt> is an integer, otherwise it is the unique 
enumeration type that contains <tt>v</tt>. 
</p><p>

<a name="idx.33">A</a>
subrange type is declared like this:
</p><pre>    TYPE T = [Lo..Hi]
</pre>
where <tt>Lo</tt> and <tt>Hi</tt> are two ordinal values with the same 
base type, called the base type of the subrange. The values of <tt>T</tt>
are all the values from <tt>Lo</tt> to <tt>Hi</tt> inclusive.
<tt>Lo</tt> and <tt>Hi</tt> must be
<a href="#idx.205">constant expressions</a>.
If <tt>Lo</tt> exceeds <tt>Hi</tt>, the subrange is empty.
<p>

The operators
<a href="http://www.research.compaq.com/SRC/m3defn/html/typeops.html#idx.200"><tt>ORD</tt> and <tt>VAL</tt></a>
convert between enumerations and integers.
The operators
<a href="http://www.research.compaq.com/SRC/m3defn/html/typeops.html#idx.202"><tt>FIRST</tt>, <tt>LAST</tt></a>,
and
<a href="http://www.research.compaq.com/SRC/m3defn/html/typeops.html#idx.201"><tt>NUMBER</tt></a> 
applied to an ordinal type return the first element, last element, 
and number of elements, respectively.
</p><p>

<a name="idx.34">Here are</a> the predeclared ordinal types:
</p><pre>    INTEGER   All integers represented by the implementation
    CARDINAL  Behaves just like the subrange <tt>[0..LAST(INTEGER)]</tt>
    BOOLEAN   The enumeration <tt>{FALSE, TRUE}</tt>
    CHAR      An enumeration containing at least 256 elements
</pre>
The first 256 elements of type <tt>CHAR</tt> represent characters in the
ISO-Latin-1 code, which is an extension of ASCII.  The language does
not specify the names of the elements of the <tt>CHAR</tt> enumeration.
The syntax for character literals is specified in the section on
<a href="#idx.171">literals</a>.
<tt>FALSE</tt> and <tt>TRUE</tt> are predeclared
synonyms for <tt>BOOLEAN.FALSE</tt> and <tt>BOOLEAN.TRUE</tt>.
<p>

Each distinct enumeration type introduces a new collection of values,
but a subrange type reuses the values from the underlying type.  For
example:
</p><pre>    TYPE
       T1 = {A, B, C}; 
       T2 = {A, B, C}; 
       U1 = [T1.A..T1.C]; 
       U2 = [T1.A..T2.C];  (* sic *) 
       V =   {A, B}
</pre>
<tt>T1</tt> and <tt>T2</tt> are the same type, since they have the same 
expanded definition.  In particular, <tt>T1.C = T2.C</tt> and therefore
<tt>U1</tt> and <tt>U2</tt> are also the same type.  But the types <tt>T1</tt> 
and <tt>U1</tt> are distinct, although they contain the same values, 
because the expanded definition of <tt>T1</tt> is an enumeration while the 
expanded definition of <tt>U1</tt> is a subrange.
The type <tt>V</tt> is a third type whose values <tt>V.A</tt> and <tt>V.B</tt>
are not related to the values <tt>T1.A</tt> and <tt>T1.B</tt>.
<p>

</p><h3><a name="FloatsSect">2.2.2 Floating-point types</a></h3>
<p>

There are three floating point types, which in order of increasing
range and precision are <tt>REAL</tt>, <tt>LONGREAL</tt>,
and <tt>EXTENDED</tt>.
The properties of these types are specified by
<a href="http://www.research.compaq.com/SRC/m3defn/html/intfs.html">required interfaces</a>.
</p><p>

</p><h3><a name="ArraysSect">2.2.3 Arrays</a></h3>
<p>

An <em>array</em> is an indexed collection of component variables,
called the <em>elements</em> of the array.  The indexes are the values of
an ordinal type, called the <em>index type</em> of the array.  The elements
all have the same size and the same type, called the <em>element type</em>
of the array.
</p><p>

<a name="idx.37">There</a>
are two kinds of array types, <em>fixed</em> and <em>open</em>.  The
length of a fixed array is determined at compile time.  The length
of an open array type is determined at runtime, when it is allocated
or bound.  The length cannot be changed thereafter.
</p><p>

<a name="idx.38">The</a>
<em>shape</em> of a multi-dimensional array is the sequence of its 
lengths in each dimension.  More precisely, the shape of an array 
is its length followed by the shape of any of its elements; the shape 
of a non-array is the empty sequence.  
</p><p>

<a name="idx.39">Arrays</a>
are assignable if they have the same element type and shape. 
If either the source or target of the assignment is an open array, 
a runtime shape check is required.
</p><p>

<a name="idx.40">A</a>
fixed array type declaration has the form:
</p><pre>    TYPE T = ARRAY Index OF Element
</pre>
where <tt>Index</tt> is an ordinal type and <tt>Element</tt> is any type other
than an open array type.  The values of type <tt>T</tt> are arrays whose
element type is <tt>Element</tt> and whose length is the number of elements
of the type <tt>Index</tt>.  
<p>

<a name="idx.41">If</a>
<tt>a</tt> has type <tt>T</tt>, then <tt>a[i]</tt> designates the element 
of <tt>a</tt> whose position corresponds to the position of <tt>i</tt> 
in <tt>Index</tt>.  For example, consider the declarations:
</p><pre>    VAR a := ARRAY [1..3] OF REAL {1.0, 2.0, 3.0};
    VAR b: ARRAY [-1..1] OF REAL := a;
</pre>
Now <tt>a = b</tt> is <tt>TRUE</tt>;
yet <tt>a[1] = 1.0</tt> while <tt>b[1] = 3.0</tt>.
The interpretation of indexes is determined by an array's
type, not its value; the assignment <tt>b := a</tt> changes <tt>b</tt>'s
value, not its type.  (This example uses
<a href="#VarsSect">variable initialization</a>,
and
<a href="#idx.177">array constructors</a>.)
<p>

<a name="idx.42">An</a>
expression of the form:
</p><pre>    ARRAY Index_1, ..., Index_n OF Element
</pre>
is shorthand for:
<pre>    ARRAY Index_1 OF ... OF ARRAY Index_n OF Element
</pre>
<p>

This shorthand is eliminated from the expanded type definition
used to define structural equivalence.  An expression of the form
<tt>a[i_1</tt>, <tt>...</tt>, <tt>i_n]</tt>
is shorthand for <tt>a[i_1]...[i_n]</tt>.
</p><p>

<a name="idx.43">An</a>
open array type declaration has the form:
</p><pre>    TYPE T = ARRAY OF Element
</pre>
where <tt>Element</tt> is any type.  The values of <tt>T</tt> are arrays 
whose element type is <tt>Element</tt> and whose length is arbitrary.  
The index type of an open array is the integer subrange
<tt>[0..n-1]</tt>, where <tt>n</tt> is the length of the array.  
<p>

An open array type can be used only as the type of a formal parameter,
the referent of a reference type, the element type of another open
array type, or as the type in an array constructor.
</p><p>

Examples of array types:
</p><pre>    TYPE
       Transform = ARRAY [1..3], [1..3] OF REAL;
       Vector    = ARRAY OF REAL;
       SkipTable = ARRAY CHAR OF INTEGER
</pre>
<p>

</p><h3><a name="RecordsSect">2.2.4 Records</a></h3>
<p>

A <em>record</em> is a sequence of named variables, called the
<em>fields</em> of the record.  Different fields can have different types. 
The name and type of each field is statically determined by the 
record's type.  The expression <tt>r.f</tt> designates the field named 
<tt>f</tt> in the record <tt>r</tt>.
</p><p>

A record type declaration has the form:
</p><pre>    TYPE T = RECORD FieldList END
</pre>
where <tt>FieldList</tt> is a list of field declarations,
each of which has the form:
<pre>    fieldName: Type := default
</pre>
where <tt>fieldName</tt> is an identifier,
<tt>Type</tt> is any non-empty type other 
than an open array type, and <tt>default</tt> is a constant expression.  
The field names must be distinct.
A record is a member of <tt>T</tt> if it has fields with the given names 
and types, in the given order, and no other fields.  Empty records 
are allowed.
<p>

<a name="idx.45">The</a>
constant <tt>default</tt> is a default value used when a record 
is
<a href="#idx.178">constructed</a>
or
<a href="#idx.181">allocated</a>.
Either "<tt>:= default</tt>" or "<tt>: Type</tt>" 
can be omitted, but not both.  If <tt>Type</tt> is omitted, it is taken 
to be the type of <tt>default</tt>. If both are present, the value of 
<tt>default</tt> must be a member of <tt>Type</tt>.
</p><p>

When a series of fields shares the same type and default,
any <tt>fieldName</tt>
can be a list of identifiers separated by commas.  Such a list is
shorthand for a list in which the type and default are repeated
for each identifier.  That is:
</p><pre>    f_1, ..., f_m: Type := default
</pre>
is shorthand for:
<pre>    f_1: Type := default; ...; f_m: Type := default
</pre>
This shorthand is eliminated from the expanded definition
of the type.  The default values are included.
<p>

Examples of record types:
</p><pre>    TYPE
      Time = RECORD
        seconds: INTEGER;
        milliseconds: [0..999]
      END; 

      Alignment = {Left, Center, Right}; 

      TextWindowStyle = RECORD 
         align          := Alignment.Center;
         font           := Font.Default; 
         foreground     := Color.Black; 
         background     := Color.White; 
         margin, border := 2  
      END
</pre>
<p>

</p><h3><a name="PackedSect">2.2.5 Packed types</a></h3>
<p>

A declaration of a packed type has the form:
</p><pre>    TYPE T = BITS n FOR Base
</pre>
where <tt>Base</tt> is a type and <tt>n</tt> is an integer-valued constant 
expression. The values of type <tt>T</tt> are the same as the values 
of type <tt>Base</tt>, but variables of type <tt>T</tt> that occur in 
records, objects, or arrays will occupy exactly <tt>n</tt> bits and 
be packed adjacent to the preceding field or element.  For example, 
a variable of type
<pre>    ARRAY [0..255] OF BITS 1 FOR BOOLEAN
</pre>
is an array of 256 booleans, each of which occupies one bit of storage.
<p>

The values allowed for <tt>n</tt> are implementation-dependent.  An 
illegal value for <tt>n</tt> is a static error.  The legality of a packed 
type can depend on its context; for example, an implementation could 
prohibit packed integers from spanning word boundaries.
</p><p>

</p><h3><a name="SetsSect">2.2.6 Sets</a></h3>
<p>

A <em>set</em> is a collection of values taken from some ordinal type.
A set type declaration has the form:
</p><pre>    TYPE T = SET OF Base
</pre>
where <tt>Base</tt> is an ordinal type.  The values of <tt>T</tt> are all sets
whose elements have type <tt>Base</tt>.  For example, a variable whose
type is <tt>SET</tt> <tt>OF</tt> <tt>[0..1]</tt> can assume the following
values:
<pre>    {}     {0}     {1}     {0,1}
</pre>
<p>

Implementations are expected to use the same representation for a 
<tt>SET OF T</tt> as for an <tt>ARRAY T OF BITS 1 FOR BOOLEAN</tt>.  Hence, 
programmers should expect <tt>SET OF [0..1023]</tt> to be practical,
but not <tt>SET OF INTEGER</tt>.
</p><p>

</p><h3><a name="RefsSect">2.2.7 References</a></h3>
<p>

A <em>reference</em> value is either <tt>NIL</tt> or the address of
a variable, called the referent.  
</p><p>

<a name="idx.49">A</a>
reference type is either <em>traced</em> or <em>untraced</em>.  When 
all traced references to a piece of allocated storage are gone, the 
implementation reclaims the storage. Two reference types are of the 
same <em>reference class</em> if they are both traced or both untraced.
A general type is traced if it is a traced reference type, 
a record type any of whose field types is traced, an array type whose 
element type is traced, or a packed type whose underlying unpacked 
type is traced.
</p><p>

<a name="idx.50">A</a>
declaration for a traced reference type has the form:
</p><pre>    TYPE T = REF Type
</pre>
where <tt>Type</tt> is any type.  The values of <tt>T</tt> are traced 
references to variables of type <tt>Type</tt>, which is called 
the <em>referent type</em> of <tt>T</tt>.  
<p>

<a name="idx.51">A</a>
declaration for an untraced reference type has the form:
</p><pre>    TYPE T = UNTRACED REF Type
</pre>
where <tt>Type</tt> is any untraced type.
(This restriction is lifted in <a href="#SafetySect">unsafe modules</a>.)
The values of <tt>T</tt> are the untraced references 
to variables of type <tt>Type</tt>.    
<p>

<a name="idx.52">In</a>
both the traced and untraced cases, the keyword <tt>REF</tt> can 
optionally be preceded by "<tt>BRANDED b</tt>" where <tt>b</tt> is 
a text constant called the <em>brand</em>.  Brands distinguish types 
that would otherwise be the same; they have no other semantic effect. 
All brands in a program must be distinct. If <tt>BRANDED</tt> is present 
and <tt>b</tt> is absent, the implementation automatically supplies 
a unique value for <tt>b</tt>.  Explicit brands are useful for persistent
data storage.
</p><p>

<a name="idx.53">The</a>
following reference types are predeclared:
</p><pre>    REFANY    Contains all traced references
    ADDRESS   Contains all untraced references
    NULL      Contains only <tt>NIL</tt>
</pre>
The <a href="#TypecaseSect"><tt>TYPECASE</tt></a> statement
can be used to test the referent type 
of a <tt>REFANY</tt> or object, but there is 
no such test for an <tt>ADDRESS</tt>.
<p>

Examples of reference types:
</p><pre>    TYPE TextLine = REF ARRAY OF CHAR;

    ControllerHandle = UNTRACED REF RECORD
      status: BITS 8 FOR [0..255];
      filler: BITS 12 FOR [0..0];
      pc: BITS 12 FOR [0..4095]
    END;

    T = BRANDED "ANSI-M3-040776" REF INTEGER;

    Apple  = BRANDED REF INTEGER;
    Orange = BRANDED REF INTEGER;
</pre>
<p>

</p><h3><a name="ProcsSect">2.2.8 Procedures</a></h3>
<p>

A <em>procedure</em> is either <tt>NIL</tt> or a triple consisting of:
</p><ul>
<li> the <em>body</em>, which is a statement, 
</li><li> the <em>signature</em>, which specifies the procedure's formal arguments,
     result type, and raises set (the set of exceptions that
     the procedure can raise), 
</li><li> the <em>environment</em>, which is the scope with respect to which
     variable names in the body will be interpreted.
</li></ul>
<p>

<a name="idx.55">A</a>
procedure that returns a result is called a <em>function procedure</em>;
a procedure that does not return a result is called a
<em>proper procedure</em>.
A <em>top-level</em> procedure is a procedure declared in the outermost scope
of a module.  Any other procedure is a <em>local</em> procedure.  
A local procedure can be passed as a parameter but not assigned, since
in a stack implementation a local procedure becomes invalid when the
frame for the procedure containing it is popped.  
</p><p>

<a name="idx.56">A</a>
<em>procedure constant</em> is an identifier declared as a procedure.
(As opposed to a procedure variable, which is a variable declared
with a procedure type.)
</p><p>

A procedure type declaration has the form:
</p><pre>    TYPE T = PROCEDURE sig
</pre>
<a name="idx.57">where</a>
<tt>sig</tt> is a signature specification, which has the form:
<pre>    (formal_1; ...; formal_n): R RAISES S
</pre>
where
<ul>
<li> Each <tt>formal_i</tt> is a formal parameter declaration, as
     described below.
</li><li> <tt>R</tt> is the result type, which can be any type but an
     open array type.  The "<tt>: R</tt>" can be omitted, making the signature
     that of a proper procedure.
</li><li> <tt>S</tt> is the raises set, which is either an explicit
     set of exceptions with the syntax <tt>{E_1, ..., E_n}</tt>, or
     the symbol <tt>ANY</tt> representing the set of all exceptions.
     If "<tt>RAISES S</tt>" is omitted, "<tt>RAISES {}</tt>" is assumed.
</li></ul>
<p>

A formal parameter declaration has the form
</p><pre>    Mode Name: Type := Default
</pre>
<a name="idx.58">where</a>
<ul>
<li> <tt>Mode</tt> is a parameter mode, which can be <tt>VALUE</tt>,
     <tt>VAR</tt>, or <tt>READONLY</tt>.  If <tt>Mode</tt> is omitted,
     it defaults to <tt>VALUE</tt>.
</li><li> <tt>Name</tt> is an identifier that names the parameter.
     The parameter names must be distinct.
</li><li> <tt>Type</tt> is the type of the parameter.
</li><li> <tt>Default</tt> is a constant expression, the default value
     for the parameter.  If <tt>Mode</tt> is <tt>VAR</tt>,
     "<tt>:= Default</tt>" must be omitted, otherwise either
     "<tt>:= Default</tt>" or "<tt>  : Type</tt>" can be omitted,
     but not both.  If <tt>Type</tt> is omitted, it is taken to be
     the type of <tt>Default</tt>.  If both are present,
     the value of <tt>Default</tt> must be a member of <tt>Type</tt>.
</li></ul>
<p>

When a series of parameters share the same mode, type, and default,
<tt>Name</tt> can be a list of identifiers separated by commas.  Such
a list is shorthand for a list in which the mode, type, and
default are repeated for each identifier.  That is:
</p><pre>    Mode v_1, ..., v_n: Type := Default
</pre>
is shorthand for:
<pre>    Mode v_1: Type := Default; ...; Mode v_n: Type := Default
</pre>
<p>

This shorthand is eliminated from the expanded definition of the type.  
The default values are included.
</p><p>

<a name="idx.59">A</a>
procedure value <tt>P</tt> is a member of the type <tt>T</tt>
if it is <tt>NIL</tt>
or its signature is <em>covered</em> by the signature of <tt>T</tt>, where
<tt>signature_1</tt> covers <tt>signature_2</tt> if:
</p><ul>
<li> They have the same number of parameters, and corresponding parameters
     have the same type and mode.
</li><li> They have the same result type, or neither has a result type.
</li><li> The raises set of <tt>signature_1</tt> contains the raises
     set of <tt>signature_2</tt>.
</li></ul>
<p>

The parameter names and defaults affect the type of a procedure, but
not its value.  For example, consider the declarations:
</p><pre>    PROCEDURE P(txt: TEXT := "P") = 
      BEGIN
        Wr.PutText(Stdio.stdout, txt)
      END P;

    VAR q: PROCEDURE(txt: TEXT := "Q") := P;
</pre>
Now <tt>P = q</tt> is <tt>TRUE</tt>, yet <tt>P()</tt> prints "<tt>P</tt>"
and <tt>q()</tt> prints "<tt>Q</tt>". The interpretation of defaulted
parameters is determined by a procedure's type, not its value; the
assignment <tt>q := P</tt> changes <tt>q</tt>'s value, not its type.
<p>

Examples of procedure types:
</p><pre>    TYPE
      Integrand = PROCEDURE (x: REAL): REAL;
      Integrator = PROCEDURE(f: Integrand; lo, hi: REAL): REAL;

      TokenIterator = PROCEDURE(VAR t: Token) RAISES {TokenError};

      RenderProc = PROCEDURE(
        scene: REFANY;
        READONLY t: Transform := Identity)
</pre>
<p>

<a name="idx.60">In</a>
a procedure type, <tt>RAISES</tt> binds to the closest preceding 
<tt>PROCEDURE</tt>.
That is, the parentheses are required in:
</p><pre>    TYPE T = PROCEDURE (): (PROCEDURE ()) RAISES {}
</pre>
<p>

</p><h3><a name="ObjectsSect">2.2.9 Objects</a></h3>
<p>

An <em>object</em> is either <tt>NIL</tt> or a reference to a data
record paired with a method suite, which is a record of procedures that will 
accept the object as a first argument.
</p><p>

An object type determines the types of a prefix of the fields of the
data record, as if "<tt>OBJECT</tt>" were "<tt>REF RECORD</tt>".  But
in the case of an object type, the data record can contain additional fields
introduced by subtypes of the object type.  Similarly, the object type
determines a prefix of the method suite, but the suite can contain
additional methods introduced by subtypes.
</p><p>

<a name="idx.62">If</a>
<tt>o</tt> is an object, then <tt>o.f</tt> designates the data field named
<tt>f</tt> in <tt>o</tt>'s data record.
If <tt>m</tt> is one of <tt>o</tt>'s methods,
an invocation of the form
<a href="#ProcCallSect"><tt>o.m( ... )</tt></a>
denotes an execution of <tt>o</tt>'s <tt>m</tt> method.
An object's methods can be invoked, but not read or written.
</p><p>

If <tt>T</tt> is an object type and <tt>m</tt> is the name of one of <tt>
T</tt>'s methods, then <tt>T.m</tt> denotes <tt>T</tt>'s <tt>m</tt> method. 
This notation makes it convenient for a subtype method to invoke 
the corresponding method of one of its supertypes.
</p><p>

<a name="idx.63">A</a>
field or method in a subtype masks any field or method with the 
same name in the supertype.  To access such a masked field, use
<tt>NARROW</tt> to view the subtype variable as a member of the supertype,
as illustrated <a href="#idx.68a">below</a>.
</p><p>

Object assignment is reference assignment.  Objects cannot be
dereferenced, since the static type of an object variable does not determine
the type of its data record.  To copy the data record of one object
into another, the fields must be assigned individually.
</p><p>

<a name="idx.64">There</a>
are two predeclared object types: 
</p><pre>    ROOT           The traced object type with no fields or methods
    UNTRACED ROOT  The untraced object type with no fields or methods
</pre>
<p>

<a name="idx.65">The</a>
declaration of an object type has the form:
</p><pre>    TYPE T = ST OBJECT
               Fields
             METHODS
               Methods
             OVERRIDES
               Overrides
             END
</pre>
where <tt>ST</tt> is an optional supertype, <tt>Fields</tt> is a list of
field declarations, exactly as in a record type, <tt>Methods</tt> is a
list of <em>method declarations</em> and <tt>Overrides</tt> is a list of
<em>method overrides</em>.  The fields of <tt>T</tt> consist of the fields
of <tt>ST</tt> followed by the fields declared in <tt>Fields</tt>.
The methods of <tt>T</tt> consist of the methods of <tt>ST</tt> modified by
<tt>Overrides</tt> and followed by the methods declared in <tt>Methods</tt>.
<tt>T</tt> has the same reference class as <tt>ST</tt>.
<p>

The names introduced in <tt>Fields</tt> and <tt>Methods</tt> must be distinct
from one another and from the names overridden in <tt>Overrides</tt>.
If <tt>ST</tt> is omitted, it defaults to <tt>ROOT</tt>.  If <tt>ST</tt> is
untraced, then the fields must not include traced types.
(This restriction is lifted in <a href="#SafetySect">unsafe modules</a>.)
If <tt>ST</tt> is declared as an
<a href="#OpaqueSect">opaque type</a>,
the declaration of <tt>T</tt> is legal only in scopes where
<tt>ST</tt>'s concrete type is known to be an object type.
</p><p>

<a name="idx.66">The</a>
keyword <tt>OBJECT</tt> can optionally be preceded by "<tt>BRANDED</tt>"
or by "<tt>BRANDED b</tt>", where <tt>b</tt> is a text constant.  The meaning
is the same as in non-object reference types.
</p><p>

<a name="idx.67">A</a>
method declaration has the form:
</p><pre>    m sig := proc
</pre>
where <tt>m</tt> is an identifier, <tt>sig</tt> is a procedure signature,
and <tt>proc</tt> is a top-level procedure constant.  It specifies that
<tt>T</tt>'s <tt>m</tt> method has signature <tt>sig</tt>
and value <tt>proc</tt>.
If "<tt>:= proc</tt>" is omitted, "<tt>:= NIL</tt>" is assumed.
If <tt>proc</tt> is non-nil, its first parameter must have mode
<tt>VALUE</tt> and
type some supertype of <tt>T</tt>, and dropping its first parameter must
result in a signature that is covered by <tt>sig</tt>.
<p>

<a name="idx.68">A</a>
method override has the form:
</p><pre>    m := proc
</pre>
where <tt>m</tt> is the name of a method of the supertype <tt>ST</tt> and
<tt>proc</tt> is a top-level procedure constant.  It specifies that the
<tt>m</tt> method for <tt>T</tt> is proc, rather than <tt>ST.m</tt>.
If <tt>proc</tt> is non-nil,
its first parameter must have mode <tt>VALUE</tt> and type some supertype
of <tt>T</tt>, and dropping its first parameter must result in a signature
that is covered by the signature of <tt>ST</tt>'s <tt>m</tt> method.
<p>

<b>Examples.</b> Consider the following declarations:
</p><pre>    TYPE 
      A  = OBJECT a: INTEGER; METHODS p() END;
      AB = A OBJECT b: INTEGER END;

    PROCEDURE Pa(self: A) = ... ; 
    PROCEDURE Pab(self: AB) = ... ;
</pre>
The procedures <tt>Pa</tt> and <tt>Pab</tt> are candidate values for
the <tt>p</tt>
methods of objects of types <tt>A</tt> and <tt>AB</tt>.  For example:
<pre>    TYPE T1 = AB OBJECT OVERRIDES p := Pab END
</pre>
declares a type with an <tt>AB</tt> data record and a <tt>p</tt> method
that expects an <tt>AB</tt>.
<tt>T1</tt> is a valid subtype of <tt>AB</tt>.  Similarly,
<pre>    TYPE T2 = A OBJECT OVERRIDES p := Pa END
</pre>
declares a type with an <tt>A</tt> data record and a method that expects
an <tt>A</tt>.  <tt>T2</tt> is a valid subtype of <tt>A</tt>.  A more
interesting example is:
<pre>    TYPE T3 = AB OBJECT OVERRIDES p := Pa END
</pre>
which declares a type with an <tt>AB</tt> data record and a <tt>p</tt> method
that expects an <tt>A</tt>.  Since every <tt>AB</tt> is an <tt>A</tt>,
the method is not too choosy for the objects in which it will be placed.
<tt>T3</tt> is a valid subtype of <tt>AB</tt>.  In contrast,
<pre>    TYPE T4 = A OBJECT OVERRIDES p := Pab END
</pre>
attempts to declare a type with an <tt>A</tt> data record and a method 
that expects an <tt>AB</tt>; since not every <tt>A</tt> is an <tt>AB</tt>, 
the method is too choosy for the objects in which it would
be placed.  The declaration of <tt>T4</tt> is a static error.
<p>

The following example illustrates the difference between declaring
a new method and overriding an existing method.
<a name="idx.68a">After the declarations</a>
</p><pre>    TYPE
      A = OBJECT METHODS m() := P END;
      B = A OBJECT OVERRIDES m := Q END;
      C = A OBJECT METHODS m() := Q END;

    VAR
      a := NEW(A); b := NEW(B); c := NEW(C);
</pre>
we have that 
<pre>    a.m()  activates  P(a) 
    b.m()  activates  Q(b) 
    c.m()  activates  Q(c) 
</pre>
So far there is no difference between overriding and extending.  But
<tt>c</tt>'s method suite has two methods, while <tt>b</tt>'s has only one,
as can be revealed if <tt>b</tt> and <tt>c</tt> are viewed as members of
type <tt>A</tt>:
<pre>    NARROW(b, A).m()   activates  Q(b) 
    NARROW(c, A).m()   activates  P(c) 
</pre>
Here <tt>NARROW</tt> is used to view a variable of a subtype as a value
of its supertype.
It is more often used for the opposite purpose, when it requires a
<a href="#idx.198">runtime check</a>.
<p>

The last example uses object subtyping to define reusable queues.  First
the interface:
</p><pre>    TYPE
      Queue = RECORD head, tail: QueueElem END;
      QueueElem = OBJECT link: QueueElem END;

    PROCEDURE Insert (VAR q: Queue; x: QueueElem);
    PROCEDURE Delete (VAR q: Queue): QueueElem;
    PROCEDURE Clear  (VAR q: Queue);
</pre>
<p>

Then an example client:
</p><pre>    TYPE
      IntQueueElem = QueueElem OBJECT val: INTEGER END;
    VAR 
      q: Queue;
      x: IntQueueElem;
      ...
      Clear(q);
      x := NEW(IntQueueElem, val := 6);
      Insert(q, x);
      ...
      x := Delete(q)
</pre>
<p>

Passing <tt>x</tt> to <tt>Insert</tt> is safe,
since every <tt>IntQueueElem</tt> is a <tt>QueueElem</tt>.
Assigning the result of <tt>Delete</tt> to <tt>x</tt> cannot be
guaranteed valid at compile-time, since other subtypes
of <tt>QueueElem</tt> can be inserted into <tt>q</tt>, but the assignment
will produce a checked runtime error if the source value is not a member
of the target type.  Thus <tt>IntQueueElem</tt> bears the same relation
to <tt>QueueElem</tt> as <tt>[0..9]</tt> bears to <tt>INTEGER</tt>.
</p><p>

</p><h3><a name="SubtypingSect">2.2.10 Subtyping rules</a></h3>
<p>

We write <tt>T &lt;: U</tt> to indicate that <tt>T</tt> is a subtype
of <tt>U</tt> and <tt>U</tt> is a supertype of <tt>T</tt>.
</p><p>

<a name="idx.70">If</a>
<tt>T &lt;: U</tt>, then every value of type <tt>T</tt> is also a value 
of type <tt>U</tt>.  The converse does not hold:  for example, a record 
or array type with packed fields contains the same values as the 
corresponding type with unpacked fields, but there is no subtype 
relation between them.  This section presents the rules that define 
the subtyping relation.
</p><p>

For ordinal types <tt>T</tt> and <tt>U</tt>, we have <tt>T &lt;:
U</tt> if they have the same basetype and every member of <tt>T</tt>
is a member of <tt>U</tt>. That is, subtyping on ordinal types
reflects the subset relation on the value sets.  
</p><p>

<a name="idx.71">For array types,</a>
</p><pre>       (ARRAY OF)^m  ARRAY J_1 OF ... ARRAY J_n OF
          ARRAY K_1 OF ... ARRAY K_p OF T
    &lt;: (ARRAY OF)^m  (ARRAY OF)^n
          ARRAY I_1 OF ... ARRAY I_p OF T

    if NUMBER(I_i) = NUMBER(K_i)  for i = 1, ..., p.
</pre>
<p>

That is, an array type <tt>A</tt> is a subtype of an array type
<tt>B</tt> if they have the same ultimate element type, the same 
number of dimensions, and, for each dimension, either both are open
(as in the first m dimensions above),
or <tt>A</tt> is fixed and <tt>B</tt> is open
(as in the next n dimensions above), or they are 
both fixed and have the same size
(as in the last p dimensions above).
</p><p>

<a name="idx.72">
<pre>   NULL &lt;: REF T &lt;: REFANY
   NULL &lt;: UNTRACED REF T &lt;: ADDRESS
</pre>
</a>
</p><p>

That is, <tt>REFANY</tt> and <tt>ADDRESS</tt> contain all traced and
untraced references, respectively, and <tt>NIL</tt> is a member
of every reference type. These rules also apply to branded
types.
</p><p>

<a name="idx.73">
<pre>    NULL &lt;: PROCEDURE(A): R RAISES S   for any A, R, and S.
</pre>
</a>
That is, <tt>NIL</tt> is a member of every procedure type.  
</p><p>

</p><pre>    PROCEDURE(A): Q RAISES E  &lt;:  PROCEDURE(B): R RAISES F
    if signature "(B): R RAISES F" covers signature "(A): Q RAISES E".
</pre>
That is, for procedure types, <tt>T &lt;: U</tt> if 
they are the same except for parameter names, defaults, 
and raises sets, and the raises set for <tt>T</tt> is contained in the 
raises set for <tt>U</tt>.
<p>

<a name="idx.74">
<pre>    ROOT &lt;: REFANY
    UNTRACED ROOT &lt;: ADDRESS
    NULL &lt;: T OBJECT ... END &lt;: T
</pre>
</a>
That is, every object is a reference,
<tt>NIL</tt> is a member of every 
object type, and every subtype is included in its supertype. 
The third rule also applies to branded types.
</p><p>

<a name="idx.75">
<pre>    BITS n FOR T &lt;: T   and  T &lt;: BITS n FOR T
</pre>
</a>
That is, <tt>BITS FOR T</tt> has the same values as <tt>T</tt>.
</p><p>

</p><pre>    T &lt;: T  for all T
    T &lt;: U  and   U &lt;: V  implies  T &lt;: V  for all T, U, V.
</pre>
That is, <tt>&lt;:</tt> is reflexive and transitive. 
<p>

Note that <tt>T &lt;: U</tt> and <tt>U &lt;: T</tt> does not imply that
<tt>T</tt> and <tt>U</tt> are the same, since the subtype relation
is unaffected by parameter names, default values, and packing.
</p><p>

For example, consider:
</p><pre>    TYPE 
      T = [0..255];
      U = BITS 8 FOR [0..255];
      AT = ARRAY OF T;
      AU = ARRAY OF U;
</pre>
The types <tt>T</tt> and <tt>U</tt> are subtypes of one another but are 
not the same. The types <tt>AT</tt> and <tt>AU</tt> are 
unrelated by the subtype relation.
<p>

</p><h3><a name="BuiltinsSect">2.2.11 Predeclared opaque types</a></h3>
<p>

The language predeclares the two types:
</p><pre>    TEXT  &lt;: REFANY
    MUTEX &lt;: ROOT
</pre>
which represent text strings and mutual exclusion semaphores, 
respectively. These are <a href="#OpaqueSect">opaque types</a>.
Their properties are specified in the required interfaces
<a href="http://www.research.compaq.com/SRC/m3defn/html/text-intf.html"><tt>Text</tt></a> and
<a href="http://www.research.compaq.com/SRC/m3defn/html/thread-intf.html"><tt>Thread</tt></a>.
<p>

</p><h2><a name="StatementsSect">2.3 Statements</a></h2>
<p>

</p><blockquote><em>
Look into any carpenter's tool-bag and see how many different  
hammers, chisels, planes and screw-drivers he keeps there---not for  
ostentation or luxury, but for different sorts of jobs.  
---Robert Graves and Alan Hodge
</em></blockquote>
<p>

<a name="idx.77">Executing</a>
a statement produces a computation that can halt (normal
outcome), raise an exception, cause a checked runtime error, or
loop forever.  If the outcome is an exception, it can optionally 
be paired with an argument.
</p><p>

<a name="idx.78">We</a>
define the semantics of <tt>EXIT</tt> and <tt>RETURN</tt> with exceptions 
called the <em>exit-exception</em> and the <em>return-exception</em>.  
The exit-exception takes no argument; the return-exception takes 
an argument of arbitrary type.  Programs cannot name these exceptions 
explicitly.
</p><p>

Implementations should speed up normal outcomes at the expense of 
exceptions (except for the return-exception and exit-exception). 
Expending a thousand instructions per exception raised to save 
one instruction per procedure call would be reasonable.
</p><p>

If an expression is evaluated as part of the execution of a statement,
and the evaluation raises an exception, then the exception becomes
the outcome of the statement.  
</p><p>

The empty statement is a no-op.  In this report, empty statements
are written <tt>(*skip*)</tt>.
</p><p>

</p><h3><a name="AssignmentSect">2.3.1 Assignment</a></h3>
<p>

To specify the typechecking of assignment statements we need to define 
"assignable", which is a relation between types and types, between 
expressions and variables, and between expressions and types.
</p><p>

<a name="type-assignable">A</a> type <tt>T</tt> is <em>assignable</em>
to a type <tt>U</tt> if:
</p><ul>
<li>
<a href="#SubtypingSect"><tt>T &lt;: U</tt></a>, or
</li><li>
<a href="#SubtypingSect"><tt>U &lt;: T</tt></a> and <tt>T</tt> is an
array or a reference type other than <tt>ADDRESS</tt> (This
restriction is lifted in <a href="#SafetySect">unsafe modules</a>.), or
</li><li>
<tt>T</tt> and <tt>U</tt> are ordinal types with at least one member 
in common. 
</li></ul>
<p>

<a name="idx.80">An</a> expression <tt>e</tt> is <em>assignable</em> to
a variable <tt>v</tt> if:
</p><ul>
<li>
the type of <tt>e</tt> is <a href="#type-assignable">assignable</a> to
the type of <tt>v</tt>, and
</li><li>
the value of <tt>e</tt> is a member of the type of <tt>v</tt>, is 
not a local procedure, and if it is an array, then it has the same 
shape as <tt>v</tt>.
</li></ul>
<p>

<a name="idx.81">The</a> first point can be checked statically; the
others generally require runtime checks. Since there is no way to
determine statically whether the value of a procedure parameter is
local or global, assigning a local procedure is a runtime rather than
a static error.
</p><p>

<a name="idx.81b">An</a> expression <tt>e</tt> is <em>assignable</em>
to a type <tt>T</tt> if <tt>e</tt> is <a href="#idx.80">assignable</a>
to some variable of type <tt>T</tt>. (If <tt>T</tt> is not an open
array type, this is the same as saying that <tt>e</tt> is assignable
to any variable of type <tt>T</tt>.)
</p><p>

<a name="idx.82">An</a> assignment statement has the form:
</p><pre>    v := e
</pre>
where <tt>v</tt> is a writable designator and <tt>e</tt> is an expression
assignable to the variable designated by <tt>v</tt>.  The statement sets
<tt>v</tt> to the value of <tt>e</tt>.  The order of evaluation of
<tt>v</tt> and <tt>e</tt> is undefined, but <tt>e</tt> will be
evaluated before <tt>v</tt> is updated.
In particular, if <tt>v</tt> and <tt>e</tt> are overlapping
<a href="#idx.164">subarrays</a>, the assignment is performed in such
a way that no element is used as a target before it is used as a source.
<p>

Examples of assignments:
</p><pre>    VAR
      x: REFANY;
      a: REF INTEGER;
      b: REF BOOLEAN;

    a := b;  (* static error *)
    x := a;  (* no possible error *)
    a := x   (* possible checked runtime error *)
</pre>
<p>

<a name="idx.83">The</a>
same comments would apply if <tt>x</tt> had an ordinal type with 
non-overlapping subranges <tt>a</tt> and <tt>b</tt>, or if <tt>x</tt> had 
an object type and <tt>a</tt> and <tt>b</tt> had incompatible subtypes.  
The type <tt>ADDRESS</tt> is treated differently from other reference 
types, since a runtime check cannot be performed on the assignment 
of raw addresses.  For example:
</p><pre>    VAR
      x: ADDRESS;
      a: UNTRACED REF INTEGER;
      b: UNTRACED REF BOOLEAN;

    a := b;  (* static error *)
    x := a;  (* no possible error *)
    a := x   (* static error in safe modules *)
</pre>
<p>

</p><h3><a name="ProcCallSect">2.3.2 Procedure call</a></h3>
<p>

A procedure call has the form:
</p><pre>    P(Bindings)
</pre>
where <tt>P</tt> is a procedure-valued expression and <tt>Bindings</tt> 
is a list of <em>keyword</em> or <em>positional</em> bindings. A keyword 
binding has the form <tt>name := actual</tt>, where <tt>actual</tt> is 
an expression and <tt>name</tt> is an identifier.  A positional binding 
has the form <tt>actual</tt>, where <tt>actual</tt> is an expression.  
When keyword and positional bindings are mixed in a call, the 
positional bindings must precede the keyword bindings.  If the list 
of bindings is empty, the parentheses are still required.
<p>

<a name="idx.85">The</a>
list of bindings is rewritten to fit the signature of <tt>P</tt>'s
type as follows:  First, each positional binding <tt>actual</tt> is
converted and added to the list of keyword bindings by supplying the
name of the <tt>i</tt>'th formal parameter, where <tt>actual</tt> is the
<tt>i</tt>'th binding in <tt>Bindings</tt>.  Second, for each parameter that
has a default and is not bound after the first step,
the binding <tt>name := default</tt> is added to the list of bindings,
where <tt>name</tt>
is the name of the parameter and <tt>default</tt> is its default value.
The rewritten list of bindings must bind only formal parameters and 
must bind each formal parameter exactly once.
For example, suppose that the type of <tt>P</tt> is
</p><pre>    PROCEDURE(ch: CHAR; n: INTEGER := 0)
</pre>
Then the following calls are all equivalent: 
<pre>    P('a', 0)
    P('a')
    P(ch := 'a')
    P(n := 0, ch := 'a')
    P('a', n := 0)
</pre>
The call <tt>P()</tt> is illegal, since it doesn't bind
<tt>ch</tt>.  The call <tt>P(n := 0, 'a')</tt> is illegal, since it has
a keyword parameter before a positional parameter.
<p>

<a name="idx.86">For</a>
a <tt>READONLY</tt> or <tt>VALUE</tt> parameter, the actual can be 
any expression assignable to the type of the formal (except that 
the prohibition against assigning local procedures is relaxed). For 
a <tt>VAR</tt> parameter, the actual must be a
<a href="#DesignatorSect">writable designator</a> whose 
type is the same as that of the formal, or, in case of a <tt>VAR</tt> 
array parameter, assignable to that of the formal (see the
<a href="#DesignatorSect">section</a> on designators).
</p><p>

<a name="idx.87">A</a>
<tt>VAR</tt> formal is bound to the variable designated by the 
corresponding actual; that is, it is aliased.  A <tt>VALUE</tt> formal 
is bound to a variable with an unused location and initialized to 
the value of the corresponding actual.  A <tt>READONLY</tt> formal is 
treated as a <tt>VAR</tt> formal if the actual is a designator and the 
type of the actual is the same as the type of the formal (or an array 
type that is assignable to the type of the formal); otherwise 
it is treated as a <tt>VALUE</tt> formal.
</p><p>

<a name="idx.88">Implementations</a>
are allowed to forbid <tt>VAR</tt> or <tt>READONLY</tt> 
parameters of packed types.
</p><p>

<a name="idx.89">To</a>
execute the call, the procedure <tt>P</tt> and its arguments are 
evaluated, the formal parameters are bound, and the body of the 
procedure is executed.  The order of evaluation of <tt>P</tt> and its 
actual arguments is undefined.  It is a checked runtime error to 
call an undefined or <tt>NIL</tt> procedure.
</p><p>

<a name="idx.90">It</a>
is a checked runtime error for a procedure to raise an exception 
not included in its raises set (If an implementation 
maps this runtime error into an exception, the exception is implicitly 
included in all <tt>RAISES</tt> clauses.) or for a function procedure 
to fail to return a result.
</p><p>

A procedure call is a statement only if the procedure is proper.  To
call a function procedure and discard its result, use
<a href="#idx.92"><tt>EVAL</tt></a>.
</p><p>

<a name="idx.91">A</a>
procedure call can also have the form:
</p><pre>    o.m(Bindings)
</pre>
where <tt>o</tt> is an object and <tt>m</tt> names one of
<tt>o</tt>'s methods.  This is equivalent to:
<pre>    (o's m method) (o, Bindings)
</pre>
<p>

</p><h3><a name="idx.92">2.3.3 Eval</a></h3>
<p>

An <tt>EVAL</tt> statement has the form:
</p><pre>    EVAL e
</pre>
where <tt>e</tt> is an expression.  The effect is to evaluate <tt>e</tt> and
ignore the result.  For example:
<pre>    EVAL Thread.Fork(p)
</pre>
<p>

</p><h3><a name="BlocksSect">2.3.4 Block statement</a></h3>
<p>

A block statement has the form:
</p><pre>    Decls BEGIN S END
</pre>
where <tt>Decls</tt> is a sequence of declarations and <tt>S</tt>
is a statement.
The block introduces the constants, types, variables, 
and procedures declared in <tt>Decls</tt> and then executes <tt>S</tt>.
The scope of the
<a href="#DeclsSect">declared names</a>
is the block.
<p>

</p><h3><a name="SequenceSect">2.3.5 Sequential composition</a></h3>
<p>

A statement of the form:
</p><pre>    S_1; S_2
</pre>
executes <tt>S_1</tt>, and then if the outcome is normal, executes
<tt>S_2</tt>.  If the outcome of <tt>S_1</tt> is an exception, <tt>S_2</tt>
is ignored.
<p>

Some programmers use the semicolon as a statement
terminator, some as a statement separator.  Similarly, some
use the vertical bar in case statements as a case initiator, some
as a separator.  Modula-3 allows both styles.  This report
uses both operators as separators.
</p><p>

</p><h3><a name="RaiseSect">2.3.6 Raise</a></h3>
<p>

A <tt>RAISE</tt> statement without an argument has the form:
</p><pre>    RAISE e
</pre>
where <tt>e</tt> is an exception that takes no argument.  The outcome 
of the statement is the exception <tt>e</tt>.  A <tt>RAISE</tt> statement 
with an argument has the form:
<pre>    RAISE e(x)
</pre>
where <tt>e</tt> is an exception that takes an argument and <tt>x</tt> is
an expression assignable to <tt>e</tt>'s argument type.  The outcome is
the exception <tt>e</tt> paired with the argument <tt>x</tt>.
<p>

</p><h3><a name="TryExceptSect">2.3.7 Try Except</a></h3>
<p>

A <tt>TRY-EXCEPT</tt> statement has the form:
</p><pre>    TRY
      Body
    EXCEPT 
      id_1 (v_1) =&gt; Handler_1
    | ... 
    | id_n (v_n) =&gt; Handler_n
    ELSE Handler_0 
    END
</pre>
where <tt>Body</tt> and each <tt>Handler</tt> are statements,
each <tt>id</tt> names an exception, and each <tt>v_i</tt> is an identifier.
The "<tt>ELSE Handler_0</tt>" and each "<tt>(v_i)</tt>" are optional.  
It is a static error for an exception to be named more than once 
in the list of <tt>id</tt>'s.
<p>

<a name="idx.97">The</a>
statement executes <tt>Body</tt>.  If the outcome is normal, the 
except clause is ignored.  If <tt>Body</tt> raises any listed exception 
<tt>id_i</tt>, then <tt>Handler_i</tt> is executed.  If <tt>Body</tt> 
raises any other exception and "<tt>ELSE Handler_0</tt>" is present, 
then it is executed.  In either case, the outcome of the <tt>TRY</tt> 
statement is the outcome of the selected handler.  If <tt>Body</tt> 
raises an unlisted exception and "<tt>ELSE Handler_0</tt>" is 
absent, then the outcome of the <tt>TRY</tt> statement is the exception 
raised by <tt>Body</tt>.
</p><p>

<a name="idx.98">Each</a>
<tt>(v_i)</tt> declares a variable whose type is the argument 
type of the exception <tt>id_i</tt> and whose scope is
<tt>Handler_i</tt>. When an exception <tt>id_i</tt> paired with an 
argument <tt>x</tt> is handled, <tt>v_i</tt> is initialized to
<tt>x</tt> before <tt>Handler_i</tt> is executed.  It is a static error 
to include <tt>(v_i)</tt> if exception <tt>id_i</tt> does not take 
an argument.  
</p><p>

If <tt>(v_i)</tt> is absent, then <tt>id_i</tt> can be a list of 
exceptions separated by commas, as shorthand for a list in 
which the rest of the handler is repeated for each exception.
That is:
</p><pre>    id_1, ..., id_n =&gt; Handler
</pre>
is shorthand for:
<pre>    id_1 =&gt; Handler | ... | id_n =&gt; Handler
</pre>
<p>

<a name="idx.99">It</a>
is a checked runtime error to raise an exception outside the dynamic 
scope of a handler for that exception.  A "<tt>TRY EXCEPT ELSE</tt>"
counts as a handler for all exceptions.
</p><p>

</p><h3><a name="TryFinallySect">2.3.8 Try Finally</a></h3>
<p>

A statement of the form:
</p><pre>    TRY S_1 FINALLY S_2 END
</pre>
executes statement <tt>S_1</tt> and then statement <tt>S_2</tt>.  
If the outcome of <tt>S_1</tt> is normal, the <tt>TRY</tt> statement 
is equivalent to <tt>S_1; S_2</tt>.  If the outcome of <tt>
S_1</tt> is an exception and the outcome of <tt>S_2</tt> is normal, 
the exception from <tt>S_1</tt> is re-raised after <tt>S_2</tt> 
is executed.  If both outcomes are exceptions, the outcome of the 
<tt>TRY</tt> is the exception from <tt>S_2</tt>.
<p>

</p><h3><a name="LoopSect">2.3.9 Loop</a></h3>
<p>

A statement of the form:
</p><pre>    LOOP S END
</pre>
repeatedly executes <tt>S</tt> until it raises the exit-exception.
Informally it is like:
<pre>    TRY S; S; S; ... EXCEPT  exit-exception  =&gt; (*skip*)  END
</pre>
<p>

</p><h3><a name="idx.102">2.3.10 Exit</a></h3>
<p>

The statement
</p><pre>    EXIT
</pre>
raises the exit-exception.  An <tt>EXIT</tt> statement must be textually
enclosed by a
<a href="#LoopSect"><tt>LOOP</tt></a>,
<a href="#WhileSect"><tt>WHILE</tt></a>,
<a href="#RepeatSect"><tt>REPEAT</tt></a>,
or
<a href="#ForSect"><tt>FOR</tt></a>
statement.
<p>

<a name="idx.103">We</a>
define <tt>EXIT</tt> and <tt>RETURN</tt> in terms of exceptions in order
to specify their interaction with the exception handling statements.
As a pathological example, consider the following code, which is an
elaborate infinite loop:
</p><pre>    LOOP
      TRY
        TRY EXIT FINALLY RAISE E END
      EXCEPT
        E =&gt; (*skip*)
      END
    END
</pre>
<p>

</p><h3><a name="ReturnSect">2.3.11 Return</a></h3>
<p>

A <tt>RETURN</tt> statement for a
<a href="#idx.55">proper procedure</a>
has the form:
</p><pre>    RETURN
</pre>
The statement raises the return-exception without an argument.  It 
is allowed only in the body of a proper procedure.
<p>

<a name="idx.105">A</a>
<tt>RETURN</tt> statement for a
<a href="#idx.55">function procedure</a>
has the form:
</p><pre>    RETURN Expr
</pre>
where <tt>Expr</tt> is an expression assignable to the result type of 
the procedure.  The statement raises the return-exception with the 
argument <tt>Expr</tt>.  It is allowed only in the body of a function 
procedure.
<p>

<a name="idx.106">Failure</a>
to return a value from a function procedure is a checked runtime
error.
</p><p>

The effect of raising the return exception is to terminate the current
procedure activation.  To be precise, a call on a proper procedure
with body <tt>B</tt> is equivalent (after binding the arguments) to:
</p><pre>    TRY B EXCEPT return-exception =&gt; (*skip*) END
</pre>
A call on a function procedure with body <tt>B</tt> is equivalent to:
<pre>    TRY 
      B;  (error: no returned value)  
    EXCEPT 
      return-exception (v) =&gt; (the result becomes v)  
    END
</pre>
<p>

</p><h3><a name="IfSect">2.3.12 If</a></h3>
<p>

An <tt>IF</tt> statement has the form:
</p><pre>    IF    B_1 THEN S_1
    ELSIF B_2 THEN S_2
      ...
    ELSIF B_n THEN S_n
    ELSE S_0
    END
</pre>
<p>

where the <tt>B</tt>'s are boolean expressions and the <tt>S</tt>'s are 
statements.  The "<tt>ELSE S_0</tt>" and each
"<tt>ELSIF B_i THEN S_i</tt>" are optional.
</p><p>

The statement evaluates the <tt>B</tt>'s in order until some
<tt>B_i</tt> evaluates to <tt>TRUE</tt>, and then executes <tt>S_i</tt>.
If none of the expressions evaluates to <tt>TRUE</tt> and
"<tt>ELSE S_0</tt>" is present, <tt>S_0</tt> is executed.
If none of the expressions evaluates 
to <tt>TRUE</tt> and "<tt>ELSE S_0</tt>" is absent, the statement 
is a no-op (except for any side-effects of the <tt>B</tt>'s).
</p><p>

</p><h3><a name="WhileSect">2.3.13 While</a></h3>
<p>

If <tt>B</tt> is an expression of type <tt>BOOLEAN</tt>
and <tt>S</tt> is a statement:
</p><pre>    WHILE B DO S END
</pre>
is shorthand for:
<pre>    <a href="#LoopSect">LOOP</a> <a href="#IfSect">IF</a> B THEN S ELSE <a href="#idx.102">EXIT</a> END END
</pre>
<p>

</p><h3><a name="RepeatSect">2.3.14 Repeat</a></h3>
<p>

If <tt>B</tt> is an expression of type <tt>BOOLEAN</tt>
and <tt>S</tt> is a statement:
</p><pre>    REPEAT S UNTIL B
</pre>
is shorthand for:
<pre>    LOOP S; IF B THEN EXIT END END
</pre>
<p>

</p><h3><a name="idx.110">2.3.15 With</a></h3>
<p>

A <tt>WITH</tt> statement has the form: 
</p><pre>    WITH id = e DO S END
</pre>
where <tt>id</tt> is an identifier, <tt>e</tt> an expression,
and <tt>S</tt> a statement.
The statement declares <tt>id</tt> with scope <tt>S</tt> as an
alias for the variable <tt>e</tt> or as a readonly name for 
the value <tt>e</tt>. The expression <tt>e</tt> is evaluated once, at entry 
to the <tt>WITH</tt> statement. 
<p>

The statement is like the procedure call <tt>P(e)</tt>, where <tt>P</tt>
is declared as:
</p><pre>    PROCEDURE P(mode id: type of e) = BEGIN S END P;
</pre>
If <tt>e</tt> is a
<a href="#DesignatorSect">writable designator</a>,
<tt>mode</tt> is <tt>VAR</tt>; otherwise,
<tt>mode</tt> is <tt>READONLY</tt>.
The only difference
between the <tt>WITH</tt> statement and the call <tt>P(e)</tt> is that free
variables, <tt>RETURN</tt>s, and <tt>EXIT</tt>s that occur in the <tt>WITH</tt>
statement are interpreted in the context of the <tt>WITH</tt> statement,
not in the context of <tt>P</tt> (see the
<a href="#DesignatorSect">section</a> on designators).
<p>

<a name="idx.111">A</a>
single <tt>WITH</tt> can contain multiple bindings, which are evaluated
sequentially.  That is:
</p><pre>    WITH id_1 = e_1, id_2 = e_2, ...
</pre>
is equivalent to:
<pre>    WITH id_1 = e_1 DO
      WITH id_2 = e_2 DO ....
</pre>
<p>

</p><h3><a name="ForSect">2.3.16 For</a></h3>
<p>

A <tt>FOR</tt> statement has the form:
</p><pre>    FOR id := first TO last BY step DO S END
</pre>
where <tt>id</tt> is an identifier, <tt>first</tt> and <tt>last</tt> are 
ordinal expressions with the same base type, 
<tt>step</tt> is an integer-valued expression, and <tt>S</tt> is a statement. 
"<tt>BY step</tt>" is optional; if omitted, <tt>step</tt> defaults to 
<tt>1</tt>.
<p>

The identifier <tt>id</tt> denotes a readonly variable whose scope is 
<tt>S</tt> and whose type is the common basetype of <tt>first</tt> and 
<tt>last</tt>. 
</p><p>

If <tt>id</tt> is an integer, the statement steps <tt>id</tt> through the 
values <tt>first</tt>, <tt>first+step</tt>, <tt>first+2*step</tt>, 
<tt>...</tt>, stopping when the value of <tt>id</tt> passes <tt>last</tt>.  
<tt>S</tt> executes once for each value; if the sequence of values is 
empty, <tt>S</tt> never executes.  The expressions <tt>first</tt>,
<tt>last</tt>, and <tt>step</tt> are evaluated once,
before the loop is entered.  
If <tt>step</tt> is negative, the loop iterates downward.
</p><p>

The case in which <tt>id</tt> is an element of an enumeration is similar. 
In either case, the semantics are defined precisely by the following 
rewriting, in which <tt>T</tt> is the type of <tt>id</tt> and in which 
<tt>i</tt>, <tt>done</tt>, and <tt>delta</tt> stand for variables that do 
not occur in the <tt>FOR</tt> statement:
</p><pre>    VAR
      i := ORD(first); done := ORD(last); delta := step;
    BEGIN
      IF delta &gt;= 0 THEN
        WHILE i &lt;= done DO 
          WITH id = VAL(i, T) DO S END; INC(i, delta)
        END
      ELSE
        WHILE i &gt;= done DO
          WITH id = VAL(i, T) DO S END; INC(i, delta)
        END
      END
    END
</pre>
<p>

If the upper bound of the loop is <tt>LAST(INTEGER)</tt>, it should be
rewritten as a <tt>WHILE</tt> loop to avoid overflow.
</p><p>

</p><h3><a name="CaseSect">2.3.17 Case</a></h3>
<p>

A <tt>CASE</tt> statement has the form:
</p><pre>    CASE Expr OF  
      L_1 =&gt; S_1 
    | ...
    | L_n =&gt; S_n
    ELSE S_0 
    END
</pre>
where <tt>Expr</tt> is an expression whose type is an ordinal type and 
each <tt>L</tt> is a list of constant expressions or ranges of constant 
expressions denoted by "<tt>e_1..e_2</tt>", which represent 
the values from <tt>e_1</tt> to <tt>e_2</tt> inclusive.  If <tt>
e_1</tt> exceeds <tt>e_2</tt>, the range is empty.  It is a static 
error if the sets represented by any two <tt>L</tt>'s overlap or if 
the value of any of the constant expressions is not a member of the 
type of <tt>Expr</tt>.  The "<tt>ELSE S_0</tt>" is optional.
<p>

<a name="idx.114">The</a>
statement evaluates <tt>Expr</tt>.  If the resulting value is in any
<tt>L_i</tt>, then <tt>S_i</tt> is executed.  If the value is
in no <tt>L_i</tt> and "<tt>ELSE S_0</tt>" is present, then it is executed.
If the value is in no <tt>L_i</tt> and "<tt>ELSE S_0</tt>" is absent,
a checked runtime error occurs.
</p><p>

</p><h3><a name="TypecaseSect">2.3.18 Typecase</a></h3>
<p>

A <tt>TYPECASE</tt> statement has the form:
</p><pre>    TYPECASE Expr OF
      T_1 (v_1) =&gt; S_1
    | ...
    | T_n (v_n) =&gt; S_n
    ELSE S_0
    END
</pre>
where <tt>Expr</tt> is an expression whose type is a reference type, 
the <tt>S</tt>'s are statements, the <tt>T</tt>'s are reference types, 
and the <tt>v</tt>'s are identifiers.  It is a static error if <tt>
Expr</tt> has type <tt>ADDRESS</tt> or if any <tt>T</tt> is not a subtype of 
the type of <tt>Expr</tt>.  The "<tt>ELSE S_0</tt>" 
and each "<tt>(v)</tt>" are optional.
<p>

<a name="idx.116">The</a>
statement evaluates <tt>Expr</tt>.  If the resulting reference value
is a member of any listed type <tt>T_i</tt>, then <tt>S_i</tt> is executed,
for the minimum such i.  (Thus a <tt>NULL</tt> case is useful only if it
comes first.)  If the value is a member of no listed type and
"<tt>ELSE S_0</tt>" is present, then it is executed.  If the value is a member
of no listed type and "<tt>ELSE S_0</tt>" is absent, a checked runtime error
occurs.
</p><p>

Each <tt>(v_i)</tt> declares a variable whose type is <tt>T_i</tt> and
whose scope is <tt>S_i</tt>.  If <tt>v_i</tt> is present, it is
initialized to the value of <tt>Expr</tt> before <tt>S_i</tt> is
executed.
</p><p>

If <tt>(v_i)</tt> is absent, then <tt>T_i</tt> can be a list of type
expressions separated by commas, as shorthand for a list in
which the rest of the branch is repeated for each type expression.
That is:
</p><pre>    T_1, ..., T_n =&gt; S
</pre>
is shorthand for:
<pre>    T_1 =&gt; S | ... | T_n =&gt; S
</pre>	
<p>

For example:
</p><pre>    PROCEDURE ToText(r: REFANY): TEXT =
      (* Assume r = NIL or r^ is a BOOLEAN or INTEGER. *)
      BEGIN
        TYPECASE r OF
          NULL =&gt; RETURN "NIL"
        | REF BOOLEAN (rb) =&gt; RETURN Fmt.Bool(rb^)
        | REF INTEGER (ri) =&gt; RETURN Fmt.Int(ri^)
        END
      END ToText;
</pre>
<p>

</p><h3><a name="LockSect">2.3.19 Lock</a></h3>
<p>

A <tt>LOCK</tt> statement has the form: 
</p><pre>    LOCK mu DO S END
</pre>
where <tt>S</tt> is a statement and <tt>mu</tt> is an expression.
It is equivalent to:
<pre>    VAR m := mu; BEGIN
      <a href="http://www.research.compaq.com/SRC/m3defn/html/thread-intf.html">Thread</a>.Acquire(m);
      TRY S FINALLY <a href="http://www.research.compaq.com/SRC/m3defn/html/thread-intf.html">Thread</a>.Release(m) END
    END
</pre>
where <tt>m</tt> stands for a variable that does not occur in <tt>S</tt>.
<p>

</p><h3><a name="IncDecSect">2.3.20 Inc and Dec</a></h3>
<p>

<tt>INC</tt> and <tt>DEC</tt> statements have the form:
</p><pre>    INC(v, n)
    DEC(v, n)
</pre>
where <tt>v</tt> designates a variable of an ordinal type
and <tt>n</tt> is an optional integer-valued argument.  If omitted, 
<tt>n</tt> defaults to 1.  The statements increment and decrement
<tt>v</tt> by <tt>n</tt>, respectively.
The statements are equivalent to:
<pre>    WITH x = v DO x := VAL(ORD(x) + n, T) END
    WITH x = v DO x := VAL(ORD(x) - n, T) END
</pre>
where <tt>T</tt> is the type of <tt>v</tt> and <tt>x</tt> stands for
a variable that does not appear in <tt>n</tt>.  As a 
consequence, the statements check for range errors.
<p>

In <a href="#SafetySect">unsafe modules</a>,
<tt>INC</tt> and <tt>DEC</tt> are extended to <tt>ADDRESS</tt>.
</p><p>

</p><h2><a name="DeclsSect">2.4 Declarations</a></h2>
<p>

</p><blockquote><em>
There are two basic methods of declaring high or low before the showdown
in all High-Low Poker games.  They are (1) simultaneous declarations,
and (2) consecutive declarations <tt>....</tt>  It is a sad but true fact that
the consecutive method spoils the game.                               
---John Scarne's Guide to Modern Poker
</em></blockquote>
<p>

<a name="idx.119">A</a>
declaration introduces a name for a constant, type, variable, exception,
or procedure.  The scope of the name is the block containing the
declaration.  A block has the form:
</p><pre>    Decls BEGIN S END
</pre>
<a name="idx.120">where</a>
<tt>Decls</tt> is a sequence of declarations and <tt>S</tt> is a
statement, the executable part of the block.  A block can appear as
a statement or as the body of a module or procedure.  The declarations
of a block can introduce a name at most once, though a name can be
redeclared in nested blocks, and a procedure declared in an interface
can be redeclared in a <a href="#UnitsSect">module</a>
exporting the interface. The order of declarations
in a block does not matter, except to determine the order of
initialization of variables.
<p>

</p><h3><a name="TypeDeclsSect">2.4.1 Types</a></h3>
<p>

If <tt>T</tt> is an identifier and <tt>U</tt> a type
(or type expression, since a type expression is allowed
wherever a type is required), then:
</p><pre>    TYPE T = U
</pre>
declares <tt>T</tt> to be the type <tt>U</tt>.  
<p>

</p><h3><a name="idx.122">2.4.2 Constants</a></h3>
<p>

If <tt>id</tt> is an identifier, <tt>T</tt> a type,
and <tt>C</tt> a constant expression, then:
</p><pre>    CONST id: T = C
</pre>
declares <tt>id</tt> as a constant with the type <tt>T</tt> and the value
of <tt>C</tt>. The "<tt>:  T</tt>" can be omitted, in which case the type
of <tt>id</tt> is the type of <tt>C</tt>. If <tt>T</tt> is present it must
contain <tt>C</tt>.
<p>

</p><h3><a name="VarsSect">2.4.3 Variables</a></h3>
<p>

If <tt>id</tt> is an identifier, <tt>T</tt> a non-empty type other than 
an open array type, and <tt>E</tt> an expression, then:
</p><pre>    VAR id: T := E
</pre>
declares <tt>id</tt> as a variable of type <tt>T</tt> whose initial value 
is the value of <tt>E</tt>. Either "<tt>:= E</tt>" or "<tt>: T</tt>" 
can be omitted, but not both. If <tt>T</tt> is omitted, it is taken 
to be the type of <tt>E</tt>. If <tt>E</tt> is omitted, the initial value 
is an arbitrary value of type <tt>T</tt>. If both are present, <tt>
E</tt> must be <a href="#idx.81b">assignable</a> to <tt>T</tt>.
<p>

<a name="idx.124">The</a>
initial value is a shorthand that is equivalent to inserting the
assignment <tt>id := E</tt> at the beginning of the executable
part of the block.
If several variables have initial values, their assignments are inserted
in the order they are declared.  For example:
</p><pre>    VAR i: [0..5] := j; j: [0..5] := i; BEGIN S END
</pre>	
initializes <tt>i</tt> and <tt>j</tt> to the same arbitrary value
in <tt>[0..5]</tt>; 
it is equivalent to:
<pre>    VAR i: [0..5]; j: [0..5]; BEGIN i := j; j := i; S END
</pre>	
<p>

If a sequence of identifiers share the same type and initial value,
<tt>id</tt> can be a list of identifiers separated by commas.  Such
a list is shorthand for a list in which the type and
initial value are repeated for each identifier.
That is:
</p><pre>    VAR v_1, ..., v_n: T := E
</pre>	
is shorthand for:
<pre>    VAR v_1: T := E; ...; VAR v_n: T := E
</pre>	
This means that <tt>E</tt> is evaluated <tt>n</tt> times.
<p>

</p><h3><a name="ProcsSect">2.4.4 Procedures</a></h3>
<p>

There are two forms of procedure declaration:
</p><pre>    PROCEDURE id sig = B id

    PROCEDURE id sig
</pre>
<a name="idx.126">where</a>
<tt>id</tt> is an identifier, <tt>sig</tt> is a procedure signature, and
<tt>B</tt> is a block.  In both cases, the type of <tt>id</tt> is the procedure
type determined by <tt>sig</tt>.  The first form is allowed only in 
modules; the second form is allowed only in interfaces.
<p>

<a name="idx.127">The</a>
first form declares <tt>id</tt> as a procedure constant whose signature
is <tt>sig</tt>, whose body is <tt>B</tt>, and whose environment is the scope
containing the declaration.  The parameter names are treated as if
they were declared at the outer level of <tt>B</tt>; the parameter types
and default values are evaluated in the scope containing the procedure
declaration.  The procedure name <tt>id</tt> must be repeated after the
<tt>END</tt> that terminates the body.
</p><p>

The second form declares <tt>id</tt> to be a procedure constant whose 
signature is <tt>sig</tt>.  The procedure body is specified in a module 
exporting the interface, by a declaration of the first form.
</p><p>

</p><h3><a name="idx.128">2.4.5 Exceptions</a></h3>
<p>

If <tt>id</tt> is an identifier and <tt>T</tt> a type other than
an open array type, then:
</p><pre>    EXCEPTION id(T)
</pre>
declares <tt>id</tt> as an exception with argument type <tt>T</tt>.
If "<tt>(T)</tt>" is omitted, the exception takes no argument.
An exception declaration is allowed only in an interface or in the
outermost scope of a module.
All declared exceptions are distinct.
<p>

</p><h3><a name="OpaqueSect">2.4.6 Opaque types</a></h3>
<p>

An <em>opaque type</em> is a name that denotes an unknown subtype of some
given reference type.  For example, an opaque subtype of <tt>REFANY</tt> is
an unknown traced reference type; an opaque subtype of
<tt>UNTRACED ROOT</tt>
is an unknown untraced object type.  The actual type denoted by an
opaque type name is called its <em>concrete type</em>.
</p><p>

Different scopes can reveal different information about an opaque type.
For example, what is known in one scope only to be a subtype of <tt>REFANY</tt>
could be known in another scope to be a subtype of <tt>ROOT</tt>.
</p><p>

An opaque type declaration has the form:
</p><pre>    TYPE T &lt;: U
</pre>
where <tt>T</tt> is an identifier and <tt>U</tt> an expression denoting a
reference type.  It introduces the name <tt>T</tt> as an opaque type and
reveals that <tt>U</tt> is a supertype of <tt>T</tt>. The concrete type of
<tt>T</tt> must be revealed elsewhere in the program.
<p>

</p><h3><a name="RevelationsSect">2.4.7 Revelations</a></h3>
<p>

A <em>revelation</em> introduces information about an opaque type into
a scope.  Unlike other declarations, revelations introduce no new names.
</p><p>

There are two kinds of revelations, <em>partial</em> and <em>complete</em>.
A program can contain any number of partial revelations for an opaque
type; it must contain exactly one complete revelation.
</p><p>

<a name="idx.131">A</a> partial revelation has the form:
</p><pre>    REVEAL T &lt;: V
</pre>
where <tt>V</tt> is a type expression (possibly just a name)
and <tt>T</tt> is an identifier (possibly
<a href="#idx.139">qualified</a>)
declared as an opaque type.  It reveals that
<tt>V</tt> is a supertype of <tt>T</tt>.
<p>

In any scope, the revealed supertypes of an opaque type must be linearly
ordered by the subtype relation.
That is, if it is revealed that <tt>T &lt;: U1</tt> and <tt>T &lt;: U2</tt>,
it must also be revealed either that
<tt>U1 &lt;: U2</tt> or that <tt>U2 &lt;: U1</tt>.
</p><p>

A complete revelation has the form:
</p><pre>    REVEAL T = V
</pre>
where <tt>V</tt> is a type expression (not just a name) whose outermost
type constructor is a branded reference or object type and <tt>T</tt>
is an identifier (possibly qualified) that has been declared as an
opaque type.  The revelation specifies that <tt>V</tt> is the concrete
type for <tt>T</tt>. It is a static error if any type revealed in any
scope as a supertype of <tt>T</tt> is not a supertype of <tt>V</tt>.
Generally this error is detected at link time.
<p>

Distinct opaque types have distinct concrete types, since <tt>V</tt>
includes a brand and all brands in a program are distinct.
</p><p>

<a name="idx.132">A</a>
revelation is allowed only in an interface or in the outermost scope
of a module.  A revelation in an interface can be imported into any
scope where it is required, as illustrated by the
<a href="#ExampleSect">stack example</a>.
</p><p>

For example, consider:
</p><pre>    INTERFACE I; TYPE T &lt;: ROOT; PROCEDURE P(x:T): T; END I.

    INTERFACE IClass; IMPORT I; REVEAL I.T &lt;: MUTEX; END IClass.

    INTERFACE IRep; IMPORT I;
      REVEAL I.T = MUTEX BRANDED OBJECT count: INTEGER END;
    END IRep.
</pre>  
An importer of <tt>I</tt> sees <tt>I.T</tt> as an opaque subtype of
<tt>ROOT</tt>, and is limited to allocating objects of type <tt>I.T</tt>,
passing them to <tt>I.P</tt>, or declaring subtypes of <tt>I.T</tt>.
An importer of <tt>IClass</tt> sees that every <tt>I.T</tt> is a
<tt>MUTEX</tt>, and can therefore lock objects of type <tt>I.T</tt>.
Finally, an importer of <tt>IRep</tt> sees the concrete type,
and can access the <tt>count</tt> field.
<p>

</p><h3><a name="RecursiveDeclsSect">2.4.8 Recursive declarations</a></h3>
<p>

A constant, type, or procedure declaration <tt>N = E</tt>,
a variable declaration <tt>N: E</tt>,
an exception declaration <tt>N(E)</tt>,
or a revelation <tt>N = E</tt>
is <em>recursive</em> if <tt>N</tt> 
occurs in any partial expansion of <tt>E</tt>.
A variable declaration <tt>N := I</tt> where the type is omitted is recursive
if <tt>N</tt> occurs in any partial expansion of the type
<tt>E</tt> of <tt>I</tt>.
Such declarations are
allowed if every occurrence of <tt>N</tt> in any partial expansion of
<tt>E</tt> is  (1) within some occurrence of the type constructor <tt>REF</tt> 
or <tt>PROCEDURE</tt>, 
(2) within a field or method type of the type constructor <tt>OBJECT</tt>, 
or (3) within a procedure body.  
</p><p>

Examples of legal recursive declarations:
</p><pre>    TYPE 
      List = REF RECORD x: REAL; link: List END;
      T = PROCEDURE(n: INTEGER; p: T);
      XList = X OBJECT link: XList END;
    CONST N = BYTESIZE(REF ARRAY [0..N] OF REAL);
    PROCEDURE P(b: BOOLEAN) = BEGIN IF b THEN P(NOT b) END END P;
    EXCEPTION E(PROCEDURE () RAISES {E});
    VAR v: REF ARRAY [0..BYTESIZE(v)] OF INTEGER;
</pre>
<p>

Examples of illegal recursive declarations:
</p><pre>    TYPE 
      T = RECORD x: T END; 
      U = OBJECT METHODS m() := U.m END;
    CONST N = N+1;
    REVEAL I.T = I.T BRANDED OBJECT END;
    VAR v := P(); PROCEDURE P(): ARRAY [0..LAST(v)] OF T;
</pre>
<p>

Examples of legal non-recursive declarations:
</p><pre>    VAR n := BITSIZE(n);
    REVEAL T &lt;: T;
</pre>
<p>

</p><h2><a name="UnitsSect">2.5 Modules and interfaces</a></h2>
<p>

</p><blockquote><em>
Art, it seems to me, should simplify.  That, indeed, is very nearly
the whole of the higher artistic process; finding what conventions
of form and what detail one can do without and yet preserve the spirit
of the whole.  
---Willa Cather
</em></blockquote>
<p>

<a name="idx.134">A</a>
<em>module</em> is like a block, except for the visibility of names.  
An entity is visible in a block if it is declared in the block 
or in some enclosing block; an entity is visible in a module if 
it is declared in the module or in an interface that is imported 
or exported by the module.  
</p><p>

<a name="idx.135">An</a>
<em>interface</em> is a group of declarations.  Declarations in
interfaces are the same as in blocks, except that any variable
initializations must be constant, and procedure declarations must specify
only the signature, not the body.
</p><p>

A module <tt>X</tt> <em>exports</em> an interface <tt>I</tt> to supply bodies
for one or more of the procedures declared in the interface.  A module
or interface <tt>X</tt> <em>imports</em> an interface <tt>I</tt> to make the
entities declared in <tt>I</tt> visible in <tt>X</tt>.
</p><p>

<a name="idx.136">A</a>
<em>program</em> is a collection of modules and interfaces that contains
every interface imported or exported by any of its modules or
interfaces, and in which no procedure, module, or interface is multiply
defined.  The effect of executing a program is to execute the bodies
of each of its modules.  The order of execution of the modules is
constrained by the <a href="#idx.148">initialization rule</a>.
</p><p>

<a name="idx.137">The</a>
module whose body is executed last is called the <em>main module</em>.
Implementations are expected to provide a way to specify the main
module, in case the initialization rule does not determine it uniquely.
The recommended rule is that the main module be the one that exports
the interface <tt>Main</tt>, whose contents are implementation-dependent.
</p><p>

<a name="idx.138">Program</a>
execution terminates when the body of the main module
terminates, even if concurrent threads of control are still executing.
</p><p>

The names of the modules and interfaces of a program are called
<em>global</em> names.  The method for looking up global names---for example,
by file system search paths---is implementation-dependent.
</p><p>

</p><h3><a name="ImportsSect">2.5.1 Import statements</a></h3>
<p>

There are two forms of import statements.  All imports of both forms
are interpreted simultaneously: their order doesn't matter.
</p><p>

<a name="idx.139">
The first form is
</a>
</p><pre>    IMPORT I AS J
</pre>
which imports the interface whose global name is <tt>I</tt> and gives
it the local name <tt>J</tt>. The entities and revelations declared in
<tt>I</tt> become accessible in the importing module or interface, but
the entities and revelations imported into <tt>I</tt> do not.  To refer
to the entity declared with name <tt>N</tt> in the interface <tt>I</tt>,
the importer must use the <em>qualified identifier</em> <tt>J.N</tt>.
<p>

The statement <tt>IMPORT I</tt> is short for <tt>IMPORT I AS I</tt>.
</p><p>

<a name="idx.140">The</a>
second form is
</p><pre>    FROM I IMPORT N
</pre>
which introduces <tt>N</tt> as the local name for the entity declared
as <tt>N</tt> in the interface <tt>I</tt>.
A local binding for <tt>I</tt> takes
precedence over a global binding.
For example,
<pre>    IMPORT I AS J, J AS I; FROM I IMPORT N
</pre>
simultaneously introduces local names <tt>J</tt>, <tt>I</tt>, and <tt>N</tt>
for the entities whose global names are <tt>I</tt>, <tt>J</tt>,
and <tt>J.N</tt>, respectively.
<p>

It is illegal to use the same local name twice:
</p><pre>    IMPORT J AS I, K AS I;
</pre>
is a static error, even if <tt>J</tt> and <tt>K</tt> are the same.
<p>

</p><h3><a name="IntfsSect">2.5.2 Interfaces</a></h3>
<p>

An interface has the form:
</p><pre>    INTERFACE id;
      Imports;
      Decls
    END id.
</pre>	
where <tt>id</tt> is an identifier that names the interface, <tt>
Imports</tt> is a sequence of import statements, and <tt>Decls</tt> is 
a sequence of declarations that contains no procedure bodies or 
non-constant variable initializations.  The names declared in <tt>
Decls</tt> and the visible imported names must be distinct. It is a static 
error for two or more interfaces to form an import cycle.
<p>

</p><h3><a name="ModsSect">2.5.3 Modules</a></h3>
<p>

A module has the form:
</p><pre>    MODULE id EXPORTS Interfaces;
      Imports;
    Block id.
</pre>
where <tt>id</tt> is an identifier that names the module, <tt>Interfaces</tt> 
is a list of distinct names of interfaces exported by the module, 
<tt>Imports</tt> is a list of import statements, and <tt>Block</tt> is 
a block, the <em>body</em> of the module.  The name <tt>id</tt> must be 
repeated after the <tt>END</tt> that terminates the body.
"<tt>EXPORTS Interfaces</tt>" can be omitted,
in which case <tt>Interfaces</tt> defaults 
to <tt>id</tt>.
<p>

<a name="idx.143">If</a>
module <tt>M</tt> exports interface <tt>I</tt>, then all declared names 
in <tt>I</tt> are visible without qualification in <tt>M</tt>.   Any 
procedure declared in <tt>I</tt> can be redeclared in <tt>M</tt>, with 
a body.  The signature in <tt>M</tt> must be
<a href="#idx.59">covered</a> by the signature 
in <tt>I</tt>.
To determine the interpretation of keyword 
bindings and parameter defaults in calls to the procedure, the
signature in <tt>M</tt> is used within <tt>M</tt>; the signature in
<tt>I</tt> is used everywhere else.
</p><p>

Except for the redeclaration of exported procedures, the names declared 
at the top level of <tt>Block</tt>, the visible imported names, and 
the names declared in the exported interfaces must be distinct.
</p><p>

For example, the following is illegal, since two names in exported
interfaces coincide:
</p><pre>    INTERFACE I;
      PROCEDURE X();  ...

    INTERFACE J;
      PROCEDURE X();  ...

    MODULE M EXPORTS I, J;
      PROCEDURE X() = ...;
</pre>
<p>

The following is also illegal, since the visible imported name
<tt>X</tt> coincides with the top-level name <tt>X</tt>:
</p><pre>    INTERFACE I;
      PROCEDURE X();  ...

    MODULE M EXPORTS I;
      FROM I IMPORT X;
      PROCEDURE X() = ...;
</pre>
<p>

<a name="idx.144">But</a>
the following is legal, although peculiar:
</p><pre>    INTERFACE I;
      PROCEDURE X(...);  ...

    MODULE M EXPORTS I;
      IMPORT I;
      PROCEDURE X(...) = ...;
</pre>
<p>

since the only visible imported name is <tt>I</tt>, and the coincidence 
between <tt>X</tt> as a top-level name and <tt>X</tt> as a name in an 
exported interface is allowed, assuming the interface signature covers 
the module signature.  Within <tt>M</tt>, the interface declaration 
determines the signature of <tt>I.X</tt> and the module declaration 
determines the signature of <tt>X</tt>.
</p><p>

</p><h3><a name="ExampleSect">2.5.4 Example module and interface</a></h3>
<p>

Here is the canonical example of a public stack with hidden representation:
</p><pre>    INTERFACE Stack;
      TYPE T &lt;: REFANY;
      PROCEDURE Create(): T;
      PROCEDURE Push(VAR s: T; x: REAL);
      PROCEDURE Pop(VAR s: T): REAL;
    END Stack.

    MODULE Stack;
      REVEAL T = BRANDED OBJECT item: REAL; link: T END;
      PROCEDURE Create(): T = BEGIN RETURN NIL END Create;

      PROCEDURE Push(VAR s: T; x: REAL) =
        BEGIN 
          s := NEW(T, item := x, link := s)
        END Push;

      PROCEDURE Pop(VAR s: T): REAL =
        VAR res: REAL;
        BEGIN 
          res := s.item; s := s.link; RETURN res
        END Pop;

    BEGIN
    END Stack.
</pre>
<p>

If the representation of stacks is required in more than one module,
it should be moved to a private interface, so that it can be imported
wherever it is required:
</p><pre>    INTERFACE Stack  (* ... as before ... *) END Stack.

    INTERFACE StackRep; IMPORT Stack;   
      REVEAL Stack.T = BRANDED OBJECT item: REAL; link: Stack.T END
    END StackRep.

    MODULE Stack; IMPORT StackRep;
      (* Push, Pop, and Create as before *)
    BEGIN
    END Stack.
</pre>	
<p>

</p><h3><a name="GenericsSect">2.5.5 Generics</a></h3>
<p>

In a generic interface or module, some of the imported interface names
are treated as formal parameters, to be bound to actual interfaces
when the generic is instantiated.
</p><p>

A generic interface has the form
</p><pre>    GENERIC INTERFACE G(F_1, ..., F_n);
      Body
    END G.
</pre>    
where <tt>G</tt> is an identifier that names the generic interface,
<tt>F_1</tt>, <tt>...</tt>, <tt>F_n</tt> is a list of identifiers, called
the formal imports of <tt>G</tt>, and <tt>Body</tt> is a sequence of imports
followed by a sequence of declarations, exactly as in a non-generic
interface.
<p>

An instance of <tt>G</tt> has the form
</p><pre>    INTERFACE I = G(A_1, ..., A_n) END I.
</pre>
where <tt>I</tt> is the name of the instance and <tt>A_1</tt>, <tt>...</tt>,
<tt>A_n</tt> is a list of actual interfaces to which the formal imports
of <tt>G</tt> are bound.  The instance <tt>I</tt> is equivalent to an ordinary
interface defined as follows: 
<pre>    INTERFACE I;
      IMPORT A_1 AS F_1, ..., A_n AS F_n;
      Body
    END I.
</pre>
<p>

<a name="idx.146">A</a>
generic module has the form
</p><pre>    GENERIC MODULE G(F_1, ..., F_n);
      Body
    END G.
</pre>
where <tt>G</tt> is an identifier that names the generic module,
<tt>F_1</tt>, <tt>...</tt>, <tt>F_n</tt> is a list of identifiers, called
the formal imports of <tt>G</tt>, and <tt>Body</tt> is a sequence of imports
followed by a block, exactly as in a non-generic module.
<p>

An instance of <tt>G</tt> has the form
</p><pre>    MODULE I EXPORTS E = G(A_1, ..., A_n) END I.
</pre>
where <tt>I</tt> is the name of the instance,
<tt>E</tt> is a list of interfaces exported
by <tt>I</tt>, and <tt>A_1</tt>, <tt>...</tt>,
<tt>A_n</tt> is a list of actual interfaces to which the formal
imports of <tt>G</tt> are bound.
"<tt>EXPORTS E</tt>" can be omitted, in which case
it defaults to "<tt>EXPORTS I</tt>".
The instance <tt>I</tt> is equivalent
to an ordinary module defined as follows:
<pre>    MODULE I EXPORTS E;
      IMPORT A_1 AS F_1, ..., A_n AS F_n;
      Body
    END I.
</pre>
Notice that the generic module itself has no exports; they are supplied
only when it is instantiated.
<p>

<a name="idx.147">For</a>
example, here is a generic stack package:
</p><pre>    GENERIC INTERFACE Stack(Elem);
      (* where Elem.T is not an open array type. *)
      TYPE T &lt;: REFANY;
      PROCEDURE Create(): T;
      PROCEDURE Push(VAR s: T; x: Elem.T);
      PROCEDURE Pop(VAR s: T): Elem.T;
    END Stack.

    GENERIC MODULE Stack(Elem);

      REVEAL 
        T = BRANDED OBJECT  n: INTEGER;  a: REF ARRAY OF Elem.T  END;

      PROCEDURE Create(): T =
        BEGIN  RETURN NEW(T, n := 0, a := NIL)  END Create;

      PROCEDURE Push(VAR s: T; x: Elem.T) =
        BEGIN
          IF s.a = NIL THEN 
            s.a := NEW(REF ARRAY OF Elem.T, 5)
          ELSIF s.n &gt; LAST(s.a^) THEN
            WITH temp = NEW(REF ARRAY OF Elem.T, 2 * NUMBER(s.a^)) DO
              FOR i := 0 TO LAST(s.a^) DO temp[i] := s.a[i] END;
              s.a := temp
            END
          END;
          s.a[s.n] := x;
          INC(s.n)
        END Push;

      PROCEDURE Pop(VAR s: T): Elem.T =
        BEGIN  DEC(s.n);  RETURN s.a[s.n]  END Pop;

    BEGIN
    END Stack.
</pre>
To instantiate these generics to produce stacks of integers: 
<pre>    INTERFACE Integer; TYPE T = INTEGER; END Integer.
    INTERFACE IntStack = Stack(Integer) END IntStack.
    MODULE IntStack = Stack(Integer) END IntStack.
</pre>
Implementations are not expected to share code between different
instances of a generic module, since this will not be possible in
general.
<p>

Implementations are not required to typecheck uninstantiated generics,
but they must typecheck their instances.  For example, if one made
the following mistake:
</p><pre>    INTERFACE String; TYPE T = ARRAY OF CHAR; END String.
    INTERFACE StringStack = Stack(String) END StringStack.
    MODULE StringStack = Stack(String) END StringStack.
</pre>
everything would go well until the last line, when the compiler would
attempt to compile a version of <tt>Stack</tt> in which the element type
was an open array.  It would then complain that the <tt>NEW</tt> call
in <tt>Push</tt> does not have enough parameters.
<p>

</p><h3><a name="idx.148">2.5.6 Initialization</a></h3>
<p>

The order of execution of the modules in a program is constrained by
the following rule:
</p><p>

If module <tt>M</tt> depends on module <tt>N</tt> and <tt>N</tt>
does not depend on <tt>M</tt>, then <tt>N</tt>'s body will be
executed before <tt>M</tt>'s body,
where:
</p><ul>
<li>
A module <tt>M</tt> <em>depends on</em> a module <tt>N</tt> if <tt>M</tt>
uses an interface that <tt>N</tt> exports or if <tt>M</tt> depends on a
module that depends on <tt>N</tt>.
</li><li>
A module <tt>M</tt> <em>uses</em> an interface <tt>I</tt> if <tt>M</tt>
imports or exports <tt>I</tt> or if <tt>M</tt> uses an interface that
(directly or indirectly) imports <tt>I</tt>.
</li></ul>
<p>

Except for this constraint, the order of execution is
implementation-dependent.
</p><p>

</p><h3><a name="SafetySect">2.5.7 Safety</a></h3>
<p>

The keyword <tt>UNSAFE</tt> can precede the declaration of any interface
or module to indicate that it is <em>unsafe</em>; that is, uses the
<a href="#UnsafeSect">unsafe features</a>
of the language.
An interface or module not explicitly labeled
<tt>UNSAFE</tt> is called <em>safe</em>.
</p><p>

<a name="idx.150">An</a>
interface is <em>intrinsically safe</em> if there is no way to produce
an unchecked runtime error by using the interface in a safe module.
If all modules that export a safe interface are safe, the compiler
guarantees the intrinsic safety of the interface.  If any of the modules
that export a safe interface are unsafe, it is the programmer, rather
than the compiler, who makes the guarantee.
</p><p>

It is a static error for a safe interface to import an unsafe one
or for a safe module to import or export an unsafe interface.
</p><p>

</p><h2><a name="ExprsSect">2.6 Expressions</a></h2>
<p>

</p><blockquote><em>
The rules of logical syntax must follow of themselves,   
if we only know how every single sign signifies.                          
---Ludwig Wittgenstein
</em></blockquote>
<p>

<a name="idx.151">An</a>
expression prescribes a computation that produces a value or 
variable.  Syntactically, an expression is either an operand, or an 
operation applied to arguments, which are themselves expressions. 
Operands are identifiers, literals, or types.  An expression is 
evaluated by recursively evaluating its arguments and performing 
the operation.  The order of argument evaluation is undefined for 
all operations except <tt>AND</tt> and <tt>OR</tt>.
</p><p>

</p><h3><a name="ExprConventions">2.6.1 Conventions for describing operations</a></h3>
<p>

To describe the argument and result types of operations,
we use a notation like procedure signatures.  But since most operations
are too general to be described by a true procedure signature, we
extend the notation in several ways.
</p><p>

The argument to an operation can be required to have a type in a particular
class, such as an ordinal type, set type, etc.  In this case the formal
specifies a type class instead of a type.  For example:
</p><pre>    ORD (x: Ordinal): INTEGER
</pre>
The formal type <tt>Any</tt> specifies an argument of any type.
<p>

<a name="idx.152">A</a>
single operation name can be overloaded, which means that it denotes
more than one operation.  In this case, we write a separate signature
for each of the operations.  For example:
</p><pre>    ABS (x: INTEGER) : INTEGER
        (x: Float)   : Float
</pre>
The particular operation will be selected so that each actual argument
type is a subtype of the corresponding formal type or a member
of the corresponding formal type class.  
<p>

The argument to an operation can be an expression denoting a type.
In this case, we write <tt>Type</tt> as the argument type.  For example:
</p><pre>    BYTESIZE (T: Type): CARDINAL
</pre>
The result type of an operation can depend on its argument values
(although the result type can always be determined statically).  In
this case, the expression for the result type contains the
appropriate arguments.
For example:
<pre>    FIRST (T: FixedArrayType): IndexType(T)
</pre>
<tt>IndexType(T)</tt> denotes the index type of the array type <tt>
T</tt> and <tt>IndexType(a)</tt> denotes the index type of the array <tt>
a</tt>. The definitions of <tt>ElemType(T)</tt> and <tt>ElemType(a)</tt> 
are similar.
<p>

</p><h3><a name="idx.153">2.6.2 Operation syntax</a></h3>
<p>

The operators that have special syntax are classified and listed in order of 
decreasing binding power in the following table:
</p><pre>    x.a                   infix dot
    f(x) a[i] T{x}        applicative <tt>(</tt>, <tt>[</tt>, <tt>{</tt>
    p^                    postfix <tt>^</tt>
    +  -                  prefix arithmetics
    * / DIV MOD           infix arithmetics
    + - &amp;                 infix arithmetics
    = # &lt; &lt;= &gt;= &gt; IN      infix relations
    NOT                   prefix <tt>NOT</tt>
    AND                   infix <tt>AND</tt>
    OR                    infix <tt>OR</tt>
</pre>
<p>

All infix operators are left associative.  Parentheses can be used 
to override the precedence rules.  Here are some examples of expressions 
together with their fully parenthesized forms:
</p><pre>    M.F(x)           (M.F)(x)           dot before application
    Q(x)^            (Q(x))^            application before <tt>^</tt>
    - p^             - (p^)             <tt>^</tt> before prefix <tt>-</tt>
    - a * b          (- a) * b          prefix <tt>-</tt> before <tt>*</tt> 
    a * b - c        (a * b) - c        <tt>*</tt> before infix <tt>-</tt>
    x IN s - t       x IN (s - t)       infix <tt>-</tt> before <tt>IN</tt>
    NOT x IN s       NOT (x IN s)       <tt>IN</tt> before <tt>NOT</tt>
    NOT p AND q      (NOT p) AND q      <tt>NOT</tt> before <tt>AND</tt>
    A OR B AND C     A OR (B AND C)     <tt>AND</tt> before <tt>OR</tt>
</pre>
<p>

<a name="idx.154">Operators</a>
without special syntax are <em>procedural</em>. An application 
of a procedural operator has the form <tt>op(args)</tt>,
where <tt>op</tt> is the operation 
and <tt>args</tt> is the list of argument expressions.  For example, 
<tt>MAX</tt> and <tt>MIN</tt> are procedural operators.
</p><p>

</p><h3><a name="DesignatorSect">2.6.3 Designators</a></h3>
<p>

An identifier is a <em>writable designator</em>
if it is declared as a variable, 
is a <tt>VAR</tt> or <tt>VALUE</tt> parameter,
is a local of a <tt>TYPECASE</tt> 
or <tt>TRY EXCEPT</tt> statement,
or is a <tt>WITH</tt> local that is bound to a writable designator.
An identifier is a <em>readonly designator</em> if it is
a <tt>READONLY</tt> parameter,
a local of a <tt>FOR</tt> statement,
or a <tt>WITH</tt> local bound to a non-designator or 
readonly designator.
</p><p>

<a name="idx.156">The</a>
only operations that produce designators are dereferencing, 
subscripting, selection, and <tt>SUBARRAY</tt>.
This section defines these operations and specifies the conditions 
under which they produce designators.
In <a href="#SafetySect">unsafe modules</a>,
<a href="#UnsafeSect"><tt>LOOPHOLE</tt></a>
can also produce a designator.
</p><p>

<a name="idx.157"><tt>r^</tt></a>
</p><blockquote>
    denotes the the referent of 
    <tt>r</tt>; this operation is called <em>dereferencing</em>.  The
    expression <tt>r^</tt> is always a writable designator.  It is a
    static error if the type of <tt>r</tt> is <tt>REFANY</tt>,
    <tt>ADDRESS</tt>, <tt>NULL</tt>, an object type, or an opaque type,
    and a checked runtime error if <tt>r</tt> is <tt>NIL</tt>.
    The type of <tt>r^</tt> is the referent type of <tt>r</tt>.
</blockquote>
<p>

<a name="idx.158"><tt>a[i]</tt></a>
</p><blockquote>
    denotes the <tt>(i + 1 - FIRST(a))</tt>-th element of the 
    array <tt>a</tt>.  The expression <tt>a[i]</tt> is a designator
    if <tt>a</tt> is, and is writable if <tt>a</tt> is.
    The expression <tt>i</tt>
    must be assignable to the index type of <tt>a</tt>.  The type of
    <tt>a[i]</tt> is the element type of <tt>a</tt>.
    <p>

    An expression of the form <tt>a[i_1, ..., i_n]</tt> is
    shorthand for <tt>a[i_1]...[i_n]</tt>.  If <tt>a</tt> is a reference
    to an array, then <tt>a[i]</tt> is shorthand for <tt>a^[i]</tt>.
</p></blockquote>
<p>

<a name="idx.159"><tt>r.f, o.f, I.x, T.m, E.id</tt></a>
</p><blockquote>
    If <tt>r</tt> denotes a record,
    <tt>r.f</tt> denotes its <tt>f</tt> field.  In
    this case <tt>r.f</tt> is a designator if <tt>r</tt> is,
    and is writable if <tt>r</tt> is.
    The type of <tt>r.f</tt> is the declared type of the field.
    <p>

    <a name="idx.160">If</a> <tt>r</tt> is a reference to a record,
    then <tt>r.f</tt> is shorthand for <tt>r^.f</tt>.
    </p><p>

    <a name="idx.161">If</a> <tt>o</tt> denotes an object and <tt>f</tt>
    names a data field specified
    in the type of <tt>o</tt>, then <tt>o.f</tt> denotes
    that data field of <tt>o</tt>.  In this case <tt>o.f</tt> is a writable
    designator whose type is the declared type of the field.
    </p><p>

    If <tt>I</tt> denotes an imported interface, then <tt>I.x</tt> denotes 
    the entity named <tt>x</tt> in the interface <tt>I</tt>.  In this case 
    <tt>I.x</tt> is a designator if <tt>x</tt> is declared as a variable; 
    such a designator is always writable.
    </p><p>

    <a name="idx.162">If</a> <tt>T</tt> is an object type and <tt>m</tt>
    is the name of one of 
    <tt>T</tt>'s methods, then <tt>T.m</tt> denotes the <tt>m</tt> method of
    type <tt>T</tt>. In this case <tt>T.m</tt> is not a designator.  Its type
    is the procedure type whose first argument has mode <tt>VALUE</tt>
    and type <tt>T</tt>, and whose remaining arguments are determined by
    the method declaration for <tt>m</tt> in <tt>T</tt>. The name of the first
    argument is unspecified; thus in calls to <tt>T.m</tt>, this argument
    must be given positionally, not by keyword.  <tt>T.m</tt> is a
    procedure constant.
    </p><p>

    <a name="idx.163">If</a> <tt>E</tt> is an enumerated type,
    then <tt>E.id</tt> denotes its
    value named <tt>id</tt>.  In this case <tt>E.id</tt> is not a designator.
    The type of <tt>E.id</tt> is <tt>E</tt>.
</p></blockquote>
<p>

<a name="idx.164">
<tt>SUBARRAY(a: Array; from, for: CARDINAL): ARRAY OF ElemType(a)</tt>
</a>
</p><blockquote>
    <tt>SUBARRAY</tt> produces a subarray of <tt>a</tt>.  It does not copy the
    array; it is a designator if <tt>a</tt> is, and is writable if <tt>a</tt>
    is.  If <tt>a</tt> is a multi-dimensional array, <tt>SUBARRAY</tt> applies
    only to the top-level array.
    <p>

    <a name="idx.165">The</a> operation returns the subarray that skips the
    first <tt>from</tt>
    elements of <tt>a</tt> and contains the next <tt>for</tt> elements.  Note
    that if <tt>from</tt> is zero, the subarray is a prefix of <tt>a</tt>,
    whether the type of <tt>a</tt> is zero-based or not.  It is a checked
    runtime error if <tt>from+for</tt> exceeds <tt>NUMBER(a)</tt>.
    </p><p>

    <a name="idx.166">Implementations</a> may restrict
    or prohibit the <tt>SUBARRAY</tt> operation for arrays with packed
    element types.
</p></blockquote>
<p>

</p><h3><a name="NumericLitsSect">2.6.4 Numeric literals</a></h3>
<p>

Numeric literals denote constant non-negative integers or reals.  
The types of these literals are <tt>INTEGER</tt>, <tt>REAL</tt>, 
<tt>LONGREAL</tt>, and <tt>EXTENDED</tt>.
</p><p>

A literal <tt>INTEGER</tt> has the form <tt>base_digits</tt>,
where <tt>base</tt> 
is one of "<tt>2</tt>", "<tt>3</tt>", ..., "<tt>16</tt>", and <tt>digits</tt> 
is a non-empty sequence of the decimal digits <tt>0</tt> through
<tt>9</tt> plus the hexadecimal digits <tt>A</tt> through <tt>F</tt>.
The "<tt>base_</tt>" can be omitted,
in which case <tt>base</tt> defaults to <tt>10</tt>.
The digits are interpreted in the given base.
Each digit must be less than <tt>base</tt>.
For example, <tt>16_FF</tt> and <tt>255</tt> 
are equivalent integer literals.
</p><p>

If no explicit base is present, the value of the literal must be at
most <tt>LAST(INTEGER)</tt>.  If an explicit base is present, the value
of the literal must be less than <tt>2^Word.Size</tt>,
and its interpretation uses the convention of the
<a href="http://www.research.compaq.com/SRC/m3defn/html/word-intf.html"><tt>Word</tt></a> interface.
For example, on a sixteen-bit two's complement machine,
<tt>16_FFFF</tt> and <tt>-1</tt> represent the same value.
</p><p>

<a name="idx.168">A</a>
literal <tt>REAL</tt> has the form <tt>decimal E exponent</tt>, where 
<tt>decimal</tt> is a non-empty sequence of decimal digits followed 
by a decimal point followed by a non-empty sequence of decimal digits, and 
<tt>exponent</tt> is a non-empty sequence of decimal digits optionally 
beginning with a <tt>+</tt> or <tt>-</tt>.
The literal denotes <tt>decimal</tt> 
times <tt>10^exponent</tt>.
If "<tt>E exponent</tt>" is omitted,
<tt>exponent</tt> defaults to <tt>0</tt>.
</p><p>

<a name="idx.169"><tt>LONGREAL</tt></a> and <tt>EXTENDED</tt>
literals are like <tt>REAL</tt> literals,
but instead of <tt>E</tt> they use <tt>D</tt> and <tt>X</tt> respectively.
</p><p>

<a name="idx.170">Case</a>
is not significant in digits, prefixes or scale factors.  Embedded
spaces are not allowed.  
</p><p>

For example, <tt>1.0</tt> and <tt>0.5</tt> are valid, <tt>1.</tt>
and <tt>.5</tt> are not;
<tt>6.624E-27</tt> is a <tt>REAL</tt>,
and <tt>3.1415926535d0</tt> a <tt>LONGREAL</tt>.
</p><p>

</p><h3><a name="idx.171">2.6.5 Text and character literals</a></h3>
<p>

A character literal is a pair of single quotes enclosing either a
single ISO-Latin-1 printing character (excluding single quote)
or an escape sequence.  The type of a character literal is <tt>CHAR</tt>.
</p><p>

<a name="idx.172">A</a>
text literal is a pair of double quotes enclosing a sequence of
ISO-Latin-1 printing characters (excluding double quote) and escape
sequences.  The type of a text literal is <tt>TEXT</tt>.
</p><p>

<a name="idx.173">Here are</a>
are the legal escape sequences and the characters they denote:
</p><pre>    \n   newline (linefeed)     \f    form feed 
    \t   tab                    \\    backslash 
    \r   carriage return        \"    double quote 
    \'   single quote           \nnn  char with code <tt>8_nnn</tt>
</pre>
A <tt>\</tt> followed by exactly three octal digits specifies the character
whose code is that octal value.  A <tt>\</tt> that is not a part
of one of these escape sequences is a static error.
<p>

For example, <tt>'a'</tt> and <tt>'\''</tt> are valid character
literals, <tt>'''</tt> is not; <tt>""</tt> and <tt>"Don't\n"</tt>
are valid text literals, <tt>"""</tt> is not.
</p><p>

</p><h3><a name="NilSect">2.6.6 Nil</a></h3>
<p>

The literal "<tt>NIL</tt>" denotes the value <tt>NIL</tt>.
Its type is <a href="#idx.53"><tt>NULL</tt></a>.
</p><p>

</p><h3><a name="FunctionAppSect">2.6.7 Function application</a></h3>
<p>

A procedure call is an expression if the procedure returns a result.
The type of the expression is the result type of the procedure.
</p><p>

</p><h3><a name="ConstructorsSect">2.6.8 Set, array, and record constructors</a></h3>
<p>

A set constructor has the form:
</p><pre>    S{e_1, ..., e_n}
</pre>
where <tt>S</tt> is a set type and the <tt>e</tt>'s are expressions or ranges
of the form <tt>lo..hi</tt>.  The constructor denotes a value of type
<tt>S</tt> containing the listed values and the values in the listed ranges.
The <tt>e</tt>'s, <tt>lo</tt>'s, and <tt>hi</tt>'s must be assignable
to the element type of <tt>S</tt>.
<p>

<a name="idx.177">An</a>
array constructor has the form:
</p><pre>    A{e_1, ..., e_n}
</pre>
where <tt>A</tt> is an array type and the <tt>e</tt>'s are expressions.  
The constructor denotes a value of type <tt>A</tt> containing the listed 
elements in the listed order.  The <tt>e</tt>'s must be assignable to 
the element type of <tt>A</tt>.  This means that if <tt>A</tt> is a 
multi-dimensional array, the <tt>e</tt>'s must themselves be array-valued 
expressions.
<p>

If <tt>A</tt> is a fixed array type and <tt>n</tt> is at least 1, then 
<tt>e_n</tt> can be followed by "<tt>, ..</tt>" to indicate that the 
value of <tt>e_n</tt> will be replicated as many times as necessary 
to fill out the array. It is a static error to provide too many or 
too few elements for a fixed array type.
</p><p>

<a name="idx.178">A</a>
record constructor has the form:
</p><pre>    R{Bindings}
</pre>
where <tt>R</tt> is a record type and <tt>Bindings</tt> is a list of keyword
or positional bindings, exactly as in a
<a href="#ProcCallSect">procedure call</a>.
The list of bindings is rewritten to fit the list of fields and defaults
of <tt>R</tt>, exactly as for a procedure call; the record field names
play the role of the procedure formal parameters.  The expression
denotes a value of type <tt>R</tt> whose field values are specified by
the rewritten binding.
<p>

The rewritten binding must bind only field names and must bind each field 
name exactly once.  Each expression in the binding must be assignable
to the type of the corresponding record field.
</p><p>

</p><h3><a name="NewSect">2.6.9 New</a></h3>
<p>

An allocation operation has the form:
</p><pre>    NEW(T, ...)
</pre>
where <tt>T</tt> is a reference type other than <tt>REFANY</tt>,
<tt>ADDRESS</tt>, or <tt>NULL</tt>.  The operation returns the address of a
newly-allocated variable of <tt>T</tt>'s referent type; or if <tt>T</tt>
is an object type, a newly-allocated data record paired with a method
suite.  The reference returned by <tt>NEW</tt> is distinct from all
existing references.  The allocated type of the new reference is <tt>T</tt>.
<p>

It is a static error if <tt>T</tt>'s referent type is empty.
If <tt>T</tt> is declared as an opaque type,
<tt>NEW(T)</tt> is legal only in scopes
where <tt>T</tt>'s concrete type is known completely,
or is known to be an object type.
</p><p>

The initial state of the referent generally represents an arbitrary 
value of its type.  If <tt>T</tt> is an object type or a reference to 
a record or open array then <tt>NEW</tt> takes additional arguments 
to control the initial state of the new variable.
</p><p>

<a name="idx.180">If</a>
<tt>T</tt> is a reference to an array with k open dimensions, the 
<tt>NEW</tt> operation has the form:
</p><pre>    NEW(T, n_1, ..., n_k)
</pre>
where the <tt>n</tt>'s are integer-valued expressions that specify the 
lengths of the new array in its first k dimensions.  The values in 
the array will be arbitrary values of their type.
<p>

<a name="idx.181">If</a>
<tt>T</tt> is an object type or a reference to a record, the <tt>NEW</tt> 
operation has the form:
</p><pre>    NEW(T, Bindings)
</pre>
where <tt>Bindings</tt> is a list of keyword bindings used to initialize
the new fields.  Positional bindings are not allowed.
<p>

Each binding <tt>f := v</tt> initializes the field <tt>f</tt> to the value
<tt>v</tt>.  Fields for which no binding is supplied will be initialized
to their
<a href="#idx.45">defaults</a>
if they have defaults; otherwise they will be
initialized to arbitrary values of their types.
</p><p>

The order of the field bindings makes no difference.
</p><p>

If <tt>T</tt> is an object type then <tt>Bindings</tt> can also include
method overrides of the form <tt>m := P</tt>, where <tt>m</tt> is a method
of <tt>T</tt> and <tt>P</tt> is a top-level procedure constant.  This is
syntactic sugar for the allocation of a subtype of <tt>T</tt> that includes
the given overrides, in the given order.
For example, <tt>NEW(T, m := P)</tt> is sugar for
</p><pre>    NEW(T OBJECT OVERRIDES m := P END).
</pre>
<p>

</p><h3><a name="ArithmeticOpsSect">2.6.10 Arithmetic operations</a></h3>
<p>

The basic arithmetic operations are built into the language;
additional operations are provided by the required
<a href="http://www.research.compaq.com/SRC/m3defn/html/intfs.html">floating-point interfaces</a>.
</p><p>

To test or set the implementation's behavior for overflow, underflow,
rounding, and division by zero, see the required interface
<a href="http://www.research.compaq.com/SRC/m3defn/html/floatmode.html"><tt>FloatMode</tt></a>.
Modula-3 arithmetic was designed
to support the
<a href="http://www.research.compaq.com/SRC/modula-3/html/bib.html#m3fp">IEEE floating-point</a>
standard, but not to require it.
</p><p>

To perform arithmetic operations modulo the word size, programs should
use the routines in the required interface
<a href="http://www.research.compaq.com/SRC/m3defn/html/word-intf.html"><tt>Word</tt></a>.
</p><p>

Implementations must not rearrange the computation of expressions in
a way that could affect the result.  For example, <tt>(x+y)+z</tt>
generally cannot be computed as <tt>x+(y+z)</tt>, since addition is not
associative either for bounded integers or for floating-point values.
</p><p>

<a name="idx.183">
<pre>    prefix    +  (x: INTEGER)    : INTEGER
              +  (x: Float)      : Float


     infix    +  (x,y: INTEGER)  : INTEGER
                 (x,y: Float)    : Float
                 (x,y: Set)      : Set
</pre>
</a>
As a prefix operator, <tt>+x</tt> returns <tt>x</tt>.  
As an infix operator on numeric arguments,
<tt>+</tt> denotes addition. On sets, <tt>+</tt> denotes set union.
That is, <tt>e IN (x + y)</tt> if and only if <tt>(e IN x) OR (e IN y)</tt>.
The types of <tt>x</tt> and <tt>y</tt> must be the same, and the result 
is the same type as both. In <a href="#SafetySect">unsafe modules</a>,
<tt>+</tt> is extended to <tt>ADDRESS</tt>. 
</p><p>

<a name="idx.184">
<pre>    prefix    -  (x: INTEGER)    : INTEGER
                 (x: Float)      : Float

     infix    -  (x,y: INTEGER)  : INTEGER
                 (x,y: Float)    : Float
                 (x,y: Set)      : Set
</pre>
</a>
As a prefix operator, <tt>-x</tt> is the negative of <tt>x</tt>. 
As an infix operator on numeric arguments, <tt>-</tt> denotes subtraction.
On sets, <tt>-</tt> denotes set difference.
That is, <tt>e IN (x - y)</tt> if and only if
<tt>(e IN x) AND NOT (e IN y)</tt>.
The types of <tt>x</tt> and <tt>y</tt> must be the same, and the result 
is the same type as both. 
In <a href="#SafetySect">unsafe modules</a>, <tt>-</tt> is extended
to <tt>ADDRESS</tt>.
</p><p>

<a name="idx.185">
<pre>    infix     *  (x,y: INTEGER)  : INTEGER
                 (x,y: Float)    : Float
                 (x,y: Set)      : Set
</pre>
</a>
On numeric arguments, <tt>*</tt> denotes multiplication.  
On sets, <tt>*</tt> denotes intersection.
That is, <tt>e IN (x * y)</tt> if and only if <tt>(e IN x) AND (e IN y)</tt>.
The types of <tt>x</tt> and <tt>y</tt> must be the same, and the result 
is the same type as both. 
</p><p>

<a name="idx.186">
<pre>    infix     /  (x,y: Float)    : Float
                 (x,y: Set)      : Set
</pre>
</a>
On reals, <tt>/</tt> denotes division. On sets, <tt>/</tt>  denotes
symmetric difference.
That is, <tt>e IN (x / y)</tt> if and only if <tt>(e IN x) # (e IN y)</tt>.
The types of <tt>x</tt> and <tt>y</tt> must be the same, and the result 
is the same type as both.
</p><p>

<a name="idx.187">
<pre>    infix    DIV (x,y: INTEGER) : INTEGER
    infix    MOD (x,y: INTEGER) : INTEGER
             MOD (x, y: Float)  : Float
</pre>
</a>
The value <tt>x DIV y</tt> is the floor of 
the quotient of <tt>x</tt> and <tt>y</tt>; that is, the maximum integer 
not exceeding the real number <tt>z</tt> such that <tt>z * y = x</tt>.
For integers <tt>x</tt> and <tt>y</tt>, the value of <tt>x MOD y</tt> is 
defined to be <tt>x - y * (x DIV y)</tt>.
</p><p>

This means that for positive <tt>y</tt>, the value of <tt>x MOD y</tt>
lies in the interval <tt>[0 .. y-1]</tt>, regardless of 
the sign of <tt>x</tt>.  For negative <tt>y</tt>, the value of
<tt>x MOD y</tt> lies in the interval <tt>[y+1 .. 0]</tt>, regardless 
of the sign of <tt>x</tt>.
</p><p>

If <tt>x</tt> and <tt>y</tt> are floats, the value of <tt>x MOD y</tt> is 
<tt>x - y * FLOOR(x / y)</tt>.  This may be computed as a Modula-3
expression, or by a method that avoids overflow if <tt>x</tt> is much
greater than <tt>y</tt>.  The types of <tt>x</tt> and <tt>y</tt> must
be the same, and the result is the same type as both.
</p><p>

<a name="idx.188">
<pre>             ABS (x: INTEGER) : INTEGER
                 (x: Float)   : Float
</pre>
</a>
<tt>ABS(x)</tt> is the absolute value of <tt>x</tt>.
If <tt>x</tt> is a float,
the type of <tt>ABS(x)</tt> is the same as the type of <tt>x</tt>.
</p><p>

<a name="idx.189">
<pre>           FLOAT (x: INTEGER; T: Type := REAL): T
                 (x: Float;   T: Type := REAL): T
</pre>
</a>
<tt>FLOAT(x, T)</tt> is a floating-point value of type <tt>T</tt>
that is equal to or very near <tt>x</tt>.
The type <tt>T</tt> must be a floating-point type;
it defaults to <tt>REAL</tt>.  The exact semantics depend on the
thread's current rounding mode, as explained in the required interface
<a href="http://www.research.compaq.com/SRC/m3defn/html/floatmode.html"><tt>FloatMode</tt></a>.
</p><p>

<a name="idx.190">
<pre>           FLOOR   (x: Float) : INTEGER

           CEILING (x: Float) : INTEGER
</pre>
</a>
<tt>FLOOR(x)</tt> is the greatest integer not exceeding <tt>x</tt>.  
<tt>CEILING(x)</tt> is the least integer not less than <tt>x</tt>.
</p><p>

<a name="idx.191">
<pre>           ROUND (r: Float)   : INTEGER

           TRUNC (r: Float)   : INTEGER
</pre>
</a>
<tt>ROUND(r)</tt> is the nearest integer to <tt>r</tt>; ties are broken 
according to the constant <tt>RoundDefault</tt> in the required interface
<a href="http://www.research.compaq.com/SRC/m3defn/html/floatmode.html"><tt>FloatMode</tt></a>.
<tt>TRUNC(r)</tt> rounds <tt>r</tt> toward zero; it equals 
<tt>FLOOR(r)</tt> for positive <tt>r</tt> and <tt>CEILING(r)</tt> for 
negative <tt>r</tt>.
</p><p>

<a name="idx.192">
<pre>       MAX, MIN (x,y: Ordinal) : Ordinal
                (x,y: Float)   : Float
</pre>
</a>
<tt>MAX</tt> returns the greater of the two values <tt>x</tt> and <tt>y</tt>;
<tt>MIN</tt> returns the lesser.  If <tt>x</tt> and <tt>y</tt> are ordinals,
they must have the same base type, which is the type of the result.
If <tt>x</tt> and <tt>y</tt> are floats, they must have the same type, and
the result is the same type as both.
</p><p>

</p><h3><a name="RelationsSect">2.6.11 Relations</a></h3>
<p>

</p><pre>     infix    =, #  (x, y: Any): BOOLEAN
</pre>
The operator <tt>=</tt> returns <tt>TRUE</tt> if <tt>x</tt> and <tt>y</tt> 
are equal.  The operator <tt>#</tt> returns <tt>TRUE</tt> 
if <tt>x</tt> and <tt>y</tt> are not equal.
It is a static error if the type of <tt>x</tt> is not
assignable to the type of <tt>y</tt> or vice versa.
<p>

Ordinals are equal if they have the same value.  Floats are equal
if the underlying implementation defines them to be; for example,
on an IEEE implementation, <tt>+0</tt> equals <tt>-0</tt> and
<tt>NaN</tt> does not equal itself.
References are equal if they address the same location.
Procedures are equal if they agree as closures; that
is, if they refer to the same procedure body and environment.
Sets are equal if they have the same elements.
Arrays are equal if they have the same length and corresponding
elements are equal.
Records are equal if they have the same fields and corresponding fields
are equal.
</p><p>

<a name="idx.194">
<pre>     infix    &lt;=, &gt;=  (x,y: Ordinal) : BOOLEAN
                      (x,y: Float)   : BOOLEAN
                      (x,y: ADDRESS) : BOOLEAN
                      (x,y: Set)     : BOOLEAN
</pre>
</a>
In the first three cases, <tt>&lt;=</tt> returns <tt>TRUE</tt> if <tt>x</tt> 
is at most as large as <tt>y</tt>.  In the last case, <tt>&lt;=</tt> returns 
<tt>TRUE</tt> if every element of <tt>x</tt> is an element of <tt>y</tt>.  
In all cases, it is a static error if the type of <tt>x</tt> is 
not assignable to the type of <tt>y</tt>, or vice versa.
The expression <tt>x &gt;= y</tt> is equivalent to <tt>y &lt;= x</tt>.
</p><p>

</p><pre>     infix    &gt;, &lt;    (x,y: Ordinal) : BOOLEAN
                      (x,y: Float)   : BOOLEAN
                      (x,y: ADDRESS) : BOOLEAN
                      (x,y: Set)     : BOOLEAN
</pre>
In all cases, <tt>x &lt; y</tt> means <tt>(x &lt;= y) AND (x # y)</tt>,
and <tt>x &gt; y</tt> means <tt>y &lt; x</tt>.
It is a static error if the type of <tt>x</tt> is not assignable
to the type of <tt>y</tt>, or vice versa.
<p>

Warning: with IEEE floating-point, <tt>x &lt;= y</tt>
is not the same as <tt>NOT x &gt; y</tt>.
</p><p>

<a name="idx.195">
<pre>     infix    IN (e: Ordinal; s: Set): BOOLEAN
</pre>
</a>
Returns <tt>TRUE</tt> if <tt>e</tt> is an element of the set <tt>s</tt>.
It is a static error if the type of <tt>e</tt> is not assignable to
the element type of <tt>s</tt>.
If the value of <tt>e</tt> is not a member of the element type,
no error occurs, but <tt>IN</tt> returns <tt>FALSE</tt>.
</p><p>

</p><h3><a name="BooleanOpsSect">2.6.12 Boolean operations</a></h3>
<p>

</p><pre>    prefix    NOT (p: BOOLEAN)   : BOOLEAN 
     infix    AND (p,q: BOOLEAN) : BOOLEAN 
     infix     OR (p,q: BOOLEAN) : BOOLEAN
</pre>
<tt>NOT p</tt> is the complement of <tt>p</tt>.
<p>

<tt>p AND q</tt> is <tt>TRUE</tt> if both <tt>p</tt> and <tt>q</tt>
are <tt>TRUE</tt>.
If <tt>p</tt> is <tt>FALSE</tt>, <tt>q</tt> is not evaluated.
</p><p>

<tt>p OR q</tt> is <tt>TRUE</tt> if at least one of <tt>p</tt> and <tt>q</tt>
is <tt>TRUE</tt>.
If <tt>p</tt> is <tt>TRUE</tt>, <tt>q</tt> is not evaluated.
</p><p>

</p><h3><a name="TypeOpsSect">2.6.13 Type operations</a></h3>
<p>

<a name="idx.197">
<pre>              ISTYPE  (x: Reference; T: RefType) : BOOLEAN
</pre>
</a>
<tt>ISTYPE(x, T)</tt> is <tt>TRUE</tt> if and only if <tt>x</tt> is a member 
of <tt>T</tt>. <tt>T</tt> must be an object type or traced reference 
type, and <tt>x</tt> must be assignable to <tt>T</tt>.

<a name="idx.198">
<pre>              NARROW  (x: Reference; T: RefType): T
</pre>
</a>
<tt>NARROW(x, T)</tt> returns <tt>x</tt> after checking that <tt>x</tt> is 
a member of <tt>T</tt>.  If the check fails, a runtime error occurs. 
<tt>T</tt> must be an object type or traced reference type,
and <tt>x</tt> must be assignable to <tt>T</tt>.
</p><p>

<a name="idx.199">
<pre>              TYPECODE (T: RefType)       : CARDINAL
                       (r: REFANY)        : CARDINAL
                       (r: UNTRACED ROOT) : CARDINAL
</pre>
</a>
Every object type or traced reference type (including <tt>NULL</tt>) 
has an associated integer code.  Different types have different 
codes.  The code for a type is constant for any single execution 
of a program, but may differ for different executions.
<tt>TYPECODE(T)</tt> returns the code for the type <tt>T</tt> and
<tt>TYPECODE(r)</tt> returns the code for the allocated type of <tt>r</tt>. 
It is a static error if <tt>T</tt> is <tt>REFANY</tt> or is not an object 
type or traced reference type.
</p><p>

<a name="idx.200">
<pre>              ORD  (element: Ordinal): INTEGER
              VAL  (i: INTEGER; T: OrdinalType): T
</pre>
</a>
<tt>ORD</tt> converts an element of an enumeration to the integer that
represents its position in the enumeration order.  The first value
in any enumeration is represented by zero.  If the type
of <tt>element</tt> is a subrange of an enumeration <tt>T</tt>, the result
is the position of the element within <tt>T</tt>, not within the subrange.
</p><p>

<tt>VAL</tt> is the inverse of <tt>ORD</tt>; it converts from a numeric
position <tt>i</tt> into the element that occupies that position in
an enumeration.  If <tt>T</tt> is a subrange, <tt>VAL</tt> returns the
element with the position <tt>i</tt> in the original enumeration type,
not the subrange.  It is a checked runtime error for the value
of <tt>i</tt> to be out of range for <tt>T</tt>.  
</p><p>

If <tt>n</tt> is an integer, <tt>ORD(n) = VAL(n, INTEGER) = n</tt>.
</p><p>

<a name="idx.201">
<pre>              NUMBER (T: OrdinalType)    : CARDINAL
                     (A: FixedArrayType) : CARDINAL
                     (a: Array)          : CARDINAL
</pre>
</a>
For an ordinal type <tt>T</tt>, <tt>NUMBER(T)</tt> returns the number of
elements in <tt>T</tt>.
For a fixed array type <tt>A</tt>, <tt>NUMBER(A)</tt> is defined by 
<tt>NUMBER(IndexType(A))</tt>.  Similarly, for an array <tt>a</tt>, 
<tt>NUMBER(a)</tt> is defined by <tt>NUMBER(IndexType(a))</tt>.  In 
this case, the expression <tt>a</tt> will be evaluated only if it 
denotes an open array.
</p><p>

<a name="idx.202">
<pre>              FIRST (T: OrdinalType)    : BaseType(T)
                    (T: FloatType)      : T
                    (A: FixedArrayType) : BaseType(IndexType(A))
                    (a: Array)          : BaseType(IndexType(a))

              LAST  (T: OrdinalType)    : BaseType(T)
                    (T: FloatType)      : T
                    (A: FixedArrayType) : BaseType(IndexType(A))
                    (a: Array)          : BaseType(IndexType(a))
</pre>
</a>
For a non-empty ordinal type <tt>T</tt>, <tt>FIRST</tt> returns the 
smallest value of <tt>T</tt> and <tt>LAST</tt> returns the largest 
value.  If <tt>T</tt> is the empty enumeration, <tt>FIRST(T)</tt> and 
<tt>LAST(T)</tt> are static errors.  If <tt>T</tt> is any other empty 
ordinal type, the values returned are implementation-dependent, 
but they satisfy <tt>FIRST(T) &gt; LAST(T)</tt>.
</p><p>

For a floating-point type <tt>T</tt>, <tt>FIRST(T)</tt> and <tt>LAST(T)</tt>
are the smallest and largest values of the type, respectively.
On IEEE implementations, these are minus and plus infinity.
</p><p>

For a fixed array type <tt>A</tt>, <tt>FIRST(A)</tt> is defined by 
<tt>FIRST(IndexType(A))</tt> and <tt>LAST(A)</tt> by
<tt>LAST(IndexType(A))</tt>.
Similarly, for an array <tt>a</tt>,
<tt>FIRST(a)</tt> and <tt>LAST(a)</tt> are defined by
<tt>FIRST(IndexType(a))</tt> and <tt>LAST(IndexType(a))</tt>.
The expression  <tt>a</tt> will be evaluated only if it is an open array.
Note that if <tt>a</tt> is an open array,
<tt>FIRST(a)</tt> and <tt>LAST(a)</tt> 
have type <tt>INTEGER</tt>.
</p><p>

<a name="idx.203">
<pre>              BITSIZE  (x: Any)  : CARDINAL
                       (T: Type) : CARDINAL

              BYTESIZE (x: Any)  : CARDINAL
                       (T: Type) : CARDINAL

              ADRSIZE  (x: Any)  : CARDINAL
                       (T: Type) : CARDINAL
</pre>
</a>
These operations return the size of the variable <tt>x</tt> or of 
variables of type <tt>T</tt>.  <tt>BITSIZE</tt> returns the number of bits, 
<tt>BYTESIZE</tt> the number of 8-bit bytes, and <tt>ADRSIZE</tt> the number 
of addressable locations. In all cases, <tt>x</tt> must be a designator 
and <tt>T</tt> must not be an open array type.  A designator <tt>x</tt> 
will be evaluated only if its type is an open array type.
</p><p>

</p><h3><a name="TextOpsSect">2.6.14 Text operations</a></h3>
<p>

</p><pre>     infix    &amp;  (a,b: TEXT): TEXT
</pre>
The concatenation of <tt>a</tt> and <tt>b</tt>, as defined by
<a href="http://www.research.compaq.com/SRC/m3defn/html/text-intf.html"><tt>Text.Cat</tt></a>.
<p>

</p><h3><a name="idx.205">2.6.15 Constant expressions</a></h3>
<p>

Constant expressions are a subset of the general class of expressions,
restricted by the requirement that it be possible to evaluate the
expression statically.  All operations are legal in constant expressions
except for <tt>ADR</tt>, <tt>LOOPHOLE</tt>, <tt>TYPECODE</tt>, <tt>NARROW</tt>,
<tt>ISTYPE</tt>, <tt>SUBARRAY</tt>, <tt>NEW</tt>, dereferencing (explicit or
implicit), and the only procedures that can be applied are the functions
in the
<a href="http://www.research.compaq.com/SRC/m3defn/html/word-intf.html"><tt>Word</tt></a> interface.
</p><p>

A variable can appear in a constant expression only as an argument
to <tt>FIRST</tt>, <tt>LAST</tt>, <tt>NUMBER</tt>, <tt>BITSIZE</tt>,
<tt>BYTESIZE</tt>, or <tt>ADRSIZE</tt>, and such a variable must not
have an open array type.
Literals and top-level procedure constants are legal in constant
expressions.
</p><p>

</p><h2><a name="UnsafeSect">2.7 Unsafe operations</a></h2>
<p>

</p><blockquote><em>
There are some cases that no law can be framed to cover.  
---Aristotle    
</em></blockquote>
<p>

<a name="idx.206">The</a>
features defined in this section can potentially cause unchecked
runtime errors and are thus forbidden in safe interfaces and modules.
</p><p>

<a name="idx.207">An</a>
unchecked type transfer operation has the form: 
</p><pre>    LOOPHOLE(e, T)
</pre>
where <tt>e</tt> is an expression whose type is not an open array type
and <tt>T</tt> is a type.  It denotes <tt>e</tt>'s bit pattern
interpreted as a variable or value of type <tt>T</tt>.  It is a designator
if <tt>e</tt> is, and is writable if <tt>e</tt> is.
An unchecked runtime error can occur if <tt>e</tt>'s bit pattern
is not a legal <tt>T</tt>, or if <tt>e</tt>
is a designator and some legal bit pattern for <tt>T</tt> is not legal
for <tt>e</tt>.
<p>

If <tt>T</tt> is not an open array type, <tt>BITSIZE(e)</tt> must equal
<tt>BITSIZE(T)</tt>.  If <tt>T</tt> is an open array type, its element type
must not be an open array type, and <tt>e</tt>'s bit pattern is interpreted
as an array whose length is <tt>BITSIZE(e)</tt> divided by
<tt>BITSIZE(</tt>the element type of <tt>T)</tt>.
The division must come out even.
</p><p>

<a name="idx.208">The</a>
following operations are primarily used for address arithmetic:
</p><pre>               ADR  (VAR x: Any)            : ADDRESS 

     infix     +    (x: ADDRESS, y:INTEGER) : ADDRESS
     infix     -    (x: ADDRESS, y:INTEGER) : ADDRESS
     infix     -    (x,y: ADDRESS)          : INTEGER
</pre>
<tt>ADR(x)</tt> is the address of the variable <tt>x</tt>.  The actual 
argument must be a designator but need not be writable.
The operations
<tt>+</tt> and <tt>-</tt> treat addresses as integers.  The validity of the
addresses produced by these operations is implementation-dependent.
For example, the address of a variable in a local procedure frame
is probably valid only for the duration of the call.  The address
of the referent of a traced reference is probably valid only as long
as traced references prevent it from being collected (and not even
that long if the implementation uses a compacting collector).
<p>

<a name="idx.209">In</a>
<a href="#SafetySect">unsafe modules</a> the <tt>INC</tt> and <tt>DEC</tt>
statements apply to addresses as well as ordinals:
</p><pre>               INC  (VAR x: ADDRESS; n: INTEGER := 1)
               DEC  (VAR x: ADDRESS; n: INTEGER := 1)
</pre>
These are short for <tt>x := x + n</tt> and <tt>x := x - n</tt>, except that
<tt>x</tt> is evaluated only once.
<p>

<a name="idx.210">A</a>
<tt>DISPOSE</tt> statement has the form:
</p><pre>               DISPOSE (v)
</pre>
where <tt>v</tt> is a writable designator whose type is not <tt>REFANY</tt>,
<tt>ADDRESS</tt>, or <tt>NULL</tt>.  If <tt>v</tt> is untraced, the statement
frees the storage for <tt>v</tt>'s referent and sets <tt>v</tt> to
<tt>NIL</tt>.
Freeing storage to which active references remain is an unchecked
runtime error.  If <tt>v</tt> is traced, the statement is equivalent to
<tt>v := NIL</tt>.  If <tt>v</tt> is <tt>NIL</tt>, the statement is a no-op.
<p>

<a name="idx.211">In</a>
unsafe interfaces and modules the definition of "assignable" for
types is extended:
two reference types <tt>T</tt> and <tt>U</tt> are assignable
if <tt>T &lt;: U</tt> or <tt>U &lt;: T</tt>.
The only effect of this change is to allow a value of
type <tt>ADDRESS</tt> to be assigned to a variable of type
<tt>UNTRACED REF T</tt>.  It is an unchecked runtime error if the value does
not address a variable of type <tt>T</tt>.
</p><p>

<a name="idx.212">In</a>
unsafe interfaces and modules the type constructor <tt>UNTRACED REF T</tt>
is allowed for traced as well as untraced <tt>T</tt>, and the fields of
untraced objects can be traced.  If <tt>u</tt> is an untraced reference
to a traced variable <tt>t</tt>, then the validity of the traced references
in <tt>t</tt> is implementation-dependent, since the garbage collector
probably will not trace them through <tt>u</tt>.
</p><p>

</p><h2><a name="SyntaxSect">2.8 Syntax</a></h2>
<p>

</p><blockquote><em>
Care should be taken, when using colons and semicolons in the same
sentence,  that the reader understands how far the force of each sign
carries.  
---Robert Graves and Alan Hodge
</em></blockquote>
<p>

</p><h3><a name="idx.213">2.8.1 Keywords</a></h3>
<p>

</p><pre>AND       DO          FROM        NOT         REPEAT     UNTIL   
ANY       ELSE        GENERIC     OBJECT      RETURN     UNTRACED
ARRAY     ELSIF       IF          OF          REVEAL     VALUE   
AS        END         IMPORT      OR          ROOT       VAR     
BEGIN     EVAL        IN          OVERRIDES   SET        WHILE   
BITS      EXCEPT      INTERFACE   PROCEDURE   THEN       WITH    
BRANDED   EXCEPTION   LOCK        RAISE       TO                 
BY        EXIT        LOOP        RAISES      TRY                
CASE      EXPORTS     METHODS     READONLY    TYPE               
CONST     FINALLY     MOD         RECORD      TYPECASE           
DIV       FOR         MODULE      REF         UNSAFE             
</pre>
<p>

</p><h3><a name="idx.214">2.8.2 Reserved identifiers</a></h3>
<p>

</p><pre>ABS       BYTESIZE   EXTENDED  INTEGER    MIN     NUMBER    TEXT    
ADDRESS   CARDINAL   FALSE     ISTYPE     MUTEX   ORD       TRUE    
ADR       CEILING    FIRST     LAST       NARROW  REAL      TRUNC   
ADRSIZE   CHAR       FLOAT     LONGREAL   NEW     REFANY    TYPECODE
BITSIZE   DEC        FLOOR     LOOPHOLE   NIL     ROUND     VAL     
BOOLEAN   DISPOSE    INC       MAX        NULL    SUBARRAY           
</pre>
<p>

</p><h3><a name="idx.215">2.8.3 Operators</a></h3>
<p>

</p><pre>+        &lt;         #        =        ;        ..       :
-        &gt;         {        }        |        :=       &lt;:
*        &lt;=        (        )        ^        ,        =&gt;
/        &gt;=        [        ]        .        &amp;
</pre>
<p>

</p><h3><a name="idx.216">2.8.4 Comments</a></h3>
<p>

A comment is an arbitrary character sequence opened by <tt>(*</tt> and closed
by <tt>*)</tt>.  Comments can be nested and can extend over more than one line.
</p><p>

</p><h3><a name="idx.217">2.8.5 Pragmas</a></h3>
<p>

A pragma is an arbitrary character sequence opened by <tt>&lt;*</tt>
and closed by <tt>*&gt;</tt>.
Pragmas can be nested and can extend over more than one line. 
Pragmas are hints to the implementation; they do not affect the 
language semantics.  
</p><p>

<a name="idx.218">We</a>
recommend supporting the two pragmas <tt>&lt;*INLINE*&gt;</tt> and
<tt>&lt;*EXTERNAL*&gt;</tt>.
The pragma <tt>&lt;*INLINE*&gt;</tt> precedes a procedure
declaration to indicate that the procedure should be expanded at the
point of call.  The pragma <tt>&lt;* EXTERNAL N:L *&gt;</tt> precedes an
interface or a declaration in an interface to indicate that the entity
it precedes is implemented by the language <tt>L</tt>, where it has the
name <tt>N</tt>. If "<tt>:L</tt>" is omitted, then the implementation's
default external language is assumed.  If "<tt>N</tt>" is omitted, then
the external name is determined from the Modula-3 name in some
implementation-dependent way.
</p><p>

</p><h3><a name="idx.219">2.8.6 Conventions for syntax</a></h3>
<p>

We use the following notation for defining syntax:
</p><pre>    X Y      <tt>X</tt> followed by <tt>Y</tt>
    X|Y      <tt>X</tt> or <tt>Y</tt>.  
    [X]      <tt>X</tt> or empty
    {X}      A possibly empty sequence of <tt>X</tt>'s 
    X&amp;Y      <tt>X</tt> or <tt>Y</tt> or <tt>X</tt> <tt>Y</tt>
</pre>
"Followed by" has greater binding power than <tt>|</tt> or <tt>&amp;</tt>;
parentheses are used to override this precedence rule.  Non-terminals
begin with an upper-case letter.  Terminals are either keywords or
quoted operators.  The symbols <tt>Ident</tt>, <tt>Number</tt>,
<tt>TextLiteral</tt>, and <tt>CharLiteral</tt> are defined in the
<a href="#idx.220">token grammar</a>.
Each production is terminated by a period.
The syntax does not reflect the restrictions that revelations
and exceptions can be declared only at the top level; nor does it
include explicit productions for <tt>NEW</tt>, <tt>INC</tt>, and <tt>DEC</tt>,
which parse like procedure calls.
<p>

</p><h3><a name="UnitProdsSect">2.8.7 Compilation unit productions</a></h3>
<p>

</p><pre>Compilation = [UNSAFE] (Interface | Module) | GenInf | GenMod.

Interface   = INTERFACE Id ";" {Import} {Decl} END Id "."
            | INTERFACE Id "=" Id GenActls END Id ".".
Module      = MODULE Id [EXPORTS IdList] ";" {Import} Block Id "."
            | MODULE Id [EXPORTS IdList] "=" Id GenActls END Id ".".

GenInf = GENERIC INTERFACE Id GenFmls ";" {Import} {Decl} END Id ".".
GenMod = GENERIC MODULE Id GenFmls ";" {Import} Block Id ".".

Import      = AsImport | FromImport.
AsImport    = IMPORT ImportItem {"," ImportItem} ";".
FromImport  = FROM Id IMPORT IdList ";".
Block       = {Decl} BEGIN S END.
Decl = CONST {ConstDecl ";"}
     | TYPE {TypeDecl ";"}
     | EXCEPTION {ExceptionDecl ";"}
     | VAR {VariableDecl ";"}
     | ProcedureHead ["=" Block Id] ";" 
     | REVEAL {QualId ("=" | "&lt;:") Type ";"}.

GenFmls        = "(" [IdList] ")".
GenActls       = "(" [IdList] ")".
ImportItem     = Id | Id AS Id.
ConstDecl      = Id [":" Type] "=" ConstExpr.
TypeDecl       = Id ("=" | "&lt;:") Type.
ExceptionDecl  = Id ["(" Type ")"].
VariableDecl   = IdList (":" Type &amp; ":=" Expr).
ProcedureHead  = PROCEDURE Id Signature.

Signature      = "(" Formals ")" [":" Type] [RAISES Raises].
Formals        = [ Formal {";" Formal} [";"] ].
Formal         = [Mode] IdList (":" Type &amp; ":=" ConstExpr).
Mode           = VALUE | VAR | READONLY.
Raises         = "{" [ QualId {"," QualId} ] "}" | ANY.
</pre>
<p>

</p><h3><a name="StmtProdsSect">2.8.8 Statement productions</a></h3>
<p>

</p><pre>Stmt = AssignSt | Block | CallSt | CaseSt | ExitSt | EvalSt | ForSt 
     | IfSt | LockSt | LoopSt | RaiseSt | RepeatSt | ReturnSt 
     | TCaseSt | TryXptSt | TryFinSt | WhileSt | WithSt.

S =  [ Stmt {";" Stmt} [";"] ].

AssignSt = Expr ":=" Expr.
CallSt   = Expr "(" [Actual {"," Actual}] ")".
CaseSt   = CASE Expr OF [Case] {"|" Case} [ELSE S] END.
ExitSt   = EXIT.
EvalSt   = EVAL Expr.
ForSt    = FOR Id ":=" Expr TO Expr [BY Expr] DO S END.
IfSt     = IF Expr THEN S {ELSIF Expr THEN S} [ELSE S] END.
LockSt   = LOCK Expr DO S END.
LoopSt   = LOOP S END.
RaiseSt  = RAISE QualId ["(" Expr ")"].
RepeatSt = REPEAT S UNTIL Expr.
ReturnSt = RETURN [Expr].
TCaseSt  = TYPECASE Expr OF [TCase] {"|" TCase} [ELSE S] END.
TryXptSt = TRY S EXCEPT [Handler] {"|" Handler} [ELSE S] END.
TryFinSt = TRY S FINALLY S END.
WhileSt  = WHILE Expr DO S END.
WithSt   = WITH Binding {"," Binding} DO S END.

Case    = Labels {"," Labels} "=&gt;" S.
Labels  = ConstExpr [".." ConstExpr].
Handler = QualId {"," QualId} ["(" Id ")"] "=&gt;" S.
TCase   = Type {"," Type} ["(" Id ")"] "=&gt;" S.
Binding = Id "=" Expr.
Actual  = Type | [Id ":="] Expr .
</pre>
<p>

</p><h3><a name="TypeProdsSect">2.8.9 Type productions</a></h3>
<p>

</p><pre>Type = TypeName | ArrayType | PackedType | EnumType | ObjectType
     | ProcedureType | RecordType | RefType | SetType | SubrangeType
     | "(" Type ")".

ArrayType     = ARRAY [Type {"," Type}] OF Type.
PackedType    = BITS ConstExpr FOR Type.
EnumType      = "{" [IdList] "}".
ObjectType    = [TypeName | ObjectType] [Brand] OBJECT Fields 
                 [METHODS Methods] [OVERRIDES Overrides] END.
ProcedureType = PROCEDURE Signature.
RecordType    = RECORD Fields END.
RefType       = [UNTRACED] [Brand] REF Type.
SetType       = SET OF Type.
SubrangeType  = "[" ConstExpr ".." ConstExpr "]".

Brand     = BRANDED [ConstExpr].
Fields    = [ Field {";" Field} [";"] ].
Field     = IdList (":" Type &amp; ":=" ConstExpr).
Methods   = [ Method {";" Method} [";"] ].
Method    = Id Signature [":=" ConstExpr].
Overrides = [ Override {";" Override} [";"] ].
Override  = Id ":=" ConstExpr .
</pre>
<p>

</p><h3><a name="ExprProdsSect">2.8.10 Expression productions</a></h3>
<p>

</p><pre>ConstExpr = Expr.

Expr = E1 {OR E1}.
  E1 = E2 {AND E2}.
  E2 = {NOT} E3.
  E3 = E4 {Relop E4}.
  E4 = E5 {Addop E5}.
  E5 = E6 {Mulop E6}.
  E6 = {"+" | "-"} E7.
  E7 = E8 {Selector}.
  E8 = Id | Number | CharLiteral | TextLiteral 
     | Constructor | "(" Expr ")".

Relop =  "=" | "#" | "&lt;"  | "&lt;=" | "&gt;" | "&gt;=" | IN.
Addop =  "+" | "-" | "&amp;".
Mulop =  "*" | "/" | DIV | MOD.

Selector = "^"  |  "." Id  |  "[" Expr {"," Expr} "]"
         | "(" [ Actual {"," Actual} ] ")".

Constructor = Type "{" [ SetCons | RecordCons | ArrayCons ] "}".

SetCons = SetElt {"," SetElt}.
SetElt = Expr [".." Expr].
RecordCons = RecordElt {"," RecordElt}.
RecordElt = [Id ":="] Expr.
ArrayCons =  Expr {"," Expr} ["," ".."].
</pre>
<p>

</p><h3><a name="MiscProdsSect">2.8.11 Miscellaneous productions</a></h3>
<p>

</p><pre>IdList      =  Id {"," Id}.
QualId      =  Id ["." Id].
TypeName    =  QualId | ROOT | UNTRACED ROOT.
</pre>
<p>

</p><h3><a name="idx.220">2.8.12 Token productions</a></h3>
<p>

To read a token, first skip all blanks, tabs, newlines, carriage 
returns, vertical tabs, form feeds, comments, and pragmas.  Then read the 
longest sequence of characters that forms an
<a href="#idx.215">operator</a>
or an <tt>Id</tt> or <tt>Literal</tt>.
</p><p>

<a name="idx.221">An</a>
<tt>Id</tt> is a case-significant sequence of letters, digits, and
underscores that begins with a letter.
An <tt>Id</tt> is a keyword if it appears in the
<a href="#idx.213">list of keywords</a>,
a reserved identifier if it appears in the
<a href="#idx.214">list of reserved identifiers</a>,
and an ordinary identifier otherwise.
</p><p>

In the following grammar, terminals are characters surrounded by
double-quotes and the special terminal <tt>DQUOTE</tt> represents
double-quote itself.
</p><p>

</p><pre>Id = Letter {Letter | Digit | "_"}.

Literal = Number | CharLiteral | TextLiteral.

CharLiteral = "'"  (PrintingChar | Escape | DQUOTE) "'".

TextLiteral = DQUOTE {PrintingChar | Escape | "'"} DQUOTE.

Escape = "\" "n"   | "\" "t"     | "\" "r"     | "\" "f"
       | "\" "\"   | "\" "'"     | "\" DQUOTE
       | "\" OctalDigit OctalDigit OctalDigit.

Number = Digit {Digit}
       | Digit {Digit} "_" HexDigit {HexDigit}
       | Digit {Digit} "." Digit {Digit} [Exp].

Exp = ("E" | "e" | "D" | "d" | "X" | "x") ["+" | "-"] Digit {Digit}.

PrintingChar = Letter | Digit | OtherChar.

HexDigit = Digit | "A" | "B" | "C" | "D" | "E" | "F"
                 | "a" | "b" | "c" | "d" | "e" | "f".

Digit = "0" | "1" | ... | "9".

OctalDigit = "0" | "1" | ... | "7".

Letter = "A"  | "B"  | ... | "Z"  | "a"  | "b"  | ... | "z".

OtherChar = " " | "!" | "#" | "$" | "%" | "&amp;" | "(" | ")"
          | "*" | "+" | "," | "-" | "." | "/" | ":" | ";"
          | "&lt;" | "=" | "&gt;" | "?" | "@" | "[" | "]" | "^"
          | "_" | "`" | "{" | "|" | "}" | "~"
          | ExtendedChar

ExtendedChar = any char with ISO-Latin-1 code in [8_ 240..8_ 377].
</pre>
<p>

</p><h2><a name="AuthorsSect">About the authors</a></h2>

<p>
Luca Cardelli was an undergraduate in Pisa and has a Ph.D. in Computer
Science from the University of Edinburgh (1982).  He worked at AT&amp;T
Bell Labs, Murray Hill, from 1982 to 1985 before assuming his current
position at DEC SRC.  His main interests are in constructive logic,
type theory, and language design and implementation.

</p><p>
Jim Donahue received his Ph.D. in Computer Science at the University
of Toronto (1975).  He was an Assistant Professor at Cornell University
from 1975 to 1981.  In 1981, he joined the Computer Science Laboratory
of the Xerox Palo Alto Research Center.  In 1986, he established the
Olivetti Research Center and was its Director until 1990.  He is now
a Senior Scientist and Product Manager for Teknekron Software Systems.
His interests include programming language design, distributed system
design, and database systems and applications.

</p><p>
Lucille Glassman is a technical writer for DEC SRC.

</p><p>
Mick Jordan has a Ph.D. in Computer Science from the University of
Cambridge.  From 1984 to 1988 he worked at the Acorn Research Center
in Palo Alto on a programming environment for Modula-2+.  Before joining
DEC SRC in 1990 he was at Olivetti Research, where he led the group
that produced the Olivetti Modula-3 implementation.  His principal
current interest is in programming tools that are based on Modula-3
Abstract Syntax Trees.

</p><p>
Bill Kalsow received his Ph.D. in Computer Science from the University
of Wisconsin at Madison (1986).  Since then he has worked as DEC SRC.
His primary interests are programming languages and their
implementations.

</p><p>
Greg Nelson got his Ph.D. from Stanford in 1980, where he worked on
program verification and algorithms for mechanical theorem proving.
He was the author of the Juno constraint-based graphics system at Xerox
PARC's Computer Science Laboratory, has taught at Princeton University,
and is now a member of DEC SRC.  Currently his active interests are
window systems, programming language design, and the semantic theory
of guarded commands.
</p><p>

</p><hr>
<a href="http://www.research.compaq.com/SRC/modula-3/html/home.html">[Modula-3 home page]</a>
<p>
</p><address>m3-request@src.dec.com</address>
<pre>Last modified on Fri Jan  8 10:49:37 PST 1999 by heydon
</pre>
<!-- Server supplied footer starts here-->

<p><font face="Verdana, arial, helvetica" size="1"><a href="http://www.compaq.com/legal.html">Legal 
Statement</a> <a href="http://www.compaq.com/privacy.html">Privacy Statement</a></font>

</p></body></html>