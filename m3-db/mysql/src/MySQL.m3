(*******************************************************************************
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.4
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
*******************************************************************************)

UNSAFE MODULE MySQL;


IMPORT M3toC;
IMPORT MySQLRaw;
IMPORT Ctypes AS C;


TYPE RefRow = UNTRACED REF ARRAY [0 .. MAX_COLUMNS] OF C.char_star;

REVEAL T = UNTRACED BRANDED REF MySQLRaw.MYSQL;

VAR Null := LOOPHOLE(0, ADDRESS);
(* This usage of zeroptr as null does not work VAR zeroValue := 0; zeroPtr
   := LOOPHOLE (ADR (zeroValue), C.char_star); *)

PROCEDURE NewString (t: TEXT): C.char_star =
  VAR res: C.char_star;
  BEGIN
    IF t = NIL THEN res := Null; ELSE res := M3toC.SharedTtoS(t); END;
    RETURN res;
  END NewString;

PROCEDURE FreeString (t: TEXT; c: C.char_star) =
  BEGIN
    IF t # NIL THEN M3toC.FreeSharedS(t, c); END;
  END FreeString;

REVEAL ResT = UNTRACED BRANDED REF MySQLRaw.MYSQL_RES;

REVEAL FieldT = UNTRACED BRANDED REF MySQLRaw.MYSQL_FIELD;

REVEAL ManagerT = UNTRACED BRANDED REF MySQLRaw.MYSQL_MANAGER;

REVEAL ParametersT = UNTRACED BRANDED REF MySQLRaw.MYSQL_PARAMETERS;

REVEAL
  StmtT = UNTRACED BRANDED REF MySQLRaw.MYSQL_STMT;
  BindT = UNTRACED BRANDED REF MySQLRaw.MYSQL_BIND;

REVEAL CharsT = UNTRACED BRANDED REF MySQLRaw.MYSQL_CHARSET_INFO;

PROCEDURE ServerInit
  (argc: INTEGER; READONLY argv, groups: ARRAY OF TEXT; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg2            := NEW(UNTRACED REF ARRAY OF C.char_star, argc + 1);
    arg3            := NEW(UNTRACED REF ARRAY OF C.char_star, argc + 1);
    result: INTEGER;
  BEGIN


    FOR i := 0 TO argc - 1 DO arg2[i] := M3toC.CopyTtoS(argv[i]); END;
    arg2[argc] := NIL;


    FOR i := 0 TO argc - 1 DO arg3[i] := M3toC.CopyTtoS(groups[i]); END;
    arg3[argc] := NIL;
    result := MySQLRaw.ServerInit(argc, ADR(arg2[0]), ADR(arg3[0]));
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END ServerInit;

PROCEDURE ServerEnd () =
  BEGIN
    MySQLRaw.ServerEnd();
  END ServerEnd;

PROCEDURE GetParameters (): ParametersT =
  VAR
    ret   : MySQLRaw.RefMysqlParametersT;
    result: ParametersT;
  BEGIN
    ret := MySQLRaw.GetParameters();
    result := LOOPHOLE(ret, ParametersT);
    RETURN result;
  END GetParameters;

PROCEDURE ThreadInit (): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
  BEGIN
    ret := MySQLRaw.ThreadInit();
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END ThreadInit;

PROCEDURE ThreadEnd () =
  BEGIN
    MySQLRaw.ThreadEnd();
  END ThreadEnd;

PROCEDURE NumRows (res: ResT; ): LONGINT =
  VAR arg1: MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    RETURN MySQLRaw.NumRows(arg1);
  END NumRows;

PROCEDURE NumFields (res: ResT; ): CARDINAL =
  VAR arg1: MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    RETURN MySQLRaw.NumFields(arg1);
  END NumFields;

PROCEDURE Eof (res: ResT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    ret := MySQLRaw.Eof(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Eof;

PROCEDURE FetchFieldDirect (res: ResT; fieldnr: CARDINAL; ): FieldT =
  VAR
    ret   : MySQLRaw.RefMysqlFieldT;
    result: FieldT;
    arg1: MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    ret := MySQLRaw.FetchFieldDirect(arg1, fieldnr);
    result := LOOPHOLE(ret, FieldT);
    RETURN result;
  END FetchFieldDirect;

PROCEDURE FetchFields (res: ResT; ): FieldT =
  VAR
    ret   : MySQLRaw.RefMysqlFieldT;
    result: FieldT;
    arg1: MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    ret := MySQLRaw.FetchFields(arg1);
    result := LOOPHOLE(ret, FieldT);
    RETURN result;
  END FetchFields;

PROCEDURE RowTell (res: ResT; ): RefMysqlRowsT =
  VAR arg1: MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    RETURN MySQLRaw.RowTell(arg1);
  END RowTell;

PROCEDURE FieldTell (res: ResT; ): CARDINAL =
  VAR arg1: MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    RETURN MySQLRaw.FieldTell(arg1);
  END FieldTell;

PROCEDURE FieldCount (mysql: T; ): CARDINAL =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.FieldCount(arg1);
  END FieldCount;

PROCEDURE AffectedRows (mysql: T; ): LONGINT =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.AffectedRows(arg1);
  END AffectedRows;

PROCEDURE InsertId (mysql: T; ): LONGINT =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.InsertId(arg1);
  END InsertId;

PROCEDURE Errno (mysql: T; ): CARDINAL =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.Errno(arg1);
  END Errno;

PROCEDURE Error (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.Error(arg1);
    RETURN M3toC.CopyStoT(result);
  END Error;

PROCEDURE Sqlstate (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.Sqlstate(arg1);
    RETURN M3toC.CopyStoT(result);
  END Sqlstate;

PROCEDURE WarningCount (mysql: T; ): CARDINAL =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.WarningCount(arg1);
  END WarningCount;

PROCEDURE Info (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.Info(arg1);
    RETURN M3toC.CopyStoT(result);
  END Info;

PROCEDURE ThreadId (mysql: T; ): CARDINAL =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.ThreadId(arg1);
  END ThreadId;

PROCEDURE CharacterSetName (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.CharacterSetName(arg1);
    RETURN M3toC.CopyStoT(result);
  END CharacterSetName;

PROCEDURE SetCharacterSet (mysql: T; csname: TEXT; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(csname);
      result := MySQLRaw.SetCharacterSet(arg1, arg2);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(csname, arg2);
    END;
    RETURN result;
  END SetCharacterSet;

PROCEDURE Init (mysql: T; ): T RAISES {ConnE} =
  VAR
    ret   : MySQLRaw.RefMysqlT;
    result: T;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.Init(arg1);
    result := LOOPHOLE(ret, T);
    IF result = NIL THEN RAISE ConnE; END;
    RETURN result;
  END Init;

PROCEDURE SslSet (mysql: T; key, cert, ca, capath, cipher: TEXT; ):
  BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    arg3  : C.const_char_star;
    arg4  : C.const_char_star;
    arg5  : C.const_char_star;
    arg6  : C.const_char_star;
  BEGIN
    arg2 := NewString(key);
    arg3 := NewString(cert);
    arg4 := NewString(ca);
    arg5 := NewString(capath);
    arg6 := NewString(cipher);
    ret := MySQLRaw.SslSet(arg1, arg2, arg3, arg4, arg5, arg6);
    result := VAL(ret, BOOLEAN);
    FreeString(key, arg2);
    FreeString(cert, arg3);
    FreeString(ca, arg4);
    FreeString(capath, arg5);
    FreeString(cipher, arg6);
    RETURN result;
  END SslSet;

PROCEDURE ChangeUser (mysql: T; user, passwd, db: TEXT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    arg3  : C.const_char_star;
    arg4  : C.const_char_star;
  BEGIN
    arg2 := NewString(user);
    arg3 := NewString(passwd);
    arg4 := NewString(db);
    ret := MySQLRaw.ChangeUser(arg1, arg2, arg3, arg4);
    result := VAL(ret, BOOLEAN);
    FreeString(user, arg2);
    FreeString(passwd, arg3);
    FreeString(db, arg4);
    RETURN result;
  END ChangeUser;

PROCEDURE RealConnect (mysql                 : T;
                       host, user, passwd, db: TEXT;
                       port                  : CARDINAL;
                       unix_socket           : TEXT;
                       clientflag            : CARDINAL; ): T
  RAISES {ConnE} =
  VAR
    ret   : MySQLRaw.RefMysqlT;
    result: T;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    arg3  : C.const_char_star;
    arg4  : C.const_char_star;
    arg5  : C.const_char_star;
    arg7  : C.const_char_star;
  BEGIN
    TRY
      arg2 := NewString(host);
      arg3 := NewString(user);
      arg4 := NewString(passwd);
      arg5 := NewString(db);
      arg7 := NewString(unix_socket);
      ret := MySQLRaw.RealConnect(
               arg1, arg2, arg3, arg4, arg5, port, arg7, clientflag);
      result := LOOPHOLE(ret, T);
      IF result = NIL THEN RAISE ConnE; END;
    FINALLY
      FreeString(host, arg2);
      FreeString(user, arg3);
      FreeString(passwd, arg4);
      FreeString(db, arg5);
      FreeString(unix_socket, arg7);
    END;
    RETURN result;
  END RealConnect;

PROCEDURE SelectDb (mysql: T; db: TEXT; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(db);
      result := MySQLRaw.SelectDb(arg1, arg2);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(db, arg2);
    END;
    RETURN result;
  END SelectDb;

PROCEDURE Query (mysql: T; q: TEXT; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(q);
      result := MySQLRaw.Query(arg1, arg2);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(q, arg2);
    END;
    RETURN result;
  END Query;

PROCEDURE SendQuery (mysql: T; q: TEXT; length: CARDINAL; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(q);
      result := MySQLRaw.SendQuery(arg1, arg2, length);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(q, arg2);
    END;
    RETURN result;
  END SendQuery;

PROCEDURE RealQuery (mysql: T; q: TEXT; length: CARDINAL; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(q);
      result := MySQLRaw.RealQuery(arg1, arg2, length);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(q, arg2);
    END;
    RETURN result;
  END RealQuery;

PROCEDURE StoreResult (mysql: T; ): ResT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResT;
    result: ResT;
    arg1  : MySQLRaw.RefMysqlT    := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.StoreResult(arg1);
    result := LOOPHOLE(ret, ResT);
    IF result = NIL THEN RAISE ResultE; END;
    RETURN result;
  END StoreResult;

PROCEDURE UseResult (mysql: T; ): ResT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResT;
    result: ResT;
    arg1  : MySQLRaw.RefMysqlT    := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.UseResult(arg1);
    result := LOOPHOLE(ret, ResT);
    IF result = NIL THEN RAISE ResultE; END;
    RETURN result;
  END UseResult;

PROCEDURE MasterQuery (mysql: T; q: TEXT; length: CARDINAL; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
  BEGIN
    arg2 := NewString(q);
    ret := MySQLRaw.MasterQuery(arg1, arg2, length);
    result := VAL(ret, BOOLEAN);
    FreeString(q, arg2);
    RETURN result;
  END MasterQuery;

PROCEDURE MasterSendQuery (mysql: T; q: TEXT; length: CARDINAL; ):
  BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
  BEGIN
    arg2 := NewString(q);
    ret := MySQLRaw.MasterSendQuery(arg1, arg2, length);
    result := VAL(ret, BOOLEAN);
    FreeString(q, arg2);
    RETURN result;
  END MasterSendQuery;

PROCEDURE SlaveQuery (mysql: T; q: TEXT; length: CARDINAL; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
  BEGIN
    arg2 := NewString(q);
    ret := MySQLRaw.SlaveQuery(arg1, arg2, length);
    result := VAL(ret, BOOLEAN);
    FreeString(q, arg2);
    RETURN result;
  END SlaveQuery;

PROCEDURE SlaveSendQuery (mysql: T; q: TEXT; length: CARDINAL; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
  BEGIN
    arg2 := NewString(q);
    ret := MySQLRaw.SlaveSendQuery(arg1, arg2, length);
    result := VAL(ret, BOOLEAN);
    FreeString(q, arg2);
    RETURN result;
  END SlaveSendQuery;

PROCEDURE GetCharSetInfo (mysql: T; VAR charset: CharsT; ) =
  VAR
    arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2: MySQLRaw.RefMysqlCharsT := LOOPHOLE(
                                       charset, MySQLRaw.RefMysqlCharsT);
  BEGIN
    MySQLRaw.GetCharSetInfo(arg1, arg2);
  END GetCharSetInfo;

PROCEDURE SetLocalInfileHandler (    mysql             : T;
                                     local_infile_init : InitCBT;
                                     local_infile_read : ReadCBT;
                                     local_infile_end  : EndCBT;
                                     local_infile_error: ErrorCBT;
                                 VAR userdata          : REFANY;   ) =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);

  PROCEDURE P0 (p1: REF C.void_star; p2: C.char_star; p3: C.void_star):
    C.int =
    VAR
      r1: REF ADDRESS := p1;
      r2              := M3toC.CopyStoT(p2);
      r3              := p3;
    BEGIN
      RETURN local_infile_init(r1, r2, r3);
    END P0;


  PROCEDURE P1 (p1: C.void_star; p2: C.char_star; p3: C.unsigned_int):
    C.int =
    VAR
      r1: ADDRESS := p1;
      r2          := M3toC.CopyStoT(p2);
      r3          := p3;
    BEGIN
      RETURN local_infile_read(r1, r2, r3);
    END P1;


  PROCEDURE P2 (p1: C.void_star; p2: C.char_star; p3: C.unsigned_int):
    C.int =
    VAR
      r1: ADDRESS := p1;
      r2          := M3toC.CopyStoT(p2);
      r3          := p3;
    BEGIN
      RETURN local_infile_error(r1, r2, r3);
    END P2;
  VAR

    arg6: ADDRESS := LOOPHOLE(userdata, ADDRESS);
  BEGIN
    MySQLRaw.SetLocalInfileHandler(arg1, <* NOWARN *> P0, <* NOWARN *> P1,
                                   local_infile_end, <* NOWARN *> P2, arg6);
  END SetLocalInfileHandler;

PROCEDURE SetLocalInfileDefault (mysql: T; ) =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    MySQLRaw.SetLocalInfileDefault(arg1);
  END SetLocalInfileDefault;

PROCEDURE EnableRplParse (mysql: T; ) =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    MySQLRaw.EnableRplParse(arg1);
  END EnableRplParse;

PROCEDURE DisableRplParse (mysql: T; ) =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    MySQLRaw.DisableRplParse(arg1);
  END DisableRplParse;

PROCEDURE RplParseEnabled (mysql: T; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.RplParseEnabled(arg1);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END RplParseEnabled;

PROCEDURE EnableReadsFromMaster (mysql: T; ) =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    MySQLRaw.EnableReadsFromMaster(arg1);
  END EnableReadsFromMaster;

PROCEDURE DisableReadsFromMaster (mysql: T; ) =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    MySQLRaw.DisableReadsFromMaster(arg1);
  END DisableReadsFromMaster;

PROCEDURE ReadsFromMasterEnabled (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.ReadsFromMasterEnabled(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END ReadsFromMasterEnabled;

PROCEDURE RplQueryType (q: TEXT; len: INTEGER; ): RplT =
  VAR
    arg1  : C.const_char_star;
    result: RplT;
  BEGIN
    arg1 := NewString(q);
    result := MySQLRaw.RplQueryType(arg1, len);
    FreeString(q, arg1);
    RETURN result;
  END RplQueryType;

PROCEDURE RplProbe (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.RplProbe(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END RplProbe;

PROCEDURE SetMaster
  (mysql: T; host: TEXT; port: CARDINAL; user, passwd: TEXT; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    arg4  : C.const_char_star;
    arg5  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(host);
      arg4 := NewString(user);
      arg5 := NewString(passwd);
      result := MySQLRaw.SetMaster(arg1, arg2, port, arg4, arg5);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(host, arg2);
      FreeString(user, arg4);
      FreeString(passwd, arg5);
    END;
    RETURN result;
  END SetMaster;

PROCEDURE AddSlave
  (mysql: T; host: TEXT; port: CARDINAL; user, passwd: TEXT; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    arg4  : C.const_char_star;
    arg5  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(host);
      arg4 := NewString(user);
      arg5 := NewString(passwd);
      result := MySQLRaw.AddSlave(arg1, arg2, port, arg4, arg5);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(host, arg2);
      FreeString(user, arg4);
      FreeString(passwd, arg5);
    END;
    RETURN result;
  END AddSlave;

PROCEDURE Shutdown (mysql: T; shutdown_level: INTEGER; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.Shutdown(arg1, shutdown_level);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END Shutdown;

PROCEDURE DumpDebugInfo (mysql: T; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.DumpDebugInfo(arg1);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END DumpDebugInfo;

PROCEDURE Refresh (mysql: T; refresh_options: CARDINAL; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.Refresh(arg1, refresh_options);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END Refresh;

PROCEDURE Kill (mysql: T; pid: CARDINAL; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.Kill(arg1, pid);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END Kill;

PROCEDURE SetServerOption (mysql: T; option: INTEGER; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.SetServerOption(arg1, option);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END SetServerOption;

PROCEDURE Ping (mysql: T; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.Ping(arg1);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END Ping;

PROCEDURE Stat (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.Stat(arg1);
    RETURN M3toC.CopyStoT(result);
  END Stat;

PROCEDURE GetServerInfo (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.GetServerInfo(arg1);
    RETURN M3toC.CopyStoT(result);
  END GetServerInfo;

PROCEDURE GetClientInfo (): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := MySQLRaw.GetClientInfo();
    RETURN M3toC.CopyStoT(result);
  END GetClientInfo;

PROCEDURE GetClientVersion (): CARDINAL =
  BEGIN
    RETURN MySQLRaw.GetClientVersion();
  END GetClientVersion;

PROCEDURE GetHostInfo (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.GetHostInfo(arg1);
    RETURN M3toC.CopyStoT(result);
  END GetHostInfo;

PROCEDURE GetServerVersion (mysql: T; ): CARDINAL =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.GetServerVersion(arg1);
  END GetServerVersion;

PROCEDURE GetProtoInfo (mysql: T; ): CARDINAL =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.GetProtoInfo(arg1);
  END GetProtoInfo;

PROCEDURE ListDbs (mysql: T; wild: TEXT; ): ResT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResT;
    result: ResT;
    arg1  : MySQLRaw.RefMysqlT    := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
  BEGIN
    TRY
      arg2 := NewString(wild);
      ret := MySQLRaw.ListDbs(arg1, arg2);
      result := LOOPHOLE(ret, ResT);
      IF result = NIL THEN RAISE ResultE; END;
    FINALLY
      FreeString(wild, arg2);
    END;
    RETURN result;
  END ListDbs;

PROCEDURE ListTables (mysql: T; wild: TEXT; ): ResT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResT;
    result: ResT;
    arg1  : MySQLRaw.RefMysqlT    := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
  BEGIN
    TRY
      arg2 := NewString(wild);
      ret := MySQLRaw.ListTables(arg1, arg2);
      result := LOOPHOLE(ret, ResT);
      IF result = NIL THEN RAISE ResultE; END;
    FINALLY
      FreeString(wild, arg2);
    END;
    RETURN result;
  END ListTables;

PROCEDURE ListProcesses (mysql: T; ): ResT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResT;
    result: ResT;
    arg1  : MySQLRaw.RefMysqlT    := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.ListProcesses(arg1);
    result := LOOPHOLE(ret, ResT);
    IF result = NIL THEN RAISE ResultE; END;
    RETURN result;
  END ListProcesses;

PROCEDURE Options (mysql: T; option: INTEGER; arg: TEXT; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg3 := NewString(arg);
      result := MySQLRaw.Options(arg1, option, arg3);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(arg, arg3);
    END;
    RETURN result;
  END Options;

PROCEDURE FreeResult (res: ResT; ) =
  VAR arg1: MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    MySQLRaw.FreeResult(arg1);
  END FreeResult;

PROCEDURE DataSeek (res: ResT; offset: LONGINT; ) =
  VAR arg1: MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    MySQLRaw.DataSeek(arg1, offset);
  END DataSeek;

PROCEDURE RowSeek (res: ResT; offset: RefMysqlRowsT; ): RefMysqlRowsT =
  VAR arg1: MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    RETURN MySQLRaw.RowSeek(arg1, offset);
  END RowSeek;

PROCEDURE FieldSeek (res: ResT; offset: CARDINAL; ): CARDINAL =
  VAR arg1: MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    RETURN MySQLRaw.FieldSeek(arg1, offset);
  END FieldSeek;

PROCEDURE FetchRow (res: ResT; ): REF ARRAY OF TEXT =
  VAR
    ret      : C.char_star_star;
    result   : RefRow;
    numFields: INTEGER;
    row      : REF ARRAY OF TEXT;
    arg1: MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    ret := MySQLRaw.FetchRow(arg1);
    IF ret = NIL THEN
      row := NIL;
    ELSE
      result := LOOPHOLE(ret, RefRow);
      numFields := NumFields(res);
      row := NEW(REF ARRAY OF TEXT, numFields);
      FOR i := 0 TO numFields - 1 DO
        (* DB NULL results in NIL M3 text *)
        IF result[i] # NIL THEN row[i] := M3toC.CopyStoT(result[i]) END;
      END;
    END;
    RETURN row;
  END FetchRow;

PROCEDURE FetchLengths (res: ResT; ): RefLengthsT =
  VAR
    ret   : C.unsigned_long_star;
    result: RefLengthsT;
    arg1  : MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    ret := MySQLRaw.FetchLengths(arg1);
    result := LOOPHOLE(ret, RefLengthsT);
    RETURN result;
  END FetchLengths;

PROCEDURE FetchField (res: ResT; ): FieldT =
  VAR
    ret   : MySQLRaw.RefMysqlFieldT;
    result: FieldT;
    arg1: MySQLRaw.RefMysqlResT := LOOPHOLE(res, MySQLRaw.RefMysqlResT);
  BEGIN
    ret := MySQLRaw.FetchField(arg1);
    result := LOOPHOLE(ret, FieldT);
    RETURN result;
  END FetchField;

PROCEDURE ListFields (mysql: T; table, wild: TEXT; ): ResT
  RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResT;
    result: ResT;
    arg1  : MySQLRaw.RefMysqlT    := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    arg3  : C.const_char_star;
  BEGIN
    TRY
      arg2 := NewString(table);
      arg3 := NewString(wild);
      ret := MySQLRaw.ListFields(arg1, arg2, arg3);
      result := LOOPHOLE(ret, ResT);
      IF result = NIL THEN RAISE ResultE; END;
    FINALLY
      FreeString(table, arg2);
      FreeString(wild, arg3);
    END;
    RETURN result;
  END ListFields;

PROCEDURE EscapeString (to, from: TEXT; from_length: CARDINAL; ):
  CARDINAL =
  VAR
    arg1  : C.char_star;
    arg2  : C.const_char_star;
    result: CARDINAL;
  BEGIN
    arg1 := NewString(to);
    arg2 := NewString(from);
    result := MySQLRaw.EscapeString(arg1, arg2, from_length);
    FreeString(to, arg1);
    FreeString(from, arg2);
    RETURN result;
  END EscapeString;

PROCEDURE HexString (to, from: TEXT; from_length: CARDINAL; ): CARDINAL =
  VAR
    arg1  : C.char_star;
    arg2  : C.const_char_star;
    result: CARDINAL;
  BEGIN
    arg1 := NewString(to);
    arg2 := NewString(from);
    result := MySQLRaw.HexString(arg1, arg2, from_length);
    FreeString(to, arg1);
    FreeString(from, arg2);
    RETURN result;
  END HexString;

PROCEDURE RealEscapeString (mysql: T; to, from: TEXT; length: CARDINAL; ):
  CARDINAL =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.char_star;
    arg3  : C.const_char_star;
    result: CARDINAL;
  BEGIN
    arg2 := NewString(to);
    arg3 := NewString(from);
    result := MySQLRaw.RealEscapeString(arg1, arg2, arg3, length);
    FreeString(to, arg2);
    FreeString(from, arg3);
    RETURN result;
  END RealEscapeString;

PROCEDURE Debug (debug: TEXT; ) =
  VAR arg1: C.const_char_star;
  BEGIN
    arg1 := NewString(debug);
    MySQLRaw.Debug(arg1);
    FreeString(debug, arg1);
  END Debug;

PROCEDURE OdbcEscapeString (    mysql        : T;
                                to           : TEXT;
                                to_length    : CARDINAL;
                                from         : TEXT;
                                from_length  : CARDINAL;
                            VAR param        : REFANY;
                                extend_buffer: ExtendCBT; ): TEXT =
  VAR
    result: C.char_star;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.char_star;
    arg4  : C.const_char_star;
    arg6  : ADDRESS            := LOOPHOLE(param, ADDRESS);

  PROCEDURE P0 (p1: C.void_star; p2: C.char_star; p3: REF C.unsigned_long):
    C.char_star =
    VAR
      r1: ADDRESS := p1;
      r2          := M3toC.CopyStoT(p2);
      r3          := LOOPHOLE(p3, REF LONGINT);
    BEGIN
      RETURN M3toC.CopyTtoS(extend_buffer(r1, r2, r3));
    END P0;

  BEGIN
    arg2 := NewString(to);
    arg4 := NewString(from);
    result :=
      MySQLRaw.OdbcEscapeString(
        arg1, arg2, to_length, arg4, from_length, arg6, <* NOWARN *> P0);
    FreeString(to, arg2);
    FreeString(from, arg4);
    RETURN M3toC.CopyStoT(result);
  END OdbcEscapeString;

PROCEDURE RemoveEscape (mysql: T; name: TEXT; ) =
  VAR
    arg1: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2: C.char_star;
  BEGIN
    arg2 := NewString(name);
    MySQLRaw.RemoveEscape(arg1, arg2);
    FreeString(name, arg2);
  END RemoveEscape;

PROCEDURE ThreadSafe (): CARDINAL =
  BEGIN
    RETURN MySQLRaw.ThreadSafe();
  END ThreadSafe;

PROCEDURE Embedded (): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
  BEGIN
    ret := MySQLRaw.Embedded();
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Embedded;

PROCEDURE ManagerInit (con: ManagerT; ): ManagerT RAISES {ConnE} =
  VAR
    ret   : MySQLRaw.RefMysqlManagerT;
    result: ManagerT;

    arg1: MySQLRaw.RefMysqlManagerT := LOOPHOLE(
                                         con, MySQLRaw.RefMysqlManagerT);
  BEGIN
    ret := MySQLRaw.ManagerInit(arg1);
    result := LOOPHOLE(ret, ManagerT);
    IF result = NIL THEN RAISE ConnE; END;
    RETURN result;
  END ManagerInit;

PROCEDURE ManagerConnect
  (con: ManagerT; host, user, passwd: TEXT; port: CARDINAL; ): ManagerT
  RAISES {ConnE} =
  VAR
    ret   : MySQLRaw.RefMysqlManagerT;
    result: ManagerT;

    arg1: MySQLRaw.RefMysqlManagerT := LOOPHOLE(
                                         con, MySQLRaw.RefMysqlManagerT);
    arg2: C.const_char_star;
    arg3: C.const_char_star;
    arg4: C.const_char_star;
  BEGIN
    TRY
      arg2 := NewString(host);
      arg3 := NewString(user);
      arg4 := NewString(passwd);
      ret := MySQLRaw.ManagerConnect(arg1, arg2, arg3, arg4, port);
      result := LOOPHOLE(ret, ManagerT);
      IF result = NIL THEN RAISE ConnE; END;
    FINALLY
      FreeString(host, arg2);
      FreeString(user, arg3);
      FreeString(passwd, arg4);
    END;
    RETURN result;
  END ManagerConnect;

PROCEDURE ManagerClose (con: ManagerT; ) =
  VAR
    arg1: MySQLRaw.RefMysqlManagerT := LOOPHOLE(
                                         con, MySQLRaw.RefMysqlManagerT);
  BEGIN
    MySQLRaw.ManagerClose(arg1);
  END ManagerClose;

PROCEDURE ManagerCommand (con: ManagerT; cmd: TEXT; cmd_len: INTEGER; ):
  INTEGER RAISES {ReturnE} =
  VAR
    arg1: MySQLRaw.RefMysqlManagerT := LOOPHOLE(
                                         con, MySQLRaw.RefMysqlManagerT);
    arg2  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(cmd);
      result := MySQLRaw.ManagerCommand(arg1, arg2, cmd_len);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(cmd, arg2);
    END;
    RETURN result;
  END ManagerCommand;

PROCEDURE ManagerFetchLine
  (con: ManagerT; res_buf: TEXT; res_buf_size: INTEGER; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg1: MySQLRaw.RefMysqlManagerT := LOOPHOLE(
                                         con, MySQLRaw.RefMysqlManagerT);
    arg2  : C.char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(res_buf);
      result := MySQLRaw.ManagerFetchLine(arg1, arg2, res_buf_size);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(res_buf, arg2);
    END;
    RETURN result;
  END ManagerFetchLine;

PROCEDURE ReadQueryResult (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.ReadQueryResult(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END ReadQueryResult;

PROCEDURE StmtInit (mysql: T; ): StmtT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlStmtT;
    result: StmtT;
    arg1  : MySQLRaw.RefMysqlT     := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.StmtInit(arg1);
    result := LOOPHOLE(ret, StmtT);
    IF result = NIL THEN RAISE ResultE; END;
    RETURN result;
  END StmtInit;

PROCEDURE StmtPrepare (stmt: StmtT; query: TEXT; length: CARDINAL; ):
  INTEGER RAISES {ReturnE} =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg2: C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(query);
      result := MySQLRaw.StmtPrepare(arg1, arg2, length);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(query, arg2);
    END;
    RETURN result;
  END StmtPrepare;

PROCEDURE StmtExecute (stmt: StmtT; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.StmtExecute(arg1);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END StmtExecute;

PROCEDURE StmtFetch (stmt: StmtT; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.StmtFetch(arg1);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END StmtFetch;

PROCEDURE StmtFetchColumn
  (stmt: StmtT; bind: BindT; column, offset: CARDINAL; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg2: MySQLRaw.RefMysqlBindT := LOOPHOLE(bind, MySQLRaw.RefMysqlBindT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.StmtFetchColumn(arg1, arg2, column, offset);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END StmtFetchColumn;

PROCEDURE StmtStoreResult (stmt: StmtT; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.StmtStoreResult(arg1);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END StmtStoreResult;

PROCEDURE StmtParamCount (stmt: StmtT; ): CARDINAL =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtParamCount(arg1);
  END StmtParamCount;

PROCEDURE StmtAttrSet
  (stmt: StmtT; attr_type: INTEGER; READONLY attr: REFANY; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg3: ADDRESS                := LOOPHOLE(attr, ADDRESS);
  BEGIN
    ret := MySQLRaw.StmtAttrSet(arg1, attr_type, arg3);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtAttrSet;

PROCEDURE StmtAttrGet
  (stmt: StmtT; attr_type: INTEGER; VAR attr: REFANY; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg3: ADDRESS                := LOOPHOLE(attr, ADDRESS);
  BEGIN
    ret := MySQLRaw.StmtAttrGet(arg1, attr_type, arg3);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtAttrGet;

PROCEDURE StmtBindParam (stmt: StmtT; bnd: BindT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg2: MySQLRaw.RefMysqlBindT := LOOPHOLE(bnd, MySQLRaw.RefMysqlBindT);
  BEGIN
    ret := MySQLRaw.StmtBindParam(arg1, arg2);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtBindParam;

PROCEDURE StmtBindResult (stmt: StmtT; bnd: BindT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg2: MySQLRaw.RefMysqlBindT := LOOPHOLE(bnd, MySQLRaw.RefMysqlBindT);
  BEGIN
    ret := MySQLRaw.StmtBindResult(arg1, arg2);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtBindResult;

PROCEDURE StmtClose (stmt: StmtT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    ret := MySQLRaw.StmtClose(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtClose;

PROCEDURE StmtReset (stmt: StmtT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    ret := MySQLRaw.StmtReset(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtReset;

PROCEDURE StmtFreeResult (stmt: StmtT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    ret := MySQLRaw.StmtFreeResult(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtFreeResult;

PROCEDURE StmtSendLongData
  (stmt: StmtT; param_number: CARDINAL; data: TEXT; length: CARDINAL; ):
  BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg3: C.const_char_star;
  BEGIN
    arg3 := NewString(data);
    ret := MySQLRaw.StmtSendLongData(arg1, param_number, arg3, length);
    result := VAL(ret, BOOLEAN);
    FreeString(data, arg3);
    RETURN result;
  END StmtSendLongData;

PROCEDURE StmtResultMetadata (stmt: StmtT; ): ResT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResT;
    result: ResT;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    ret := MySQLRaw.StmtResultMetadata(arg1);
    result := LOOPHOLE(ret, ResT);
    IF result = NIL THEN RAISE ResultE; END;
    RETURN result;
  END StmtResultMetadata;

PROCEDURE StmtParamMetadata (stmt: StmtT; ): ResT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResT;
    result: ResT;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    ret := MySQLRaw.StmtParamMetadata(arg1);
    result := LOOPHOLE(ret, ResT);
    IF result = NIL THEN RAISE ResultE; END;
    RETURN result;
  END StmtParamMetadata;

PROCEDURE StmtErrno (stmt: StmtT; ): CARDINAL =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtErrno(arg1);
  END StmtErrno;

PROCEDURE StmtError (stmt: StmtT; ): TEXT =
  VAR
    result: C.char_star;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    result := MySQLRaw.StmtError(arg1);
    RETURN M3toC.CopyStoT(result);
  END StmtError;

PROCEDURE StmtSqlstate (stmt: StmtT; ): TEXT =
  VAR
    result: C.char_star;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    result := MySQLRaw.StmtSqlstate(arg1);
    RETURN M3toC.CopyStoT(result);
  END StmtSqlstate;

PROCEDURE StmtRowSeek (stmt: StmtT; offset: RefMysqlRowsT; ):
  RefMysqlRowsT =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtRowSeek(arg1, offset);
  END StmtRowSeek;

PROCEDURE StmtRowTell (stmt: StmtT; ): RefMysqlRowsT =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtRowTell(arg1);
  END StmtRowTell;

PROCEDURE StmtDataSeek (stmt: StmtT; offset: LONGINT; ) =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    MySQLRaw.StmtDataSeek(arg1, offset);
  END StmtDataSeek;

PROCEDURE StmtNumRows (stmt: StmtT; ): LONGINT =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtNumRows(arg1);
  END StmtNumRows;

PROCEDURE StmtAffectedRows (stmt: StmtT; ): LONGINT =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtAffectedRows(arg1);
  END StmtAffectedRows;

PROCEDURE StmtInsertId (stmt: StmtT; ): LONGINT =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtInsertId(arg1);
  END StmtInsertId;

PROCEDURE StmtFieldCount (stmt: StmtT; ): CARDINAL =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtFieldCount(arg1);
  END StmtFieldCount;

PROCEDURE Commit (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.Commit(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Commit;

PROCEDURE Rollback (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.Rollback(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Rollback;

PROCEDURE Autocommit (mysql: T; auto_mode: BOOLEAN; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2                       := LOOPHOLE(auto_mode, MySQLRaw.my_bool);
  BEGIN
    ret := MySQLRaw.Autocommit(arg1, arg2);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Autocommit;

PROCEDURE MoreResults (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.MoreResults(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END MoreResults;

PROCEDURE NextResult (mysql: T; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.NextResult(arg1);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END NextResult;

PROCEDURE Close (sock: T; ) =
  VAR arg1: MySQLRaw.RefMysqlT := LOOPHOLE(sock, MySQLRaw.RefMysqlT);
  BEGIN
    MySQLRaw.Close(arg1);
  END Close;


BEGIN
END MySQL.
