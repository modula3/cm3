(*******************************************************************************
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
*******************************************************************************)

UNSAFE MODULE MySQL;


IMPORT M3toC;
IMPORT MySQLRaw;
IMPORT Ctypes AS C;


TYPE RefRow = UNTRACED REF ARRAY [0 .. MAX_COLUMNS] OF C.char_star;

REVEAL
  T = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  ResultT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  StmtT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  RowOffsetT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  ManagerT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  ParametersT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  BindT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  CharsT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;

VAR Null := LOOPHOLE(0, ADDRESS);

PROCEDURE NewString (t: TEXT): C.char_star =
  VAR res: C.char_star;
  BEGIN
    IF t = NIL THEN res := Null; ELSE res := M3toC.CopyTtoS(t); END;
    RETURN res;
  END NewString;

PROCEDURE FreeString (t: TEXT; c: C.char_star) =
  BEGIN
    IF t # NIL THEN M3toC.FreeCopiedS(c); END;
  END FreeString;

PROCEDURE ToText (s: C.char_star): TEXT =
  BEGIN
    IF s # NIL THEN RETURN M3toC.CopyStoT(s); ELSE RETURN NIL; END;
  END ToText;

PROCEDURE NewField (READONLY fieldRef: MySQLRaw.MYSQL_FIELD): FieldT =
  VAR ret := NEW(FieldT);
  BEGIN
    ret.name := ToText(fieldRef.name);
    ret.org_name := ToText(fieldRef.org_name);
    ret.table := ToText(fieldRef.table);
    ret.org_table := ToText(fieldRef.org_table);
    ret.db := ToText(fieldRef.db);
    ret.catalog := ToText(fieldRef.catalog);
    ret.def := ToText(fieldRef.def);
    ret.length := fieldRef.length;
    ret.max_length := fieldRef.max_length;
    ret.name_length := fieldRef.name_length;
    ret.org_name_length := fieldRef.org_name_length;
    ret.table_length := fieldRef.table_length;
    ret.org_table_length := fieldRef.org_table_length;
    ret.db_length := fieldRef.db_length;
    ret.catalog_length := fieldRef.catalog_length;
    ret.def_length := fieldRef.def_length;
    ret.flags := fieldRef.flags;
    ret.decimals := fieldRef.decimals;
    ret.charsetnr := fieldRef.charsetnr;
    ret.type := fieldRef.type;
    RETURN ret;
  END NewField;

PROCEDURE GetFieldList
  (fieldRef: MySQLRaw.RefMysqlFieldT; numFields: CARDINAL): RefFieldArray =
  VAR ret: RefFieldArray;
  BEGIN
    ret := NEW(RefFieldArray, numFields);
    FOR j := 0 TO numFields - 1 DO
      ret[j] := NewField(fieldRef^);
      INC(fieldRef, BYTESIZE(MySQLRaw.MYSQL_FIELD));
    END;
    RETURN ret;
  END GetFieldList;





PROCEDURE New_MYSQL_FIELD (self: C.int_star; ): C.int_star =
  BEGIN
    RETURN MySQLRaw.New_MYSQL_FIELD();
  END New_MYSQL_FIELD;

PROCEDURE Delete_MYSQL_FIELD (VALUE self: C.int; ) =
  BEGIN
    MySQLRaw.Delete_MYSQL_FIELD(self);
  END Delete_MYSQL_FIELD;



PROCEDURE SetLocalInfileHandler (mysql             : T;
                                 local_infile_init : InitCBT;
                                 local_infile_read : ReadCBT;
                                 local_infile_end  : EndCBT;
                                 local_infile_error: ErrorCBT;
                                 arg6              : ADDRESS;  ) =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);

  PROCEDURE P0 (p1: REF C.void_star; p2: C.char_star; p3: C.void_star):
    C.int =
    VAR
      r1: REF ADDRESS := p1;
      r2              := M3toC.CopyStoT(p2);
      r3              := p3;
    BEGIN
      RETURN local_infile_init(r1, r2, r3);
    END P0;

  PROCEDURE P1 (p1: C.void_star; p2: C.char_star; p3: C.unsigned_int):
    C.int =
    VAR
      r1: ADDRESS := p1;
      r2          := M3toC.CopyStoT(p2);
      r3          := p3;
    BEGIN
      RETURN local_infile_read(r1, r2, r3);
    END P1;

  PROCEDURE P2 (p1: C.void_star; p2: C.char_star; p3: C.unsigned_int):
    C.int =
    VAR
      r1: ADDRESS := p1;
      r2          := M3toC.CopyStoT(p2);
      r3          := p3;
    BEGIN
      RETURN local_infile_error(r1, r2, r3);
    END P2;
  VAR

  BEGIN
    MySQLRaw.SetLocalInfileHandler(rawT, <* NOWARN *> P0, <* NOWARN *> P1,
                                   local_infile_end, <* NOWARN *> P2, arg6);
  END SetLocalInfileHandler;

PROCEDURE SetLocalInfileDefault (mysql: T; ) =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    MySQLRaw.SetLocalInfileDefault(rawT);
  END SetLocalInfileDefault;

PROCEDURE NumRows (res: ResultT; ): LONGINT =
  VAR
    ret   : C.unsigned_long_long;
    result: LONGINT;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.NumRows(arg1);
    result := LOOPHOLE(ret, LONGINT);
    RETURN result;
  END NumRows;

PROCEDURE NumFields (res: ResultT; ): Int32 =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    RETURN MySQLRaw.NumFields(arg1);
  END NumFields;

PROCEDURE Eof (res: ResultT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.Eof(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Eof;

PROCEDURE FetchFieldDirect (res: ResultT; fieldnr: Int32; ): FieldT =
  VAR
    ret   : MySQLRaw.RefMysqlFieldT;
    result: FieldT;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.FetchFieldDirect(arg1, fieldnr);
    result := NewField(ret^);
    RETURN result;
  END FetchFieldDirect;

PROCEDURE FetchFields (res: ResultT; ): RefFieldArray =
  VAR
    ret   : MySQLRaw.RefMysqlFieldT;
    result: RefFieldArray;
    len   : CARDINAL;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.FetchFields(arg1);
    len := MySQLRaw.NumFields(arg1);
    result := GetFieldList(ret, len);
    RETURN result;
  END FetchFields;

PROCEDURE RowTell (res: ResultT; ): RowOffsetT =
  VAR
    ret   : MySQLRaw.RowOffsetT;
    result: RowOffsetT;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.RowTell(arg1);
    result := LOOPHOLE(ret, RowOffsetT);
    RETURN result;
  END RowTell;

PROCEDURE FieldTell (res: ResultT; ): Int32 =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    RETURN MySQLRaw.FieldTell(arg1);
  END FieldTell;

PROCEDURE FieldCount (mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.FieldCount(rawT);
  END FieldCount;

PROCEDURE MoreResults (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.MoreResults(rawT);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END MoreResults;

PROCEDURE NextResult (mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.NextResult(rawT);
  END NextResult;

PROCEDURE AffectedRows (mysql: T; ): LONGINT =
  VAR
    ret   : C.unsigned_long_long;
    result: LONGINT;
    rawT  : MySQLRaw.RefMysqlT   := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.AffectedRows(rawT);
    result := LOOPHOLE(ret, LONGINT);
    RETURN result;
  END AffectedRows;

PROCEDURE Autocommit (mysql: T; mode: BOOLEAN; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2                       := LOOPHOLE(mode, MySQLRaw.my_bool);
  BEGIN
    ret := MySQLRaw.Autocommit(rawT, arg2);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Autocommit;

PROCEDURE Commit (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.Commit(rawT);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Commit;

PROCEDURE Rollback (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.Rollback(rawT);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Rollback;

PROCEDURE InsertId (mysql: T; ): LONGINT =
  VAR
    ret   : C.unsigned_long_long;
    result: LONGINT;
    rawT  : MySQLRaw.RefMysqlT   := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.InsertId(rawT);
    result := LOOPHOLE(ret, LONGINT);
    RETURN result;
  END InsertId;

PROCEDURE Errno (mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.Errno(rawT);
  END Errno;

PROCEDURE Error (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.Error(rawT);
    RETURN M3toC.CopyStoT(result);
  END Error;

PROCEDURE Info (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.Info(rawT);
    RETURN M3toC.CopyStoT(result);
  END Info;

PROCEDURE ThreadId (mysql: T; ): CARDINAL =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.ThreadId(rawT);
  END ThreadId;

PROCEDURE CharacterSetName (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.CharacterSetName(rawT);
    RETURN M3toC.CopyStoT(result);
  END CharacterSetName;

PROCEDURE GetCharacterSetInfo (mysql: T; VAR cs: CharsT; ) =
  VAR
    rawT: MySQLRaw.RefMysqlT      := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2: MySQLRaw.RefMysqlCharsT := LOOPHOLE(cs, MySQLRaw.RefMysqlCharsT);
  BEGIN
    MySQLRaw.GetCharacterSetInfo(rawT, arg2);
  END GetCharacterSetInfo;

PROCEDURE SetCharacterSet (mysql: T; csname: TEXT; ): Int32 =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: Int32;
  BEGIN
    arg2 := NewString(csname);
    result := MySQLRaw.SetCharacterSet(rawT, arg2);
    FreeString(csname, arg2);
    RETURN result;
  END SetCharacterSet;

PROCEDURE Init (mysql: T; ): T =
  VAR
    ret   : MySQLRaw.RefMysqlT;
    result: T;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.Init(rawT);
    result := LOOPHOLE(ret, T);
    RETURN result;
  END Init;

PROCEDURE SslSet (mysql: T; key, cert, ca, capath, cipher: TEXT; ): Int32 =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    arg3  : C.const_char_star;
    arg4  : C.const_char_star;
    arg5  : C.const_char_star;
    arg6  : C.const_char_star;
    result: Int32;
  BEGIN
    arg2 := NewString(key);
    arg3 := NewString(cert);
    arg4 := NewString(ca);
    arg5 := NewString(capath);
    arg6 := NewString(cipher);
    result := MySQLRaw.SslSet(rawT, arg2, arg3, arg4, arg5, arg6);
    FreeString(key, arg2);
    FreeString(cert, arg3);
    FreeString(ca, arg4);
    FreeString(capath, arg5);
    FreeString(cipher, arg6);
    RETURN result;
  END SslSet;

PROCEDURE GetSslCipher (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.GetSslCipher(rawT);
    RETURN M3toC.CopyStoT(result);
  END GetSslCipher;

PROCEDURE ChangeUser (mysql: T; user, passwd, db: TEXT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    arg3  : C.const_char_star;
    arg4  : C.const_char_star;
  BEGIN
    arg2 := NewString(user);
    arg3 := NewString(passwd);
    arg4 := NewString(db);
    ret := MySQLRaw.ChangeUser(rawT, arg2, arg3, arg4);
    result := VAL(ret, BOOLEAN);
    FreeString(user, arg2);
    FreeString(passwd, arg3);
    FreeString(db, arg4);
    RETURN result;
  END ChangeUser;

PROCEDURE RealConnect (mysql                 : T;
                       host, user, passwd, db: TEXT;
                       port                  : Int32;
                       unix_socket           : TEXT;
                       clientflag            : CARDINAL; ): T =
  VAR
    ret   : MySQLRaw.RefMysqlT;
    result: T;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    arg3  : C.const_char_star;
    arg4  : C.const_char_star;
    arg5  : C.const_char_star;
    arg7  : C.const_char_star;
  BEGIN
    arg2 := NewString(host);
    arg3 := NewString(user);
    arg4 := NewString(passwd);
    arg5 := NewString(db);
    arg7 := NewString(unix_socket);
    ret := MySQLRaw.RealConnect(
             rawT, arg2, arg3, arg4, arg5, port, arg7, clientflag);
    result := LOOPHOLE(ret, T);
    FreeString(host, arg2);
    FreeString(user, arg3);
    FreeString(passwd, arg4);
    FreeString(db, arg5);
    FreeString(unix_socket, arg7);
    RETURN result;
  END RealConnect;

PROCEDURE Close (sock: T; ) =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(sock, MySQLRaw.RefMysqlT);
  BEGIN
    MySQLRaw.Close(rawT);
  END Close;

PROCEDURE SelectDb (mysql: T; db: TEXT; ): Int32 =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: Int32;
  BEGIN
    arg2 := NewString(db);
    result := MySQLRaw.SelectDb(rawT, arg2);
    FreeString(db, arg2);
    RETURN result;
  END SelectDb;

PROCEDURE Query (mysql: T; q: TEXT; ): Int32 =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: Int32;
  BEGIN
    arg2 := NewString(q);
    result := MySQLRaw.Query(rawT, arg2);
    FreeString(q, arg2);
    RETURN result;
  END Query;

PROCEDURE SendQuery (mysql: T; q: TEXT; length: CARDINAL; ): Int32 =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: Int32;
  BEGIN
    arg2 := NewString(q);
    result := MySQLRaw.SendQuery(rawT, arg2, length);
    FreeString(q, arg2);
    RETURN result;
  END SendQuery;

PROCEDURE ReadQueryResult (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.ReadQueryResult(rawT);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END ReadQueryResult;

PROCEDURE RealQuery (mysql: T; q: TEXT; length: CARDINAL; ): Int32 =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: Int32;
  BEGIN
    arg2 := NewString(q);
    result := MySQLRaw.RealQuery(rawT, arg2, length);
    FreeString(q, arg2);
    RETURN result;
  END RealQuery;

PROCEDURE Shutdown (mysql: T; shutdown_level: INTEGER; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.Shutdown(rawT, shutdown_level);
  END Shutdown;

PROCEDURE DumpDebugInfo (mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.DumpDebugInfo(rawT);
  END DumpDebugInfo;

PROCEDURE Refresh (mysql: T; refresh_options: Int32; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.Refresh(rawT, refresh_options);
  END Refresh;

PROCEDURE Kill (mysql: T; pid: CARDINAL; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.Kill(rawT, pid);
  END Kill;

PROCEDURE Ping (mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.Ping(rawT);
  END Ping;

PROCEDURE Stat (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.Stat(rawT);
    RETURN M3toC.CopyStoT(result);
  END Stat;

PROCEDURE GetServerInfo (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.GetServerInfo(rawT);
    RETURN M3toC.CopyStoT(result);
  END GetServerInfo;

PROCEDURE GetServerVersion (mysql: T; ): CARDINAL =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.GetServerVersion(rawT);
  END GetServerVersion;

PROCEDURE GetHostInfo (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.GetHostInfo(rawT);
    RETURN M3toC.CopyStoT(result);
  END GetHostInfo;

PROCEDURE GetProtoInfo (mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.GetProtoInfo(rawT);
  END GetProtoInfo;

PROCEDURE ListDbs (mysql: T; wild: TEXT; ): ResultT =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2: C.const_char_star;
  BEGIN
    arg2 := NewString(wild);
    ret := MySQLRaw.ListDbs(rawT, arg2);
    result := LOOPHOLE(ret, ResultT);
    FreeString(wild, arg2);
    RETURN result;
  END ListDbs;

PROCEDURE ListTables (mysql: T; wild: TEXT; ): ResultT =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2: C.const_char_star;
  BEGIN
    arg2 := NewString(wild);
    ret := MySQLRaw.ListTables(rawT, arg2);
    result := LOOPHOLE(ret, ResultT);
    FreeString(wild, arg2);
    RETURN result;
  END ListTables;

PROCEDURE ListFields (mysql: T; table, wild: TEXT; ): ResultT =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2: C.const_char_star;
    arg3: C.const_char_star;
  BEGIN
    arg2 := NewString(table);
    arg3 := NewString(wild);
    ret := MySQLRaw.ListFields(rawT, arg2, arg3);
    result := LOOPHOLE(ret, ResultT);
    FreeString(table, arg2);
    FreeString(wild, arg3);
    RETURN result;
  END ListFields;

PROCEDURE ListProcesses (mysql: T; ): ResultT =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.ListProcesses(rawT);
    result := LOOPHOLE(ret, ResultT);
    RETURN result;
  END ListProcesses;

PROCEDURE StoreResult (mysql: T; ): ResultT =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.StoreResult(rawT);
    result := LOOPHOLE(ret, ResultT);
    RETURN result;
  END StoreResult;

PROCEDURE UseResult (mysql: T; ): ResultT =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.UseResult(rawT);
    result := LOOPHOLE(ret, ResultT);
    RETURN result;
  END UseResult;

PROCEDURE Options (mysql: T; option: INTEGER; arg: ADDRESS; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.Options(rawT, option, arg);
  END Options;

PROCEDURE Options4 (mysql: T; option: INTEGER; arg1, arg2: ADDRESS; ):
  Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.Options4(rawT, option, arg1, arg2);
  END Options4;

PROCEDURE FreeResult (mysql_res: ResultT; ) =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    MySQLRaw.FreeResult(arg1);
  END FreeResult;

PROCEDURE DataSeek (mysql_res: ResultT; offset: LONGINT; ) =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    MySQLRaw.DataSeek(arg1, offset);
  END DataSeek;

PROCEDURE RowSeek (mysql_res: ResultT; VAR arg2_in: RowOffsetT; ):
  RowOffsetT =
  VAR
    ret   : MySQLRaw.RowOffsetT;
    result: RowOffsetT;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
    arg2: MySQLRaw.RowOffsetT := LOOPHOLE(arg2_in, MySQLRaw.RowOffsetT);
  BEGIN
    ret := MySQLRaw.RowSeek(arg1, arg2);
    result := LOOPHOLE(ret, RowOffsetT);
    RETURN result;
  END RowSeek;

PROCEDURE FieldSeek (mysql_res: ResultT; offset: CARDINAL; ): CARDINAL =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    RETURN MySQLRaw.FieldSeek(arg1, offset);
  END FieldSeek;

PROCEDURE FetchRow (mysql_res: ResultT; ): REF ARRAY OF TEXT =
  VAR
    ret      : C.char_star_star;
    result   : RefRow;
    numFields: INTEGER;
    row      : REF ARRAY OF TEXT;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.FetchRow(arg1);
    IF ret = NIL THEN
      row := NIL;
    ELSE
      result := LOOPHOLE(ret, RefRow);
      numFields := NumFields(mysql_res);
      row := NEW(REF ARRAY OF TEXT, numFields);
      FOR i := 0 TO numFields - 1 DO
        (* DB NULL results in NIL M3 text *)
        IF result[i] # NIL THEN row[i] := M3toC.CopyStoT(result[i]) END;
      END;
    END;
    RETURN row;
  END FetchRow;

PROCEDURE FetchLengths (mysql_res: ResultT; ): RefLengthsT =
  VAR
    ret   : C.unsigned_long_star;
    result: RefLengthsT;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.FetchLengths(arg1);
    result := LOOPHOLE(ret, RefLengthsT);
    RETURN result;
  END FetchLengths;

PROCEDURE FetchField (mysql_res: ResultT; ): FieldT =
  VAR
    ret   : MySQLRaw.RefMysqlFieldT;
    result: FieldT;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.FetchField(arg1);
    result := NewField(ret^);
    RETURN result;
  END FetchField;

PROCEDURE EscapeString (to, from: TEXT; from_length: CARDINAL; ):
  CARDINAL =
  VAR
    arg1  : C.char_star;
    arg2  : C.const_char_star;
    result: CARDINAL;
  BEGIN
    arg1 := NewString(to);
    arg2 := NewString(from);
    result := MySQLRaw.EscapeString(arg1, arg2, from_length);
    FreeString(to, arg1);
    FreeString(from, arg2);
    RETURN result;
  END EscapeString;

PROCEDURE RealEscapeString (mysql: T; to, from: TEXT; length: CARDINAL; ):
  CARDINAL =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.char_star;
    arg3  : C.const_char_star;
    result: CARDINAL;
  BEGIN
    arg2 := NewString(to);
    arg3 := NewString(from);
    result := MySQLRaw.RealEscapeString(rawT, arg2, arg3, length);
    FreeString(to, arg2);
    FreeString(from, arg3);
    RETURN result;
  END RealEscapeString;

PROCEDURE ThreadSafe (): Int32 =
  BEGIN
    RETURN MySQLRaw.ThreadSafe();
  END ThreadSafe;

PROCEDURE WarningCount (mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.WarningCount(rawT);
  END WarningCount;

PROCEDURE Sqlstate (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.Sqlstate(rawT);
    RETURN M3toC.CopyStoT(result);
  END Sqlstate;

PROCEDURE ServerInit (argc: Int32; READONLY argv, groups: ARRAY OF TEXT; ):
  Int32 =
  VAR
    arg2  : C.char_star;
    arg3  : C.char_star;
    result: Int32;
  BEGIN
    arg2 := NewString(argv[0]);
    arg3 := NewString(groups[0]);
    result := MySQLRaw.ServerInit(argc, arg2, arg3);
    FreeString(argv[0], arg2);
    FreeString(groups[0], arg3);
    RETURN result;
  END ServerInit;

PROCEDURE ServerEnd () =
  BEGIN
    MySQLRaw.ServerEnd();
  END ServerEnd;

PROCEDURE ThreadEnd () =
  BEGIN
    MySQLRaw.ThreadEnd();
  END ThreadEnd;

PROCEDURE ThreadInit (): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
  BEGIN
    ret := MySQLRaw.ThreadInit();
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END ThreadInit;

PROCEDURE SetServerOption (mysql: T; option: INTEGER; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.SetServerOption(rawT, option);
  END SetServerOption;

PROCEDURE GetClientInfo (): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := MySQLRaw.GetClientInfo();
    RETURN M3toC.CopyStoT(result);
  END GetClientInfo;

PROCEDURE GetClientVersion (): CARDINAL =
  BEGIN
    RETURN MySQLRaw.GetClientVersion();
  END GetClientVersion;

(*  
PROCEDURE GetServerName (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.GetServerName(rawT);
    RETURN M3toC.CopyStoT(result);
  END GetServerName;

PROCEDURE GetOption (mysql: T; option: INTEGER; arg: ADDRESS; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.GetOption(rawT, option, arg);
  END GetOption;
*)

PROCEDURE HexString (to, from: TEXT; len: CARDINAL; ): CARDINAL =
  VAR
    arg1  : C.char_star;
    arg2  : C.const_char_star;
    result: CARDINAL;
  BEGIN
    arg1 := NewString(to);
    arg2 := NewString(from);
    result := MySQLRaw.HexString(arg1, arg2, len);
    FreeString(to, arg1);
    FreeString(from, arg2);
    RETURN result;
  END HexString;

PROCEDURE GetSocket (mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.GetSocket(rawT);
  END GetSocket;

PROCEDURE GetTimeoutValue (mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.GetTimeoutValue(rawT);
  END GetTimeoutValue;

PROCEDURE GetTimeoutValueMs (mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.GetTimeoutValueMs(rawT);
  END GetTimeoutValueMs;

PROCEDURE Debug (debug: TEXT; ) =
  VAR arg1: C.const_char_star;
  BEGIN
    arg1 := NewString(debug);
    MySQLRaw.Debug(arg1);
    FreeString(debug, arg1);
  END Debug;

PROCEDURE NetReadPacket (mysql: T; ): CARDINAL =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.NetReadPacket(rawT);
  END NetReadPacket;

PROCEDURE NetFieldLength (READONLY packet: ARRAY OF TEXT; ): CARDINAL =
  VAR
    arg1  : C.char_star;
    result: CARDINAL;
  BEGIN
    arg1 := NewString(packet[0]);
    result := MySQLRaw.NetFieldLength(arg1);
    FreeString(packet[0], arg1);
    RETURN result;
  END NetFieldLength;

PROCEDURE Embedded (): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
  BEGIN
    ret := MySQLRaw.Embedded();
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Embedded;

PROCEDURE GetParameters (): ParametersT =
  VAR
    ret   : MySQLRaw.RefMysqlParametersT;
    result: ParametersT;
  BEGIN
    ret := MySQLRaw.GetParameters();
    result := LOOPHOLE(ret, ParametersT);
    RETURN result;
  END GetParameters;

PROCEDURE CloseStart (sock: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(sock, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.CloseStart(rawT);
  END CloseStart;

PROCEDURE CloseCont (sock: T; status: Int32; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(sock, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.CloseCont(rawT, status);
  END CloseCont;

PROCEDURE CommitStart (ret: TEXT; mysql: T; ): Int32 =
  VAR
    arg1  : C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.CommitStart(arg1, rawT);
    FreeString(ret, arg1);
    RETURN result;
  END CommitStart;

PROCEDURE CommitCont (ret: TEXT; mysql: T; status: Int32; ): Int32 =
  VAR
    arg1  : C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.CommitCont(arg1, rawT, status);
    FreeString(ret, arg1);
    RETURN result;
  END CommitCont;

PROCEDURE DumpDebugInfoCont
  (VAR ret: Int32; mysql: T; ready_status: Int32; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.DumpDebugInfoCont(ret, rawT, ready_status);
  END DumpDebugInfoCont;

PROCEDURE DumpDebugInfoStart (VAR ret: Int32; mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.DumpDebugInfoStart(ret, rawT);
  END DumpDebugInfoStart;

PROCEDURE RollbackStart (ret: TEXT; mysql: T; ): Int32 =
  VAR
    arg1  : C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.RollbackStart(arg1, rawT);
    FreeString(ret, arg1);
    RETURN result;
  END RollbackStart;

PROCEDURE RollbackCont (ret: TEXT; mysql: T; status: Int32; ): Int32 =
  VAR
    arg1  : C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.RollbackCont(arg1, rawT, status);
    FreeString(ret, arg1);
    RETURN result;
  END RollbackCont;

PROCEDURE AutocommitStart (ret: TEXT; mysql: T; auto_mode: BOOLEAN; ):
  Int32 =
  VAR
    arg1  : C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3                       := LOOPHOLE(auto_mode, MySQLRaw.my_bool);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.AutocommitStart(arg1, rawT, arg3);
    FreeString(ret, arg1);
    RETURN result;
  END AutocommitStart;

PROCEDURE ListFieldsCont (ret: ResultT; mysql: T; ready_status: Int32; ):
  Int32 =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        ret, MySQLRaw.RefMysqlResultT);
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.ListFieldsCont(arg1, rawT, ready_status);
  END ListFieldsCont;

PROCEDURE ListFieldsStart (ret: ResultT; mysql: T; table, wild: TEXT; ):
  Int32 =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        ret, MySQLRaw.RefMysqlResultT);
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3  : C.const_char_star;
    arg4  : C.const_char_star;
    result: Int32;
  BEGIN
    arg3 := NewString(table);
    arg4 := NewString(wild);
    result := MySQLRaw.ListFieldsStart(arg1, rawT, arg3, arg4);
    FreeString(table, arg3);
    FreeString(wild, arg4);
    RETURN result;
  END ListFieldsStart;

PROCEDURE AutocommitCont (ret: TEXT; mysql: T; status: Int32; ): Int32 =
  VAR
    arg1  : C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.AutocommitCont(arg1, rawT, status);
    FreeString(ret, arg1);
    RETURN result;
  END AutocommitCont;

PROCEDURE NextResultStart (VAR ret: Int32; mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.NextResultStart(ret, rawT);
  END NextResultStart;

PROCEDURE NextResultCont (VAR ret: Int32; mysql: T; status: Int32; ):
  Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.NextResultCont(ret, rawT, status);
  END NextResultCont;

PROCEDURE SelectDbStart (VAR ret: Int32; mysql: T; db: TEXT; ): Int32 =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3  : C.const_char_star;
    result: Int32;
  BEGIN
    arg3 := NewString(db);
    result := MySQLRaw.SelectDbStart(ret, rawT, arg3);
    FreeString(db, arg3);
    RETURN result;
  END SelectDbStart;

PROCEDURE SelectDbCont (VAR ret: Int32; mysql: T; ready_status: Int32; ):
  Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.SelectDbCont(ret, rawT, ready_status);
  END SelectDbCont;

(*  
PROCEDURE StmtWarningCount (stmt: StmtT; ): Int32 =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtWarningCount(arg1);
  END StmtWarningCount;
*)
PROCEDURE StmtNextResultStart (VAR ret: Int32; stmt: StmtT; ): Int32 =
  VAR
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtNextResultStart(ret, arg2);
  END StmtNextResultStart;

PROCEDURE StmtNextResultCont
  (VAR ret: Int32; stmt: StmtT; status: Int32; ): Int32 =
  VAR
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtNextResultCont(ret, arg2, status);
  END StmtNextResultCont;

PROCEDURE SetCharacterSetStart (VAR ret: Int32; mysql: T; csname: TEXT; ):
  Int32 =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3  : C.const_char_star;
    result: Int32;
  BEGIN
    arg3 := NewString(csname);
    result := MySQLRaw.SetCharacterSetStart(ret, rawT, arg3);
    FreeString(csname, arg3);
    RETURN result;
  END SetCharacterSetStart;

PROCEDURE SetCharacterSetCont (VAR ret: Int32; mysql: T; status: Int32; ):
  Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.SetCharacterSetCont(ret, rawT, status);
  END SetCharacterSetCont;

PROCEDURE ChangeUserStart (ret: TEXT; mysql: T; user, passwd, db: TEXT; ):
  Int32 =
  VAR
    arg1  : C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3  : C.const_char_star;
    arg4  : C.const_char_star;
    arg5  : C.const_char_star;
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    arg3 := NewString(user);
    arg4 := NewString(passwd);
    arg5 := NewString(db);
    result := MySQLRaw.ChangeUserStart(arg1, rawT, arg3, arg4, arg5);
    FreeString(ret, arg1);
    FreeString(user, arg3);
    FreeString(passwd, arg4);
    FreeString(db, arg5);
    RETURN result;
  END ChangeUserStart;

PROCEDURE ChangeUserCont (ret: TEXT; mysql: T; status: Int32; ): Int32 =
  VAR
    arg1  : C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.ChangeUserCont(arg1, rawT, status);
    FreeString(ret, arg1);
    RETURN result;
  END ChangeUserCont;

PROCEDURE RealConnectStart (VAR ret                   : T;
                                mysql                 : T;
                                host, user, passwd, db: TEXT;
                                port                  : Int32;
                                unix_socket           : TEXT;
                                clientflag            : CARDINAL; ):
  Int32 =
  VAR
    raw1T : MySQLRaw.RefMysqlT := LOOPHOLE(ret, MySQLRaw.RefMysqlT);
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3  : C.const_char_star;
    arg4  : C.const_char_star;
    arg5  : C.const_char_star;
    arg6  : C.const_char_star;
    arg8  : C.const_char_star;
    result: Int32;
  BEGIN
    arg3 := NewString(host);
    arg4 := NewString(user);
    arg5 := NewString(passwd);
    arg6 := NewString(db);
    arg8 := NewString(unix_socket);
    result := MySQLRaw.RealConnectStart(raw1T, rawT, arg3, arg4, arg5,
                                        arg6, port, arg8, clientflag);
    FreeString(host, arg3);
    FreeString(user, arg4);
    FreeString(passwd, arg5);
    FreeString(db, arg6);
    FreeString(unix_socket, arg8);
    RETURN result;
  END RealConnectStart;

PROCEDURE RealConnectCont (VAR ret: T; mysql: T; status: Int32; ): Int32 =
  VAR
    raw1T: MySQLRaw.RefMysqlT := LOOPHOLE(ret, MySQLRaw.RefMysqlT);
    rawT : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.RealConnectCont(raw1T, rawT, status);
  END RealConnectCont;

PROCEDURE QueryStart (VAR ret: Int32; mysql: T; q: TEXT; ): Int32 =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3  : C.const_char_star;
    result: Int32;
  BEGIN
    arg3 := NewString(q);
    result := MySQLRaw.QueryStart(ret, rawT, arg3);
    FreeString(q, arg3);
    RETURN result;
  END QueryStart;

PROCEDURE QueryCont (VAR ret: Int32; mysql: T; status: Int32; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.QueryCont(ret, rawT, status);
  END QueryCont;

PROCEDURE SendQueryStart
  (VAR ret: Int32; mysql: T; q: TEXT; length: CARDINAL; ): Int32 =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3  : C.const_char_star;
    result: Int32;
  BEGIN
    arg3 := NewString(q);
    result := MySQLRaw.SendQueryStart(ret, rawT, arg3, length);
    FreeString(q, arg3);
    RETURN result;
  END SendQueryStart;

PROCEDURE SendQueryCont (VAR ret: Int32; mysql: T; status: Int32; ):
  Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.SendQueryCont(ret, rawT, status);
  END SendQueryCont;

PROCEDURE RealQueryStart
  (VAR ret: Int32; mysql: T; q: TEXT; length: CARDINAL; ): Int32 =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3  : C.const_char_star;
    result: Int32;
  BEGIN
    arg3 := NewString(q);
    result := MySQLRaw.RealQueryStart(ret, rawT, arg3, length);
    FreeString(q, arg3);
    RETURN result;
  END RealQueryStart;

PROCEDURE RealQueryCont (VAR ret: Int32; mysql: T; status: Int32; ):
  Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.RealQueryCont(ret, rawT, status);
  END RealQueryCont;

PROCEDURE StoreResultStart (ret: ResultT; mysql: T; ): Int32 =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        ret, MySQLRaw.RefMysqlResultT);
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.StoreResultStart(arg1, rawT);
  END StoreResultStart;

PROCEDURE StoreResultCont (ret: ResultT; mysql: T; status: Int32; ):
  Int32 =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        ret, MySQLRaw.RefMysqlResultT);
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.StoreResultCont(arg1, rawT, status);
  END StoreResultCont;

PROCEDURE ShutdownStart
  (VAR ret: Int32; mysql: T; shutdown_level: INTEGER; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.ShutdownStart(ret, rawT, shutdown_level);
  END ShutdownStart;

PROCEDURE ShutdownCont (VAR ret: Int32; mysql: T; status: Int32; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.ShutdownCont(ret, rawT, status);
  END ShutdownCont;

PROCEDURE RefreshStart
  (VAR ret: Int32; mysql: T; refresh_options: Int32; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.RefreshStart(ret, rawT, refresh_options);
  END RefreshStart;

PROCEDURE RefreshCont (VAR ret: Int32; mysql: T; status: Int32; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.RefreshCont(ret, rawT, status);
  END RefreshCont;

PROCEDURE KillStart (VAR ret: Int32; mysql: T; pid: CARDINAL; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.KillStart(ret, rawT, pid);
  END KillStart;

PROCEDURE KillCont (VAR ret: Int32; mysql: T; status: Int32; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.KillCont(ret, rawT, status);
  END KillCont;

PROCEDURE SetServerOptionStart
  (VAR ret: Int32; mysql: T; option: INTEGER; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.SetServerOptionStart(ret, rawT, option);
  END SetServerOptionStart;

PROCEDURE SetServerOptionCont (VAR ret: Int32; mysql: T; status: Int32; ):
  Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.SetServerOptionCont(ret, rawT, status);
  END SetServerOptionCont;

PROCEDURE PingStart (VAR ret: Int32; mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.PingStart(ret, rawT);
  END PingStart;

PROCEDURE PingCont (VAR ret: Int32; mysql: T; status: Int32; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.PingCont(ret, rawT, status);
  END PingCont;

PROCEDURE StatStart (READONLY ret: ARRAY OF TEXT; mysql: T; ): Int32 =
  VAR
    arg1  : C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret[0]);
    result := MySQLRaw.StatStart(arg1, rawT);
    FreeString(ret[0], arg1);
    RETURN result;
  END StatStart;

PROCEDURE StatCont
  (READONLY ret: ARRAY OF TEXT; mysql: T; status: Int32; ): Int32 =
  VAR
    arg1  : C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret[0]);
    result := MySQLRaw.StatCont(arg1, rawT, status);
    FreeString(ret[0], arg1);
    RETURN result;
  END StatCont;

PROCEDURE FreeResultStart (mysql_res: ResultT; ): Int32 =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    RETURN MySQLRaw.FreeResultStart(arg1);
  END FreeResultStart;

PROCEDURE FreeResultCont (mysql_res: ResultT; status: Int32; ): Int32 =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    RETURN MySQLRaw.FreeResultCont(arg1, status);
  END FreeResultCont;

PROCEDURE FetchRowStart (VAR ret: REF ARRAY OF TEXT; mysql_res: ResultT; ):
  Int32 =
  VAR
    numFields: INTEGER;
    res      : RefRow;
    arg1               := LOOPHOLE(ret, C.char_star_star);
    arg2: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
    result: Int32;
  BEGIN
    result := MySQLRaw.FetchRowStart(arg1, arg2);

    IF arg1 = NIL THEN
      ret := NIL;
    ELSE
      res := LOOPHOLE(arg1, RefRow);
      numFields := NumFields(mysql_res);
      ret := NEW(REF ARRAY OF TEXT, numFields);
      FOR i := 0 TO numFields - 1 DO
        (* DB NULL results in NIL M3 text *)
        IF res[i] # NIL THEN ret[i] := M3toC.CopyStoT(res[i]) END;
      END;
    END;

    RETURN result;
  END FetchRowStart;

PROCEDURE FetchRowCont
  (VAR ret: REF ARRAY OF TEXT; mysql_res: ResultT; status: Int32; ):
  Int32 =
  VAR
    numFields: INTEGER;
    res      : RefRow;
    arg1               := LOOPHOLE(ret, C.char_star_star);
    arg2: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
    result: Int32;
  BEGIN
    result := MySQLRaw.FetchRowCont(arg1, arg2, status);

    IF arg1 = NIL THEN
      ret := NIL;
    ELSE
      res := LOOPHOLE(arg1, RefRow);
      numFields := NumFields(mysql_res);
      ret := NEW(REF ARRAY OF TEXT, numFields);
      FOR i := 0 TO numFields - 1 DO
        (* DB NULL results in NIL M3 text *)
        IF res[i] # NIL THEN ret[i] := M3toC.CopyStoT(res[i]) END;
      END;
    END;

    RETURN result;
  END FetchRowCont;

PROCEDURE ReadQueryResultStart (ret: TEXT; mysql: T; ): Int32 =
  VAR
    arg1  : C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.ReadQueryResultStart(arg1, rawT);
    FreeString(ret, arg1);
    RETURN result;
  END ReadQueryResultStart;

PROCEDURE ReadQueryResultCont (ret: TEXT; mysql: T; status: Int32; ):
  Int32 =
  VAR
    arg1  : C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.ReadQueryResultCont(arg1, rawT, status);
    FreeString(ret, arg1);
    RETURN result;
  END ReadQueryResultCont;
(*
PROCEDURE ResetConnectionStart (VAR ret: Int32; mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.ResetConnectionStart(ret, rawT);
  END ResetConnectionStart;

PROCEDURE ResetConnectionCont (VAR ret: Int32; mysql: T; status: Int32; ):
  Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.ResetConnectionCont(ret, rawT, status);
  END ResetConnectionCont;

PROCEDURE SessionTrackGetNext (         mysql : T;
                                        type  : INTEGER;
                               READONLY data  : ARRAY OF TEXT;
                               VAR      length: INTEGER;       ): Int32 =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3  : C.char_star;
    result: Int32;
  BEGIN
    arg3 := NewString(data[0]);
    result := MySQLRaw.SessionTrackGetNext(rawT, type, arg3, length);
    FreeString(data[0], arg3);
    RETURN result;
  END SessionTrackGetNext;

PROCEDURE SessionTrackGetFirst (         mysql : T;
                                         type  : INTEGER;
                                READONLY data  : ARRAY OF TEXT;
                                VAR      length: INTEGER;       ): Int32 =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3  : C.char_star;
    result: Int32;
  BEGIN
    arg3 := NewString(data[0]);
    result := MySQLRaw.SessionTrackGetFirst(rawT, type, arg3, length);
    FreeString(data[0], arg3);
    RETURN result;
  END SessionTrackGetFirst;
*)
PROCEDURE StmtPrepareStart
  (VAR ret: Int32; stmt: StmtT; query: TEXT; length: CARDINAL; ): Int32 =
  VAR
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg3: C.const_char_star;
    result: Int32;
  BEGIN
    arg3 := NewString(query);
    result := MySQLRaw.StmtPrepareStart(ret, arg2, arg3, length);
    FreeString(query, arg3);
    RETURN result;
  END StmtPrepareStart;

PROCEDURE StmtPrepareCont (VAR ret: Int32; stmt: StmtT; status: Int32; ):
  Int32 =
  VAR
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtPrepareCont(ret, arg2, status);
  END StmtPrepareCont;

PROCEDURE StmtExecuteStart (VAR ret: Int32; stmt: StmtT; ): Int32 =
  VAR
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtExecuteStart(ret, arg2);
  END StmtExecuteStart;

PROCEDURE StmtExecuteCont (VAR ret: Int32; stmt: StmtT; status: Int32; ):
  Int32 =
  VAR
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtExecuteCont(ret, arg2, status);
  END StmtExecuteCont;

PROCEDURE StmtFetchStart (VAR ret: Int32; stmt: StmtT; ): Int32 =
  VAR
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtFetchStart(ret, arg2);
  END StmtFetchStart;

PROCEDURE StmtFetchCont (VAR ret: Int32; stmt: StmtT; status: Int32; ):
  Int32 =
  VAR
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtFetchCont(ret, arg2, status);
  END StmtFetchCont;

PROCEDURE StmtStoreResultStart (VAR ret: Int32; stmt: StmtT; ): Int32 =
  VAR
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtStoreResultStart(ret, arg2);
  END StmtStoreResultStart;

PROCEDURE StmtStoreResultCont
  (VAR ret: Int32; stmt: StmtT; status: Int32; ): Int32 =
  VAR
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtStoreResultCont(ret, arg2, status);
  END StmtStoreResultCont;

PROCEDURE StmtCloseStart (ret: TEXT; stmt: StmtT; ): Int32 =
  VAR
    arg1: C.char_star;
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.StmtCloseStart(arg1, arg2);
    FreeString(ret, arg1);
    RETURN result;
  END StmtCloseStart;

PROCEDURE StmtCloseCont (ret: TEXT; stmt: StmtT; status: Int32; ): Int32 =
  VAR
    arg1: C.char_star;
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.StmtCloseCont(arg1, arg2, status);
    FreeString(ret, arg1);
    RETURN result;
  END StmtCloseCont;

PROCEDURE StmtResetStart (ret: TEXT; stmt: StmtT; ): Int32 =
  VAR
    arg1: C.char_star;
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.StmtResetStart(arg1, arg2);
    FreeString(ret, arg1);
    RETURN result;
  END StmtResetStart;

PROCEDURE StmtResetCont (ret: TEXT; stmt: StmtT; status: Int32; ): Int32 =
  VAR
    arg1: C.char_star;
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.StmtResetCont(arg1, arg2, status);
    FreeString(ret, arg1);
    RETURN result;
  END StmtResetCont;

PROCEDURE StmtFreeResultStart (ret: TEXT; stmt: StmtT; ): Int32 =
  VAR
    arg1: C.char_star;
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.StmtFreeResultStart(arg1, arg2);
    FreeString(ret, arg1);
    RETURN result;
  END StmtFreeResultStart;

PROCEDURE StmtFreeResultCont (ret: TEXT; stmt: StmtT; status: Int32; ):
  Int32 =
  VAR
    arg1: C.char_star;
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.StmtFreeResultCont(arg1, arg2, status);
    FreeString(ret, arg1);
    RETURN result;
  END StmtFreeResultCont;

PROCEDURE StmtSendLongDataStart (ret         : TEXT;
                                 stmt        : StmtT;
                                 param_number: Int32;
                                 data        : TEXT;
                                 len         : CARDINAL; ): Int32 =
  VAR
    arg1: C.char_star;
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg4: C.const_char_star;
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    arg4 := NewString(data);
    result :=
      MySQLRaw.StmtSendLongDataStart(arg1, arg2, param_number, arg4, len);
    FreeString(ret, arg1);
    FreeString(data, arg4);
    RETURN result;
  END StmtSendLongDataStart;

PROCEDURE StmtSendLongDataCont (ret: TEXT; stmt: StmtT; status: Int32; ):
  Int32 =
  VAR
    arg1: C.char_star;
    arg2: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: Int32;
  BEGIN
    arg1 := NewString(ret);
    result := MySQLRaw.StmtSendLongDataCont(arg1, arg2, status);
    FreeString(ret, arg1);
    RETURN result;
  END StmtSendLongDataCont;
(*
PROCEDURE ResetConnection (mysql: T; ): Int32 =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.ResetConnection(rawT);
  END ResetConnection;
*)

BEGIN
END MySQL.
